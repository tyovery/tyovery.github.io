<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç„¡é™å°æ±º</title>
    <style>
        :root {
            --primary: #667eea; --secondary: #764ba2; --success: #48bb78;
            --danger: #f56565; --info: #4299e1; --warning: #9f7aea; --gray: #718096;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            min-height: 100vh; color: #333;
        }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; color: white; margin-bottom: 0px; padding: 0px; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .nav-buttons { display: flex; justify-content: center; gap: 20px; margin-bottom: 15px; }
        .btn {
            padding: 12px 30px; border: none; border-radius: 25px; font-size: 16px;
            font-weight: bold; cursor: pointer; transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0,0,0,0.2); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-nav { background: white; color: #333; }
        .btn-nav.active { background: #4a5568; color: white; }
        .btn-primary { background: var(--success); color: white; }
        .btn-info { background: var(--info); color: white; }
        .btn-warning { background: var(--warning); color: white; }
        .btn-danger { background: var(--danger); color: white; }
        .btn-gray { background: var(--gray); color: white; }
        .page { display: none; animation: fadeIn 0.5s; }
        .page.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .card { background: white; border-radius: 20px; padding: 30px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; font-weight: bold; margin-bottom: 5px; }
        .form-control {
            width: 100%; padding: 10px; border: 2px solid #e2e8f0;
            border-radius: 10px; font-size: 16px;
        }
        .vs-container { display: grid; grid-template-columns: 1fr auto 1fr; gap: 30px; align-items: center; margin-bottom: 30px; }
        .option-card {
			background: #f7fafc; border-radius: 15px; padding: 20px; text-align: center;
			transition: all 0.3s;
			position: relative; /* æ·»åŠ ç›¸å¯¹å®šä½ï¼Œä½¿score-changeèƒ½ç›¸å¯¹äºå®ƒå®šä½ */
			min-height: 200px; /* ç¡®ä¿æœ‰è¶³å¤Ÿçš„æœ€å°é«˜åº¦ */
		}
        .option-card:hover { transform: scale(1.05); background: #edf2f7; box-shadow: 0 10px 25px rgba(0,0,0,0.15); }
        .option-title { font-size: 1.5em; font-weight: bold; margin-bottom: 15px; color: #2d3748; }
        .video-container {
            width: 100%; aspect-ratio: 16/9; background: #000; border-radius: 10px;
            overflow: hidden; margin-bottom: 15px; position: relative;
        }
        .video-container iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; }
        .reload-btn, .invalid-btn {
            position: absolute; top: 10px; background: rgba(255,255,255,0.9);
            border: none; border-radius: 50%; cursor: pointer; z-index: 10; transition: all 0.3s;
        }
        .reload-btn { right: 10px; width: 35px; height: 35px; display: flex; align-items: center; justify-content: center; }
        .reload-btn:hover { background: white; transform: rotate(180deg); }
        .invalid-btn { left: 10px; padding: 5px 10px; border-radius: 15px; font-size: 12px; }
        .invalid-btn.active { background: var(--danger); color: white; }
        .vs-text { font-size: 3em; font-weight: bold; color: #e53e3e; text-shadow: 2px 2px 4px rgba(0,0,0,0.1); }
        .item-stats { background: rgba(255,255,255,0.95); border-radius: 10px; padding: 10px; margin-top: 10px; font-size: 0.9em; }
        .score-change {
			margin-top: 10px; font-size: 1.5em; font-weight: bold; opacity: 0;
			animation: scoreFloat 2s ease-out;
			position: absolute; /* æ”¹ä¸ºç»å¯¹å®šä½ */
			bottom: 10px; /* è·ç¦»åº•éƒ¨10px */
			left: 0;
			right: 0;
			text-align: center;
			z-index: 5;
		}
        .score-change.positive { color: var(--success); }
        .score-change.negative { color: var(--danger); }
        @keyframes scoreFloat { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(30px); } }
        .vote-slider-container {
            background: linear-gradient(90deg, var(--success) 0%, #f7fafc 50%, var(--danger) 100%);
            border-radius: 50px; padding: 5px; margin: 30px auto; max-width: 600px;
            position: relative; /* æ–°å¢ï¼šç‚ºåˆ†æ•¸å‹•ç•«å®šä½ */
        }
        .vote-slider {
            width: 100%; height: 60px; -webkit-appearance: none; appearance: none;
            background: transparent; outline: none; cursor: pointer;
        }
        .vote-slider::-webkit-slider-thumb {
            -webkit-appearance: none; width: 50px; height: 50px; background: white;
            cursor: pointer; border-radius: 50%; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .flex-center { display: flex; justify-content: center; gap: 20px; margin: 30px auto; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-top: 20px; }
        .stat-card {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white; border-radius: 15px; padding: 20px; text-align: center;
        }
        .stat-value { font-size: 2.5em; font-weight: bold; margin-bottom: 10px; }
        .list-item {
            background: #f7fafc; border-radius: 10px; padding: 15px; margin-bottom: 10px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .list-item.editing { background: #e6fffa; border: 2px solid var(--info); }
        .item-info { flex: 1; display: flex; gap: 15px; align-items: center; }
        .item-preview { width: 160px; height: 90px; background: #000; border-radius: 5px; overflow: hidden; position: relative; flex-shrink: 0; }
        .item-preview iframe { width: 100%; height: 100%; border: none; }
        .pagination { display: flex; gap: 5px; align-items: center; justify-content: center; }
        .hidden { display: none !important; }
        .invalid-link { color: var(--danger) !important; text-decoration: line-through; }
        .filter-controls { display: flex; gap: 10px; align-items: center; }
        .checkbox-container { display: flex; align-items: center; gap: 5px; }
        .toggle-btn { 
            padding: 8px 16px; border: 2px solid var(--gray); border-radius: 20px; 
            background: white; color: var(--gray); cursor: pointer; transition: all 0.3s;
        }
        .toggle-btn.active { 
            background: var(--danger); color: white; border-color: var(--danger);
        }
        .game-settings-row {
            display: flex; gap: 20px; align-items: center; justify-content: center; flex-wrap: wrap; margin-bottom: 30px;
        }
        .game-settings-row .form-group {
            margin-bottom: 0;
        }
        .game-settings-row label {
            margin-right: 5px;
        }
        .mood-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .mood-btn {
            font-size: 1.5em;
            background: none;
            border: 2px solid #e2e8f0;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .mood-btn.active {
            background: var(--primary);
            border-color: var(--primary);
            transform: scale(1.1);
        }
        .mood-display {
            display: flex;
            gap: 5px;
            margin-right: 10px;
        }
        .mood-filter-btn {
            font-size: 1.2em;
            background: none;
            border: 2px solid #e2e8f0;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            cursor: pointer;
            transition: all 0.3s;
        }
		.mood-filter-buttons {
			display: flex;
			gap: 5px;
			flex-wrap: nowrap;
		}
        .mood-filter-btn.active {
            background: var(--primary);
            border-color: var(--primary);
            transform: scale(1.1);
        }
        .mood-filter-container {
            display: flex;
            gap: 5px;
            align-items: center;
            flex-wrap: nowrap; /* çµ±è¨ˆé å¿ƒæƒ…æŒ‰éˆ•ä¸€è¡Œé¡¯ç¤º */
            padding: 5px 0;
        }
        .mood-filter-row {
            display: flex;
            gap: 5px;
            width: 100%;
            justify-content: center;
        }
        .clear-invalid-btn {
            background: var(--warning) !important;
            color: white !important;
        }
        /* æŠ•ç¥¨é å¿ƒæƒ…ç¯©é¸å€åŸŸæ¨£å¼ */
        .voting-mood-filter-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }
        .voting-mood-filter-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .voting-keyword-filter {
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative;
        }
        .clear-filter-btn {
            position: absolute;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.2em;
            cursor: pointer;
            color: var(--gray);
            transition: all 0.3s;
        }
        .clear-filter-btn:hover {
            color: var(--danger);
            transform: scale(1.1);
        }
        /* è¨­å®šé é …ç›®ç·¨è¼¯å¿ƒæƒ…æŒ‰éˆ•æ¨£å¼ */
        .edit-mood-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        .edit-mood-btn {
            font-size: 1.2em;
            background: none;
            border: 2px solid #e2e8f0;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .edit-mood-btn.active {
            background: var(--primary);
            border-color: var(--primary);
            transform: scale(1.1);
        }
        /* è¨­å®šé é …ç›®åˆ—è¡¨ä¸­çš„å¿ƒæƒ…æŒ‰éˆ•æ¨£å¼ */
        .item-mood-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        .item-mood-btn {
            font-size: 1.2em;
            background: none;
            border: 2px solid #e2e8f0;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .item-mood-btn.active {
            background: var(--primary);
            border-color: var(--primary);
            transform: scale(1.1);
        }
        /* ç•¶å‰å½±ç‰‡URLæ¨£å¼ */
        .current-video-url {
            font-size: 0.8em;
            color: var(--gray);
            margin-top: 5px;
            word-break: break-all;
            max-height: 60px;
            overflow-y: auto;
            background: rgba(0,0,0,0.05);
            padding: 5px;
            border-radius: 5px;
        }
        /* æ–°å¢ï¼šæŠ•ç¥¨æ»‘æ¡¿æ—çš„åˆ†æ•¸å‹•ç•«æ¨£å¼ */
        .slider-score-change {
            position: absolute;
            top: -40px;
            font-size: 1.8em;
            font-weight: bold;
            opacity: 0;
            z-index: 10;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .slider-score-change.positive { color: var(--success); }
        .slider-score-change.negative { color: var(--danger); }
        .slider-score-change.left { 
            left: 10%; 
            animation: scoreFloatLeft 2s ease-out;
        }
        .slider-score-change.right { 
            right: 10%; 
            animation: scoreFloatRight 2s ease-out;
        }
		.slider-score-change.zero { color: var(--gray); }
        @keyframes scoreFloatLeft { 
            0% { opacity: 1; transform: translateX(0); } 
            100% { opacity: 0; transform: translateX(-50px); } 
        }
        @keyframes scoreFloatRight { 
            0% { opacity: 1; transform: translateX(0); } 
            100% { opacity: 0; transform: translateX(50px); } 
        }
        /* æ–°å¢ï¼šå¿ƒæƒ…é‚è¼¯ä¸‹æ‹‰é¸å–®æ¨£å¼ */
        .mood-logic-select {
            padding: 5px 10px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }
        .mood-logic-select:focus {
            outline: none;
            border-color: var(--primary);
        }
        /* æ–°å¢ï¼šè¨­å®šé è¡¨å–®è¡Œæ¨£å¼ */
        .form-row {
            display: flex;
            align-items: flex-end;
            gap: 15px;
            margin-bottom: 20px;
        }
        .form-row .form-group {
            margin-bottom: 0;
            flex: 1;
        }
        .items-management-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header"><h1>ğŸ”¥ ç„¡é™å°æ±º ğŸ”¥</h1></div>
        <div class="nav-buttons">
            <button class="btn btn-nav" onclick="showPage('settings')">âš™ï¸è¨­å®š</button>
            <button class="btn btn-nav active" onclick="showPage('voting')">ğŸ—³ï¸æŠ•ç¥¨</button>
            <button class="btn btn-nav" onclick="showPage('stats')">ğŸ“Šçµ±è¨ˆ</button>
        </div>

        <div id="voting" class="page active">
            <div class="card">
                <div class="game-settings-row">
                    <div class="form-group">
                        <label for="gameSelect">é¸æ“‡éŠæˆ²ï¼š</label>
                        <select id="gameSelect" class="form-control" style="width: auto; display: inline-block;" onchange="updateGameSettings()">
                            <option value="">è«‹é¸æ“‡éŠæˆ²</option>
                        </select>
                    </div>
                    <div id="gameSettings" style="display: flex; gap: 20px; align-items: center;">
                        <div class="form-group">
                            <label for="extractMode">æŠ½å–æ¨¡å¼ï¼š</label>
                            <select id="extractMode" class="form-control" style="width: auto; display: inline-block;">
								<option value="maxError">æœ€å¤§èª¤å·®</option>
								<option value="leastVoted">æœ€å°‘ç¥¨æ¬¡</option>
								<option value="weakest">åæ¬¡æœ€ä½</option>
								<option value="lowestWinRate">å‹ç‡æœ€ä½</option>
                                <option value="middle">åæ¬¡ä¸­æ®µ</option>
								<option value="nearAverage">è¿‘å¹³å‡åˆ†</option>
								<option value="middleWinRate">å‹ç‡ä¸­æ®µ</option>
								<option value="strongest">åæ¬¡æœ€é«˜</option>
								<option value="highestWinRate">å‹ç‡æœ€é«˜</option>
								<option value="uniform">å‡å‹»éš¨æ©Ÿ</option>
                                <option value="newest">æœ€è¿‘åŠ å…¥</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <!-- å¿ƒæƒ…ç¯©é¸æŒ‰éˆ•æ”¾åœ¨é—œéµå­—ç¯©é¸ä¸Šæ–¹ -->
                            <div class="voting-mood-filter-container">
                                <div style="display: flex; align-items: center; gap: 10px; justify-content: center;">
                                    <select id="votingMoodLogic" class="mood-logic-select" onchange="updateItemCountMax()">
                                        <option value="and">å’Œ</option>
                                        <option value="or">æˆ–</option>
                                        <option value="not">é</option>
                                    </select>
                                    <div class="voting-mood-filter-buttons" id="votingMoodFilter"></div>
                                </div>
                                <div class="voting-keyword-filter">
                                    <input type="text" id="keywordFilter" class="form-control" style="width: 280px; padding-right: 35px;" placeholder="ä»¥é—œéµå­—ç¯©é¸..." oninput="updateItemCountMax()" onkeydown="handleKeywordFilterKeydown(event)">
                                    <button type="button" class="clear-filter-btn" onclick="clearVotingFilters()">âŒ</button>
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="itemCount">åƒè³½é …ç›®æ•¸ï¼š</label>
                            <input type="number" id="itemCount" min="4" value="0" class="form-control" style="width: 120px; display: inline-block;">
                            <button class="btn btn-danger" onclick="setMaxItems()" style="margin-left: 5px;">å…¨éƒ¨</button>
                        </div>
                        <div class="form-group">
                            <label>&nbsp;</label>
                            <button class="btn btn-primary" onclick="startGame()">é–‹å§‹</button>
                        </div>
                    </div>
                </div>

                <div id="votingArea" class="hidden">
                    <div class="vs-container">
                        <div class="option-card" id="option1Card" onmouseenter="handleVideoHover(1)">
                            <div class="option-title" id="option1Title">é¸é … 1</div>
                            <div class="video-container" id="video1Container"></div>
                            <div class="mood-buttons" id="mood1Buttons"></div>
                            <div class="item-stats hidden" id="stats1"></div>
                            <div class="score-change" id="scoreChange1"></div>
                        </div>
                        <div style="text-align: center;">
                            <button class="btn btn-info" onclick="reloadBothVideos()" style="margin-bottom: 10px;">ğŸ”„</button>
                            <div class="vs-text">VS</div>
                            <button id="toggleStatsButton" class="btn btn-info" onclick="toggleStats()">ğŸ‘ï¸</button>
                        </div>
                        <div class="option-card" id="option2Card" onmouseenter="handleVideoHover(2)">
                            <div class="option-title" id="option2Title">é¸é … 2</div>
                            <div class="video-container" id="video2Container"></div>
                            <div class="mood-buttons" id="mood2Buttons"></div>
                            <div class="item-stats hidden" id="stats2"></div>
                            <div class="score-change" id="scoreChange2"></div>
                        </div>
                    </div>

                    <div class="vote-slider-container">
                        <div id="sliderScoreChangeLeft" class="slider-score-change"></div>
                        <div id="sliderScoreChangeRight" class="slider-score-change"></div>
                        <input type="range" class="vote-slider" id="voteSlider" min="0" max="100" value="50">
                    </div>
                    <div class="flex-center">
                        <button class="btn btn-primary" onclick="voteExtreme(0)">æœ€å·¦</button>
                        <button class="btn btn-gray" onclick="submitTie()">å¹³æ‰‹</button>
                        <button class="btn btn-danger" onclick="voteExtreme(100)">æœ€å³</button>
                    </div>
                    <div class="flex-center">
                        <button class="btn btn-warning" id="undoBtn" onclick="undoVote()" disabled>å¾©åŸ</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="settings" class="page">
            <div class="card">
                <h2>éŠæˆ²ç®¡ç†</h2>
                <div class="form-row">
                    <div class="form-group">
                        <label for="gameName">éŠæˆ²åç¨±</label>
                        <input type="text" id="gameName" class="form-control" placeholder="ä¾‹å¦‚ï¼šæœ€æ„›æ­Œæ›²å°æ±º">
                    </div>
                    <button class="btn btn-primary" onclick="createGame()">å‰µå»ºéŠæˆ²</button>
                </div>

                <div class="flex-center">
                    <button class="btn btn-info" onclick="exportSettings()">åŒ¯å‡ºè¨­å®š</button>
                    <button class="btn btn-warning" onclick="document.getElementById('importFile').click()">åŒ¯å…¥è¨­å®š</button>
                    <input type="file" id="importFile" accept=".json" onchange="importSettings(event)" class="hidden">
                </div>

                <div id="gamesList"><h3>ç¾æœ‰éŠæˆ²</h3></div>

                <div id="itemsManagement" class="hidden" style="margin-top: 30px; padding-top: 30px; border-top: 2px solid #e2e8f0;">
                    <div class="items-management-header">
                        <h2>é …ç›®ç®¡ç†</h2>
                        <button class="btn btn-gray" onclick="toggleItemsManagement()">æ”¶èµ·é …ç›®ç®¡ç†</button>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="itemsInput">æ‰¹æ¬¡æ–°å¢é …ç›®</label>
                            <textarea id="itemsInput" class="form-control" style="min-height: 150px;" placeholder="æ¯è¡Œè¼¸å…¥ä¸€å€‹é …ç›®ï¼Œæ ¼å¼ï¼šé …ç›®åç¨±,å½±ç‰‡é€£çµ"></textarea>
                        </div>
                        <button class="btn btn-primary" onclick="addItems()">æ‰¹æ¬¡æ–°å¢</button>
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; margin: 20px 0;">
                        <h3 id="itemsListTitle">é …ç›®åˆ—è¡¨</h3>
                        <div class="filter-controls">
                            <button class="toggle-btn clear-invalid-btn" onclick="clearAllInvalidLinks()" style="padding: 8px 16px;">æ¸…é™¤æ‰€æœ‰ç„¡æ•ˆé€£çµ</button>
                            <button class="toggle-btn" id="showInvalidOnlyBtn" onclick="toggleInvalidFilter()">ç„¡æ•ˆé€£çµ</button>
                            <div class="mood-filter-container" id="settingsMoodFilter">
								<select id="settingsMoodLogic" class="mood-logic-select">
									<option value="and">å’Œ</option>
									<option value="or">æˆ–</option>
									<option value="not">é</option>
								</select>
								<div class="mood-filter-buttons" id="settingsMoodButtons"></div>
							</div>
                            <div class="voting-keyword-filter">
                                <input type="text" id="itemFilter" placeholder="éæ¿¾é …ç›®..." class="form-control" style="width: 200px; padding-right: 35px;">
                                <button type="button" class="clear-filter-btn" onclick="clearSettingsFilters()">âŒ</button>
                            </div>
                            <select id="pageSize">
                                <option value="10" selected>10</option>
                                <option value="50">50</option>
                                <option value="100">100</option>
                            </select>
                        </div>
                    </div>
                    <div class="pagination" id="paginationTop"></div>
                    <div id="itemsList"></div>
                    <div class="pagination" id="paginationBottom"></div>
                </div>
            </div>
        </div>

        <div id="stats" class="page">
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2>æŠ•ç¥¨çµ±è¨ˆ</h2>
                    <button class="btn btn-primary" onclick="refreshStats()">ğŸ”„ é‡æ–°æ•´ç†</button>
                </div>
                
                <div style="text-align: center; margin-bottom: 20px;">
                    <label for="statsGameSelect">é¸æ“‡éŠæˆ²ï¼š</label>
                    <select id="statsGameSelect" class="form-control" style="width: auto; display: inline-block;">
                        <option value="">è«‹é¸æ“‡éŠæˆ²</option>
                    </select>
                </div>

                <div class="flex-center">
                    <button class="btn btn-info" onclick="exportStats()">åŒ¯å‡ºçµ±è¨ˆ</button>
                    <button class="btn btn-warning" onclick="document.getElementById('importStatsFile').click()">åŒ¯å…¥çµ±è¨ˆ</button>
                    <button class="btn btn-danger" onclick="clearStats()">æ¸…é™¤æ•¸æ“š</button>
                    <input type="file" id="importStatsFile" accept=".json" class="hidden">
                </div>

                <div id="statsContent" class="hidden">
                    <div class="grid">
                        <div class="stat-card">
                            <div class="stat-value" id="totalItems">0</div>
                            <div>ç¸½é …ç›®æ•¸</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="totalVotes">0</div>
                            <div>ç¸½æŠ•ç¥¨æ•¸</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="expectedVotes">0</div>
                            <div>æœŸæœ›ç¥¨æ•¸</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="avgError">0</div>
                            <div>å¹³å‡èª¤å·®</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="avgScore">1500</div>
                            <div>å¹³å‡åˆ†æ•¸</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="medianScore">1500</div>
                            <div>ä¸­ä½åˆ†æ•¸</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="maxScore">1500</div>
                            <div>æœ€é«˜åˆ†æ•¸</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="minScore">1500</div>
                            <div>æœ€ä½åˆ†æ•¸</div>
                        </div>
                    </div>

                    <div style="margin-top: 30px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 id="rankingTitle">æ’è¡Œæ¦œ</h3>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <div class="mood-filter-container" id="statsMoodFilter">
									<select id="statsMoodLogic" class="mood-logic-select">
										<option value="and">å’Œ</option>
										<option value="or">æˆ–</option>
										<option value="not">é</option>
									</select>
									<div class="mood-filter-buttons" id="statsMoodButtons"></div>
								</div>
                                <div class="voting-keyword-filter">
                                    <input type="text" id="rankingSearch" placeholder="æœå°‹é …ç›®..." class="form-control" style="width: 200px; padding-right: 35px;">
                                    <button type="button" class="clear-filter-btn" onclick="clearStatsFilters()">âŒ</button>
                                </div>
                                <select id="sortBy" class="form-control">
                                    <option value="rank">ä¾åæ¬¡</option>
                                    <option value="score">ä¾åˆ†æ•¸</option>
									<option value="error">ä¾èª¤å·®</option>
                                    <option value="winRate">ä¾å‹ç‡</option>
                                    <option value="votes">ä¾ç¥¨æ¬¡</option>
                                    <option value="time">ä¾æ–°åŠ </option>
                                </select>
                            </div>
                        </div>
                        <div id="rankingList"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
	<center>ver 0.1&emsp;~tyovery~&emsp;2025-10<br /><br /></center>

    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
        let games = JSON.parse(localStorage.getItem('games')) || {};
        let currentGame = null, currentPair = null, selectedGameForEdit = null;
        let activeItems = [], voteHistory = [], editingItemId = null, renamingGameId = null;
        let player1 = null, player2 = null, youtubeReady = false, currentPlayingPlayer = null;
        let selectedGameId = localStorage.getItem('selectedGameId') || '';
        let selectedItemCount = parseInt(localStorage.getItem('selectedItemCount')) || 0;
        let selectedExtractMode = localStorage.getItem('selectedExtractMode') || 'uniform';
        let currentPage = 1, itemsPerPage = 10, statsVisible = localStorage.getItem('statsVisible') === 'true', filteredItems = [];
        let currentVideoLinks = [null, null], visibleItemObserver = null;
        let showInvalidOnly = false;
        let cooldownActive = false;
        let uniformPool = []; // ç”¨æ–¼å‡å‹»æŠ½å–çš„æš«å­˜æ± 
        let isLeftMouseDownOnSlider = false; // è¿½è¹¤æ˜¯å¦åœ¨æ»‘æ¡¿ä¸ŠæŒ‰ä¸‹æ»‘é¼ å·¦éµ
        let isEditing = false; // è¿½è¹¤æ˜¯å¦æ­£åœ¨ç·¨è¼¯é …ç›®
        const moodEmojis = ['ğŸŒ', 'ğŸ”¥', 'ğŸ’—', 'ğŸŒ±', 'ğŸ“', 'ğŸ˜­', 'ğŸ•Šï¸']; // å°è±¡å¿ƒæƒ…emoji
        
        // ä¿®æ”¹ï¼šå¾localStorageè®€å–æŠ•ç¥¨é ç¯©é¸ç‹€æ…‹
        let selectedMoodFilters = JSON.parse(localStorage.getItem('selectedMoodFilters')) || []; // æŠ•ç¥¨é çš„å¿ƒæƒ…ç¯©é¸ç‹€æ…‹
        let statsMoodFilters = JSON.parse(localStorage.getItem('statsMoodFilters')) || []; // çµ±è¨ˆé çš„å¿ƒæƒ…ç¯©é¸ç‹€æ…‹
        let settingsMoodFilters = JSON.parse(localStorage.getItem('settingsMoodFilters')) || []; // è¨­å®šé çš„å¿ƒæƒ…ç¯©é¸ç‹€æ…‹
        
        // æ–°å¢ï¼šå¿ƒæƒ…ç¯©é¸é‚è¼¯ç‹€æ…‹
        let votingMoodLogic = localStorage.getItem('votingMoodLogic') || 'and';
        let settingsMoodLogic = localStorage.getItem('settingsMoodLogic') || 'and';
        let statsMoodLogic = localStorage.getItem('statsMoodLogic') || 'and';

        // ä¿å­˜ç·¨è¼¯ç‹€æ…‹çš„è®Šæ•¸
        let editingItemData = {};

        // é˜²æ­¢é‡è¤‡åŸ·è¡ŒstartGameçš„æ¨™èªŒ
        let startGameExecuting = false;

        // é˜²æ­¢åˆ†æ•¸å‹•ç•«é‡è¤‡æ’­æ”¾çš„æ¨™èªŒ
        let scoreAnimationActive = false;

        // è¨ˆç®—èª¤å·®çš„å‡½æ•¸
        function calculateError(item) {
			const D = item.votes - (item.wins || 0) - (item.losses || 0) ;
			const W = (item.wins || 0) + 0.5 * D ;
			const L = (item.losses || 0) + 0.5 * D ;
			if (item.votes === 0 || W == 0 || L == 0 ) return Infinity;
			return 340.48687381214944 / Math.sqrt( W * L / item.votes ) ;
        }

        function migrateOldData() {
            Object.values(games).forEach(game => {
                game.items.forEach(item => {
                    if (typeof item.link === 'string') {
                        item.links = [item.link];
                        delete item.link;
                    } else if (!item.links) item.links = [];
                    if (!item.invalidLinks) item.invalidLinks = [];
                    ['wins', 'losses'].forEach(prop => { if (item[prop] === undefined) item[prop] = 0; });
                    // åˆå§‹åŒ–å¿ƒæƒ…æ¨™è¨˜
                    if (!item.moods) item.moods = [];
                });
            });
            localStorage.setItem('games', JSON.stringify(games));
        }

        function onYouTubeIframeAPIReady() { youtubeReady = true; }

        function handleVideoHover(optionNum) {
            currentPlayingPlayer = optionNum;
            try {
                if (optionNum === 1) {
                    if (player1?.unMute) { player1.unMute(); player1.playVideo(); }
                    if (player2?.mute) { player2.mute(); player2.pauseVideo(); }
                } else {
                    if (player2?.unMute) { player2.unMute(); player2.playVideo(); }
                    if (player1?.mute) { player1.mute(); player1.pauseVideo(); }
                }
            } catch (e) { console.log('Video control not available'); }
        }

        function toggleInvalidLink(optionNum) {
            if (!currentPair) return;
            const item = currentGame.items.find(i => i.id === currentPair[optionNum - 1].id);
            const currentLink = currentVideoLinks[optionNum - 1];
            if (!item || !currentLink) return;
            
            if (!item.invalidLinks) item.invalidLinks = [];
            const btn = document.querySelector(`#video${optionNum}Container .invalid-btn`);
            
            if (item.invalidLinks.includes(currentLink)) {
                item.invalidLinks = item.invalidLinks.filter(link => link !== currentLink);
                btn.classList.remove('active');
            } else {
                item.invalidLinks.push(currentLink);
                btn.classList.add('active');
            }
            localStorage.setItem('games', JSON.stringify(games));
            syncData();
        }

        function toggleStats() {
            statsVisible = !statsVisible;
            localStorage.setItem('statsVisible', statsVisible);
            const btn = document.getElementById('toggleStatsButton');
            const stats1 = document.getElementById('stats1');
            const stats2 = document.getElementById('stats2');
            
            if (statsVisible) {
                btn.textContent = 'ğŸ‘ï¸';
                updateItemStats();
                stats1.classList.remove('hidden');
                stats2.classList.remove('hidden');
            } else {
                btn.textContent = 'ğŸ‘ï¸';
                stats1.classList.add('hidden');
                stats2.classList.add('hidden');
            }
        }

        function sortItemsByRank(items) {
            return [...items].sort((a, b) => {
                if (b.score !== a.score) return b.score - a.score;
                
                // è¨ˆç®—èª¤å·®
                const errorA = calculateError(a);
                const errorB = calculateError(b);
                if (errorA !== errorB) return errorA - errorB; // èª¤å·®å°çš„æ’å…ˆ
                
                const winRateA = a.votes > 0 ? (a.wins || 0) / a.votes : 0;
                const winRateB = b.votes > 0 ? (b.wins || 0) / b.votes : 0;
                if (winRateB !== winRateA) return winRateB - winRateA;
                
                return b.votes - a.votes;
            });
        }

        function updateItemStats() {
			if (!currentPair || !currentGame) return;
			
			// æ¯æ¬¡é‡æ–°è¨ˆç®—æ’åå’Œçµ±è¨ˆè³‡æ–™
			const sortedItems = sortItemsByRank(currentGame.items);
			
			[0, 1].forEach(idx => {
				const item = currentPair[idx];
				const rank = sortedItems.findIndex(i => i.id === item.id) + 1;
				const winRate = item.votes > 0 ? ((item.wins / item.votes) * 100).toFixed(1) : 0;
				const p = item.votes > 0 ? ( item.wins || 0 ) / item.votes : 0 ;
				let error = calculateError(item); // ä½¿ç”¨æ–°çš„è¨ˆç®—èª¤å·®å‡½æ•¸
				error = error === Infinity ? 'âˆ' : Math.round(error) ;
				
				// è¨ˆç®—æœ‰æ•ˆé€£çµæ•¸å’Œç¸½é€£çµæ•¸ï¼ˆå»é‡å¾Œï¼‰
				const allLinks = [...new Set([...(item.links || []), ...(item.invalidLinks || [])])];
				const totalLinkCount = allLinks.length;
				const validLinks = allLinks.filter(link => !item.invalidLinks?.includes(link));
				const validLinkCount = validLinks.length;
				
				// å–å¾—ç•¶å‰è¼‰å…¥çš„å½±ç‰‡URL
				const currentVideoUrl = currentVideoLinks[idx] || '[æ²’æœ‰]' ;
				
				document.getElementById(`stats${idx + 1}`).innerHTML = `
					<div>æ’å: ${rank} | åˆ†æ•¸: ${item.score}Â±${error} | å‹ç‡: ${winRate}% | ç¥¨æ¬¡: ${item.votes} | é€£çµ: ${validLinkCount}/${totalLinkCount}</div>
					<div class="current-video-url">${currentVideoUrl}</div>`;
			});
		}

        function setMaxItems() {
            const gameId = document.getElementById('gameSelect').value;
            if (gameId) {
                const keyword = document.getElementById('keywordFilter').value.toLowerCase().trim();
                let items = games[gameId].items;
                
                if (keyword) {
                    items = items.filter(item => item.name.toLowerCase().includes(keyword));
                }
                
                // æ‡‰ç”¨å¿ƒæƒ…ç¯©é¸
                if (selectedMoodFilters.length > 0) {
                    items = applyMoodFilter(items, selectedMoodFilters, votingMoodLogic);
                }
                
                document.getElementById('itemCount').value = items.length;
            }
        }

        // æ–°å¢ï¼šæ‡‰ç”¨å¿ƒæƒ…ç¯©é¸é‚è¼¯çš„å‡½æ•¸
        function applyMoodFilter(items, moodFilters, logic) {
            if (moodFilters.length === 0) return items;
            
            return items.filter(item => {
                const itemMoods = item.moods || [];
                
                switch(logic) {
                    case 'and':
                        // å¿…é ˆåŒ…å«æ‰€æœ‰é¸ä¸­çš„å¿ƒæƒ…æ¨™è¨˜
                        return moodFilters.every(mood => itemMoods.includes(mood));
                    case 'or':
                        // è‡³å°‘åŒ…å«ä¸€å€‹é¸ä¸­çš„å¿ƒæƒ…æ¨™è¨˜
                        return moodFilters.some(mood => itemMoods.includes(mood));
                    case 'not':
                        // ä¸èƒ½åŒ…å«ä»»ä½•é¸ä¸­çš„å¿ƒæƒ…æ¨™è¨˜
                        return !moodFilters.some(mood => itemMoods.includes(mood));
                    default:
                        return true;
                }
            });
        }

        function reloadVideo(optionNum) {
            if (!currentPair) return;
            const item = currentPair[optionNum - 1];
            if (item?.links?.length > 0) {
                let availableLinks = [...item.links];
                if (item.links.length > 1 && currentVideoLinks[optionNum - 1]) {
                    availableLinks = availableLinks.filter(link => link !== currentVideoLinks[optionNum - 1]);
                }
                const selectedLink = availableLinks[Math.floor(Math.random() * availableLinks.length)];
                currentVideoLinks[optionNum - 1] = selectedLink;
                loadVideo(`video${optionNum}Container`, selectedLink, optionNum);
                // æ›´æ–°çµ±è¨ˆè³‡è¨Šä»¥é¡¯ç¤ºæ–°çš„å½±ç‰‡URL
                if (statsVisible) updateItemStats();
            }
        }

        function reloadBothVideos() {
            // ä¿®æ”¹ï¼šå„ªå…ˆå¾æ²’æœ‰æ¨™è¨˜ç‚ºç„¡æ•ˆçš„é€£çµä¸­éš¨æ©Ÿé¸å‡º
            [1, 2].forEach(optionNum => {
                if (!currentPair) return;
                const item = currentPair[optionNum - 1];
                if (item?.links?.length > 0) {
                    // å„ªå…ˆé¸æ“‡æœ‰æ•ˆé€£çµ
                    let validLinks = item.links.filter(link => !item.invalidLinks?.includes(link));
                    
                    // å¦‚æœæ²’æœ‰æœ‰æ•ˆé€£çµï¼Œå‰‡ä½¿ç”¨æ‰€æœ‰é€£çµ
                    if (validLinks.length === 0) {
                        validLinks = [...item.links];
                    }
                    
                    let availableLinks = [...validLinks];
                    if (validLinks.length > 1 && currentVideoLinks[optionNum - 1]) {
                        availableLinks = availableLinks.filter(link => link !== currentVideoLinks[optionNum - 1]);
                    }
                    const selectedLink = availableLinks[Math.floor(Math.random() * availableLinks.length)];
                    currentVideoLinks[optionNum - 1] = selectedLink;
                    loadVideo(`video${optionNum}Container`, selectedLink, optionNum);
                }
            });
            // æ›´æ–°çµ±è¨ˆè³‡è¨Šä»¥é¡¯ç¤ºæ–°çš„å½±ç‰‡URL
            if (statsVisible) updateItemStats();
        }

        function getRandomValidLink(item) {
            if (!item?.links?.length) return null;
            
            // å„ªå…ˆé¸æ“‡æ²’æœ‰æ¨™è¨˜ç‚ºç„¡æ•ˆçš„é€£çµ
            let validLinks = item.links.filter(link => !item.invalidLinks?.includes(link));
            
            // å¦‚æœæ²’æœ‰æœ‰æ•ˆé€£çµï¼Œå‰‡ä½¿ç”¨æ‰€æœ‰é€£çµ
            if (validLinks.length === 0) {
                validLinks = [...item.links];
            }
            
            return validLinks[Math.floor(Math.random() * validLinks.length)];
        }

        function showPage(pageName) {
            // å¦‚æœæ­£åœ¨ç·¨è¼¯é …ç›®ï¼Œä¿å­˜ç•¶å‰ç·¨è¼¯å…§å®¹
            if (isEditing && editingItemId) {
                saveEditingItemData();
            }
            
            document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
            document.getElementById(pageName).classList.add('active');
            document.querySelectorAll('.btn-nav').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            if (pageName === 'voting') {
                // æ¸…é™¤åˆ†æ•¸å‹•ç•«å…ƒç´ ï¼Œé¿å…åˆ‡æ›é é¢æ™‚é‡æ–°æ’­æ”¾
                clearScoreAnimations();
                updateGameSelect();
                createVotingMoodFilter();
                if (selectedGameId) {
                    document.getElementById('gameSelect').value = selectedGameId;
                    updateGameSettings();
                }
                if (selectedExtractMode) document.getElementById('extractMode').value = selectedExtractMode;
            } else if (pageName === 'stats') {
                updateStatsGameSelect();
                createStatsMoodFilter();
                if (selectedGameId) {
                    document.getElementById('statsGameSelect').value = selectedGameId;
                    loadStats();
                }
            } else if (pageName === 'settings') {
                // ç•¶åˆ‡æ›åˆ°è¨­å®šé æ™‚ï¼Œç«‹å³è¼‰å…¥å¯è¦‹é …ç›®çš„é è¦½
                createSettingsMoodFilter();
                setTimeout(() => {
                    if (selectedGameForEdit) {
                        updateItemsListWithPagination();
                    }
                }, 100);
            }
        }

        // æ¸…é™¤åˆ†æ•¸å‹•ç•«å…ƒç´ 
        function clearScoreAnimations() {
            const leftElement = document.getElementById('sliderScoreChangeLeft');
            const rightElement = document.getElementById('sliderScoreChangeRight');
            
            if (leftElement) {
                leftElement.textContent = '';
                leftElement.className = 'slider-score-change';
            }
            
            if (rightElement) {
                rightElement.textContent = '';
                rightElement.className = 'slider-score-change';
            }
            
            // é‡ç½®å‹•ç•«ç‹€æ…‹æ¨™èªŒ
            scoreAnimationActive = false;
        }

        // ä¿å­˜ç·¨è¼¯ä¸­çš„é …ç›®è³‡æ–™
        function saveEditingItemData() {
            if (!editingItemId) return;
            
            const nameInput = document.getElementById(`edit-name-${editingItemId}`);
            const linksInput = document.getElementById(`edit-links-${editingItemId}`);
            
            if (nameInput && linksInput) {
                editingItemData[editingItemId] = {
                    name: nameInput.value,
                    links: linksInput.value,
                    moods: [...(games[selectedGameForEdit].items.find(i => i.id === editingItemId)?.moods || [])]
                };
            }
        }

        function createGame() {
            const gameName = document.getElementById('gameName').value.trim();
            if (!gameName) { alert('è«‹è¼¸å…¥éŠæˆ²åç¨±'); return; }
            const gameId = Date.now().toString();
            games[gameId] = { id: gameId, name: gameName, items: [], votes: [] };
            localStorage.setItem('games', JSON.stringify(games));
            syncData();
            document.getElementById('gameName').value = '';
            updateGamesList();
            alert('éŠæˆ²å‰µå»ºæˆåŠŸï¼');
        }

        function updateGamesList() {
            const gamesList = document.getElementById('gamesList');
            gamesList.innerHTML = '<h3>ç¾æœ‰éŠæˆ²</h3>';
            Object.values(games).forEach(game => {
                const gameItem = document.createElement('div');
                gameItem.className = 'list-item';
                if (renamingGameId === game.id) {
                    gameItem.classList.add('editing');
                    gameItem.innerHTML = `
                        <div><input type="text" class="form-control" id="rename-input-${game.id}" value="${game.name}">
                        <small>é …ç›®æ•¸: ${game.items.length}</small></div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn btn-primary" onclick="saveGameRename('${game.id}')">å„²å­˜</button>
                            <button class="btn btn-gray" onclick="cancelGameRename()">å–æ¶ˆ</button>
                        </div>`;
                } else {
                    gameItem.innerHTML = `
                        <div><div style="font-weight: bold; font-size: 1.2em;">${game.name}</div>
                        <small>é …ç›®æ•¸: ${game.items.length}</small></div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn btn-warning" onclick="startRenameGame('${game.id}')">æ”¹å</button>
                            <button class="btn btn-info" onclick="editGame('${game.id}')">ç®¡ç†é …ç›®</button>
                            <button class="btn btn-danger" onclick="deleteGame('${game.id}')">åˆªé™¤</button>
                        </div>`;
                }
                gamesList.appendChild(gameItem);
            });
        }

        function startRenameGame(gameId) { renamingGameId = gameId; updateGamesList(); }

        function saveGameRename(gameId) {
            const newName = document.getElementById(`rename-input-${gameId}`).value.trim();
            if (newName) {
                games[gameId].name = newName;
                localStorage.setItem('games', JSON.stringify(games));
                syncData();
                renamingGameId = null;
                updateGamesList();
                updateGameSelect();
                updateStatsGameSelect();
            } else alert('éŠæˆ²åç¨±ä¸èƒ½ç‚ºç©º');
        }

        function cancelGameRename() { renamingGameId = null; updateGamesList(); }

        function toggleInvalidFilter() {
            showInvalidOnly = !showInvalidOnly;
            const btn = document.getElementById('showInvalidOnlyBtn');
            if (showInvalidOnly) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
            filterItems();
        }

        function filterItems() { currentPage = 1; updateItemsListWithPagination(); }

        function editGame(gameId) {
			// å¦‚æœæ­£åœ¨ç·¨è¼¯é …ç›®ï¼Œä¿å­˜ç•¶å‰ç·¨è¼¯å…§å®¹
            if (isEditing && editingItemId) {
                saveEditingItemData();
            }
			
            selectedGameForEdit = gameId;
            document.getElementById('itemsManagement').classList.remove('hidden');
            currentPage = 1;
            updateItemsListWithPagination();
        }

        function setupIntersectionObserver() {
            if (visibleItemObserver) visibleItemObserver.disconnect();
            visibleItemObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const previewId = entry.target.id;
                        const itemId = previewId.replace('preview-', '');
                        const item = games[selectedGameForEdit].items.find(i => i.id === itemId);
                        if (item?.links?.length > 0 && !entry.target.innerHTML) {
                            loadPreviewVideo(previewId, item.links[0]);
                        }
                    }
                });
            }, { rootMargin: '50px' });
        }

        function deleteGame(gameId) {
            if (confirm('ç¢ºå®šè¦åˆªé™¤é€™å€‹éŠæˆ²å—ï¼Ÿ')) {
                delete games[gameId];
                localStorage.setItem('games', JSON.stringify(games));
                syncData();
                updateGamesList();
            }
        }

        function addItems() {
            if (!selectedGameForEdit) { alert('è«‹å…ˆé¸æ“‡è¦ç·¨è¼¯çš„éŠæˆ²'); return; }
            const itemsInput = document.getElementById('itemsInput').value.trim();
            if (!itemsInput) { alert('è«‹è¼¸å…¥é …ç›®è³‡æ–™'); return; }

            const game = games[selectedGameForEdit];
            const lines = itemsInput.split('\n');
            let addedCount = 0;

            lines.forEach(line => {
                line = line.trim();
                if (!line) return;
                const parts = line.split(',');
                if (parts.length) {
                    const itemName = parts[0].trim();
                    // ä¿®æ”¹ï¼šå…è¨±æ²’æœ‰è¼¸å…¥é€£çµï¼Œå¦‚æœæ²’æœ‰é€£çµå‰‡è¨­ç‚ºç©ºé™£åˆ—
                    const itemLink = parts.slice(1).join(',').trim();
                    if (itemName) {
                        game.items.push({
                            id: Date.now().toString() + '_' + Math.random(),
                            name: itemName, 
                            links: itemLink ? [itemLink] : [], // å¦‚æœæœ‰é€£çµæ‰åŠ å…¥
                            invalidLinks: [],
                            score: 1500, votes: 0, wins: 0, losses: 0, addedTime: Date.now(),
                            moods: []
                        });
                        addedCount++;
                    }
                }
            });

            if (addedCount > 0) {
                localStorage.setItem('games', JSON.stringify(games));
                syncData();
                document.getElementById('itemsInput').value = '';
                updateItemsListWithPagination();
                alert(`æˆåŠŸæ–°å¢ ${addedCount} å€‹é …ç›®ï¼`);
				updateGamesList();
            } else alert('æ²’æœ‰æœ‰æ•ˆçš„é …ç›®è¢«æ–°å¢ï¼Œè«‹æª¢æŸ¥æ ¼å¼');
        }

        function updateItemsListWithPagination() {
            if (!selectedGameForEdit) return;
            const game = games[selectedGameForEdit];
            const filterText = document.getElementById('itemFilter').value.toLowerCase();
            
            filteredItems = game.items.filter(item => {
                const matchesText = !filterText || item.name.toLowerCase().includes(filterText);
                const hasInvalidLinks = item.invalidLinks && item.invalidLinks.length > 0;
                const matchesInvalidFilter = !showInvalidOnly || hasInvalidLinks;
                
                // æ‡‰ç”¨å¿ƒæƒ…ç¯©é¸é‚è¼¯
                const matchesMoodFilter = applyMoodFilter([item], settingsMoodFilters, settingsMoodLogic).length > 0;
                
                return matchesText && matchesInvalidFilter && matchesMoodFilter;
            });
            
            // ä¿®æ”¹ï¼šåœ¨è¨­å®šé æŒ‰ç·¨è¼¯é …ç›®æŒ‰éˆ•æ™‚ï¼Œé¡¯ç¤ºçš„é …ç›®ä¾åŠ å…¥æ™‚é–“æ–°è‡³èˆŠæ’åº
            filteredItems.sort((a, b) => (b.addedTime || 0) - (a.addedTime || 0));
            
            const totalItems = filteredItems.length;
            itemsPerPage = parseInt(document.getElementById('pageSize').value); // ç¡®ä¿æ¯æ¬¡éƒ½é‡æ–°è¯»å–pageSizeçš„å€¼
            const totalPages = Math.ceil(totalItems / itemsPerPage);
            if (currentPage > totalPages) currentPage = totalPages;
            if (currentPage < 1) currentPage = 1;
            
            // æ›´æ–°é …ç›®åˆ—è¡¨æ¨™é¡Œæ ¼å¼ç‚ºï¼š"[éŠæˆ²åç¨±] ([ç•¶å‰é¡¯ç¤ºçš„é …ç›®æ•¸]/[è©²éŠæˆ²çš„ç¸½é …ç›®æ•¸])"
            document.getElementById('itemsListTitle').textContent = `${game.name} (${totalItems}/${game.items.length})`;
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, totalItems);
            updateItemsList(filteredItems.slice(startIndex, endIndex));
            updatePagination(totalPages);
            
            // è¨­ç½®è§€å¯Ÿè€…ä¸¦ç«‹å³è¼‰å…¥å¯è¦‹é …ç›®çš„é è¦½
            setupIntersectionObserver();
            document.querySelectorAll('.item-preview').forEach(preview => {
                if (isElementInViewport(preview)) {
                    const itemId = preview.id.replace('preview-', '');
                    const item = game.items.find(i => i.id === itemId);
                    if (item?.links?.length > 0 && !preview.innerHTML) {
                        loadPreviewVideo(preview.id, item.links[0]);
                    }
                } else {
                    visibleItemObserver.observe(preview);
                }
            });
        }
        
        function changePageSize() {
            currentPage = 1; // åˆ‡æ›æ¯é é …ç›®æ•¸æ™‚é‡ç½®åˆ°ç¬¬ä¸€é 
            updateItemsListWithPagination();
        }

        function isElementInViewport(el) {
            if (!el) return false;
            const rect = el.getBoundingClientRect();
            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }

        function updatePagination(totalPages) {
            const html = `
                <button class="btn btn-gray" onclick="changePage(1)" ${currentPage === 1 ? 'disabled' : ''}>é¦–é </button>
                <button class="btn btn-gray" onclick="changePage(${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''}>ä¸Šä¸€é </button>
                <span>ç¬¬ ${currentPage} / ${totalPages} é </span>
                <button class="btn btn-gray" onclick="changePage(${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''}>ä¸‹ä¸€é </button>
                <button class="btn btn-gray" onclick="changePage(${totalPages})" ${currentPage === totalPages ? 'disabled' : ''}>æœ«é </button>`;
            ['paginationTop', 'paginationBottom'].forEach(id => document.getElementById(id).innerHTML = html);
        }

        function changePage(page) { currentPage = page; updateItemsListWithPagination(); }

        function updateItemsList(items) {
            const itemsList = document.getElementById('itemsList');
            itemsList.innerHTML = '';
            items.forEach(item => {
                const itemCard = document.createElement('div');
                itemCard.className = 'list-item';
                if (editingItemId === item.id) {
                    itemCard.classList.add('editing');
                    // ä½¿ç”¨ä¿å­˜çš„ç·¨è¼¯æ•¸æ“šæˆ–ç•¶å‰æ•¸æ“š
                    const savedData = editingItemData[item.id];
                    const nameValue = savedData?.name || item.name;
                    const linksText = savedData?.links || (() => {
                        // åˆä½µæœ‰æ•ˆå’Œç„¡æ•ˆé€£çµï¼Œé¿å…é‡è¤‡é¡¯ç¤º
                        const allLinks = [...(item.links || [])];
                        item.invalidLinks?.forEach(link => {
                            if (!allLinks.includes(link)) {
                                allLinks.push(link);
                            }
                        });
                        return allLinks.map(link => 
                            item.invalidLinks?.includes(link) ? `[ç„¡æ•ˆ] ${link}` : link).join('\n') || '';
                    })();
                    
                    itemCard.innerHTML = `
                        <div class="item-info">
                            <div style="flex: 1;">
                                <!-- å¿ƒæƒ…æŒ‰éˆ•æ”¾åœ¨é …ç›®åç¨±ä¸Šæ–¹ -->
                                <div class="edit-mood-buttons" id="edit-mood-buttons-${item.id}"></div>
                                <input type="text" class="form-control" id="edit-name-${item.id}" value="${nameValue}" style="margin-bottom: 10px;">
                                <textarea class="form-control" id="edit-links-${item.id}" placeholder="æ¯è¡Œä¸€å€‹å½±ç‰‡é€£çµ" style="min-height: 80px;">${linksText}</textarea>
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn btn-primary" onclick="saveItem('${item.id}')">å„²å­˜</button>
                            <button class="btn btn-gray" onclick="cancelEdit()">å–æ¶ˆ</button>
                        </div>`;
                    
                    // åˆå§‹åŒ–ç·¨è¼¯æ™‚çš„å¿ƒæƒ…æŒ‰éˆ•
                    setTimeout(() => {
                        createEditMoodButtons(item.id, savedData?.moods || item.moods || []);
                    }, 0);
                } else {
                    const firstLink = item.links?.[0] || '';
                    // è¨ˆç®—ä¸é‡è¤‡çš„é€£çµç¸½æ•¸
                    const uniqueLinks = [...new Set(item.links || [])];
                    const linkCount = uniqueLinks.length;
                    // è¨ˆç®—ä¸é‡è¤‡çš„ç„¡æ•ˆé€£çµæ•¸
                    const uniqueInvalidLinks = [...new Set(item.invalidLinks || [])];
                    const invalidCount = uniqueInvalidLinks.length;
                    const isFirstLinkInvalid = item.invalidLinks?.includes(firstLink);
                    
                    itemCard.innerHTML = `
                        <div class="item-info">
                            <div class="item-preview" id="preview-${item.id}"></div>
                            <div style="flex: 1;">
                                <!-- åœ¨é …ç›®åç¨±ä¸Šæ–¹æ·»åŠ å¿ƒæƒ…æŒ‰éˆ•ï¼Œä¸éœ€è¦æŒ‰ç·¨è¼¯æŒ‰éˆ•å°±èƒ½ç·¨è¼¯ -->
                                <div class="item-mood-buttons" id="item-mood-buttons-${item.id}"></div>
                                <div style="font-weight: bold;">${item.name}</div>
                                <div class="${isFirstLinkInvalid ? 'invalid-link' : ''}" style="color: var(--primary); font-size: 0.9em;">${firstLink}</div>
                                <!-- ä¿®æ”¹ï¼šå¦‚æœæ²’æœ‰é€£çµï¼Œé¡¯ç¤º"å…± 0 å€‹å½±ç‰‡é€£çµ" -->
                                <div style="color: var(--gray); font-size: 0.85em;">å…± ${linkCount+invalidCount} å€‹å½±ç‰‡é€£çµ</div>
                                ${invalidCount > 0 ? `<div style="color: var(--danger); font-size: 0.85em;">âš ï¸ ${invalidCount} å€‹ç„¡æ•ˆé€£çµ</div>` : ''}
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px;">
							<button class="btn btn-primary" onclick="searchOnWeb('${item.id}','youtube')">YTæœå°‹</button>
							<button class="btn btn-primary" onclick="searchOnWeb('${item.id}','bilibili')">Bç«™æœå°‹</button>
                            <button class="btn btn-info" onclick="startEditItem('${item.id}')">ç·¨è¼¯</button>
                            <button class="btn btn-danger" onclick="confirmRemoveItem('${item.id}')">ç§»é™¤</button>
                        </div>`;
                    
                    // åˆå§‹åŒ–éç·¨è¼¯ç‹€æ…‹ä¸‹çš„å¿ƒæƒ…æŒ‰éˆ•
                    setTimeout(() => {
                        createItemMoodButtons(item.id, item.moods || []);
                    }, 0);
                }
                itemsList.appendChild(itemCard);
            });
        }

        // å‰µå»ºé …ç›®åˆ—è¡¨ä¸­çš„å¿ƒæƒ…æŒ‰éˆ•ï¼ˆéç·¨è¼¯ç‹€æ…‹ï¼‰
        function createItemMoodButtons(itemId, currentMoods) {
            const container = document.getElementById(`item-mood-buttons-${itemId}`);
            if (!container) return;
            
            container.innerHTML = '';
            
            moodEmojis.forEach(emoji => {
                const moodBtn = document.createElement('button');
                moodBtn.className = 'item-mood-btn';
                moodBtn.textContent = emoji;
                moodBtn.dataset.emoji = emoji;
                
                // æª¢æŸ¥æ˜¯å¦å·²ç¶“é¸ä¸­
                if (currentMoods.includes(emoji)) {
                    moodBtn.classList.add('active');
                }
                
                moodBtn.onclick = function() {
                    toggleItemMood(itemId, emoji, moodBtn);
                };
                
                container.appendChild(moodBtn);
            });
        }

        // åˆ‡æ›é …ç›®åˆ—è¡¨ä¸­çš„å¿ƒæƒ…ç‹€æ…‹ï¼ˆéç·¨è¼¯ç‹€æ…‹ï¼‰
        function toggleItemMood(itemId, emoji, button) {
            const item = games[selectedGameForEdit].items.find(i => i.id === itemId);
            if (!item) return;
            
            // åˆå§‹åŒ–å¿ƒæƒ…æ•¸çµ„
            if (!item.moods) item.moods = [];
            
            // åˆ‡æ›å¿ƒæƒ…ç‹€æ…‹
            if (item.moods.includes(emoji)) {
                // å¦‚æœå·²ç¶“å­˜åœ¨ï¼Œç§»é™¤å®ƒ
                item.moods = item.moods.filter(m => m !== emoji);
                button.classList.remove('active');
            } else {
                // å¦‚æœä¸å­˜åœ¨ï¼Œæ·»åŠ å®ƒ
                item.moods.push(emoji);
                button.classList.add('active');
            }
            
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å„²
            localStorage.setItem('games', JSON.stringify(games));
            syncData();
        }

        // å‰µå»ºç·¨è¼¯é …ç›®çš„å¿ƒæƒ…æŒ‰éˆ•
        function createEditMoodButtons(itemId, currentMoods) {
            const container = document.getElementById(`edit-mood-buttons-${itemId}`);
            if (!container) return;
            
            container.innerHTML = '';
            
            moodEmojis.forEach(emoji => {
                const moodBtn = document.createElement('button');
                moodBtn.className = 'edit-mood-btn';
                moodBtn.textContent = emoji;
                moodBtn.dataset.emoji = emoji;
                
                // æª¢æŸ¥æ˜¯å¦å·²ç¶“é¸ä¸­
                if (currentMoods.includes(emoji)) {
                    moodBtn.classList.add('active');
                }
                
                moodBtn.onclick = function() {
                    toggleEditMood(itemId, emoji, moodBtn);
                };
                
                container.appendChild(moodBtn);
            });
        }

        // åˆ‡æ›ç·¨è¼¯é …ç›®çš„å¿ƒæƒ…ç‹€æ…‹
        function toggleEditMood(itemId, emoji, button) {
            const item = games[selectedGameForEdit].items.find(i => i.id === itemId);
            if (!item) return;
            
            // åˆå§‹åŒ–å¿ƒæƒ…æ•¸çµ„
            if (!item.moods) item.moods = [];
            
            // åˆ‡æ›å¿ƒæƒ…ç‹€æ…‹
            if (item.moods.includes(emoji)) {
                // å¦‚æœå·²ç¶“å­˜åœ¨ï¼Œç§»é™¤å®ƒ
                item.moods = item.moods.filter(m => m !== emoji);
                button.classList.remove('active');
            } else {
                // å¦‚æœä¸å­˜åœ¨ï¼Œæ·»åŠ å®ƒ
                item.moods.push(emoji);
                button.classList.add('active');
            }
            
            // æ›´æ–°ä¿å­˜çš„ç·¨è¼¯æ•¸æ“š
            if (editingItemData[itemId]) {
                editingItemData[itemId].moods = [...item.moods];
            }
        }

        function loadPreviewVideo(containerId, link) {
            const container = document.getElementById(containerId);
            if (!container || !link) return;
            if (link.includes('youtube.com') || link.includes('youtu.be')) {
                let videoId = '';
                if (link.includes('youtu.be/')) videoId = link.split('youtu.be/')[1].split(/[?&#]/)[0];
                else if (link.includes('youtube.com/watch')) {
                    const match = link.match(/[?&]v=([^&#]+)/);
                    if (match) videoId = match[1];
                } else if (link.includes('youtube.com/embed/')) videoId = link.split('embed/')[1].split(/[?&#]/)[0];
                else if (link.includes('youtube.com/shorts/')) videoId = link.split('shorts/')[1].split(/[?&#]/)[0];
                if (videoId) container.innerHTML = `<iframe src="https://www.youtube-nocookie.com/embed/${videoId}?controls=1&modestbranding=1&rel=0" frameborder="0" allowfullscreen></iframe>`;
            } else if (link.includes('bilibili.com')) {
                let bvMatch = link.match(/BV[\w]+/);
                if (bvMatch) container.innerHTML = `<iframe src="https://player.bilibili.com/player.html?bvid=${bvMatch[0]}&high_quality=1&autoplay=0" scrolling="no" frameborder="0" allowfullscreen></iframe>`;
                else {
                    const avMatch = link.match(/av(\d+)/);
                    if (avMatch) container.innerHTML = `<iframe src="https://player.bilibili.com/player.html?aid=${avMatch[1]}&high_quality=1&autoplay=0" scrolling="no" frameborder="0" allowfullscreen></iframe>`;
                }
            }
        }
		
		function searchOnWeb(itemId,site) {
			const item = games[selectedGameForEdit].items.find(i => i.id === itemId);
            if (item) {
				let link = '' ;
				switch(site)
				{
					case 'bilibili' :
						link = `https://search.bilibili.com/?keyword=${item.name}` ;
					break ;
					case 'youtube' :
						link = `https://www.youtube.com/results?search_query=${item.name}` ;
					break ;
				}
				window.open(link,'_blank') ;
			}
		}

        function startEditItem(itemId) {
			// å¦‚æœæ­£åœ¨ç·¨è¼¯é …ç›®ï¼Œä¿å­˜ç•¶å‰ç·¨è¼¯å…§å®¹
            if (isEditing && editingItemId) {
                saveEditingItemData();
            }

            editingItemId = itemId; 
            isEditing = true;
            updateItemsListWithPagination(); 
        }

        function saveItem(itemId) {
            const item = games[selectedGameForEdit].items.find(i => i.id === itemId);
            if (item) {
                const newName = document.getElementById(`edit-name-${itemId}`).value.trim();
                const newLinksText = document.getElementById(`edit-links-${itemId}`).value.trim();
                if (newName) {
                    const allLinks = newLinksText.split('\n').map(link => link.trim()).filter(link => link);
                    const validLinks = [];
                    const invalidLinks = [];
                    
                    // è™•ç†é‡è¤‡é€£çµ
                    const linkSet = new Set();
                    
                    allLinks.forEach(link => {
                        if (link.startsWith('[ç„¡æ•ˆ] ')) {
                            const cleanLink = link.substring(5);
                            // å¦‚æœç›¸åŒé€£çµå·²ç¶“å­˜åœ¨æ–¼æœ‰æ•ˆé€£çµä¸­ï¼Œå‰‡å¾æœ‰æ•ˆé€£çµä¸­ç§»é™¤
                            if (linkSet.has(cleanLink)) {
                                // å¦‚æœå·²ç¶“å­˜åœ¨ï¼Œå„ªå…ˆä¿ç•™ç„¡æ•ˆé€£çµ
                                const index = validLinks.indexOf(cleanLink);
                                if (index > -1) {
                                    validLinks.splice(index, 1);
                                }
                            }
                            invalidLinks.push(cleanLink);
                            linkSet.add(cleanLink);
                        } else {
                            // å¦‚æœç›¸åŒé€£çµå·²ç¶“å­˜åœ¨æ–¼ç„¡æ•ˆé€£çµä¸­ï¼Œå‰‡ä¸åŠ å…¥æœ‰æ•ˆé€£çµ
                            if (!linkSet.has(link)) {
                                validLinks.push(link);
                                linkSet.add(link);
                            }
                        }
                    });
                    
                    item.name = newName;
                    // ç¢ºä¿ä¿å­˜çš„é€£çµæ˜¯å»é‡å¾Œçš„
                    item.links = [...new Set(validLinks)];
                    item.invalidLinks = [...new Set(invalidLinks)];
                    // å¿ƒæƒ…æ¨™è¨˜å·²åœ¨ç·¨è¼¯éç¨‹ä¸­ç›´æ¥æ›´æ–°åˆ°item.moods
                    localStorage.setItem('games', JSON.stringify(games));
                    syncData();
                    editingItemId = null;
                    isEditing = false;
                    // æ¸…é™¤ä¿å­˜çš„ç·¨è¼¯æ•¸æ“š
                    delete editingItemData[itemId];
                    updateItemsListWithPagination();
                } else alert('é …ç›®åç¨±ä¸èƒ½ç‚ºç©º');
            }
        }

        function cancelEdit() { 
            // æ¸…é™¤ä¿å­˜çš„ç·¨è¼¯æ•¸æ“šï¼Œä¸ä¿å­˜æ›´æ”¹
            if (editingItemId) {
                delete editingItemData[editingItemId];
            }
            editingItemId = null; 
            isEditing = false;
            updateItemsListWithPagination(); 
        }

        function confirmRemoveItem(itemId) {
			// å¦‚æœæ­£åœ¨ç·¨è¼¯é …ç›®ï¼Œä¿å­˜ç•¶å‰ç·¨è¼¯å…§å®¹
            if (isEditing && editingItemId) {
                saveEditingItemData();
            }
			
            const item = games[selectedGameForEdit].items.find(i => i.id === itemId);
            if (item && confirm(`ç¢ºå®šè¦ç§»é™¤ã€Œ${item.name}ã€å—ï¼Ÿ`)){
				removeItem(itemId);
				updateGamesList();
			}
        }

        function removeItem(itemId) {
            if (selectedGameForEdit) {
                games[selectedGameForEdit].items = games[selectedGameForEdit].items.filter(item => item.id !== itemId);
                localStorage.setItem('games', JSON.stringify(games));
                syncData();
                updateItemsListWithPagination();
            }
        }

        function updateGameSelect() {
            const gameSelect = document.getElementById('gameSelect');
            const currentValue = gameSelect.value;
            gameSelect.innerHTML = '<option value="">è«‹é¸æ“‡éŠæˆ²</option>';
            Object.values(games).forEach(game => {
				const option = document.createElement('option');
				option.value = game.id; option.textContent = game.name;
				gameSelect.appendChild(option);
            });
            if (currentValue) gameSelect.value = currentValue;
        }

        function updateGameSettings() {
            const gameId = document.getElementById('gameSelect').value;
            selectedGameId = gameId; 
            localStorage.setItem('selectedGameId', selectedGameId);
            
            // ä¸å†éš±è—è¨­å®šå€åŸŸï¼Œå³ä½¿æ²’æœ‰é¸æ“‡éŠæˆ²
            document.getElementById('gameSettings').style.display = 'flex';
            
            if (!gameId) {
                // å¦‚æœæ²’æœ‰é¸æ“‡éŠæˆ²ï¼Œç¦ç”¨ç›¸é—œè¨­å®š
                document.getElementById('extractMode').disabled = true;
                document.getElementById('keywordFilter').disabled = true;
                document.getElementById('itemCount').disabled = true;
                document.querySelector('button[onclick="setMaxItems()"]').disabled = true;
                document.querySelector('button[onclick="startGame()"]').disabled = true;
                
                // ç¦ç”¨å¿ƒæƒ…ç¯©é¸æŒ‰éˆ•
                disableVotingMoodFilter();
                return;
            }
            
            // å¦‚æœæœ‰é¸æ“‡éŠæˆ²ï¼Œå•Ÿç”¨ç›¸é—œè¨­å®š
            document.getElementById('extractMode').disabled = false;
            document.getElementById('keywordFilter').disabled = false;
            document.getElementById('itemCount').disabled = false;
            document.querySelector('button[onclick="setMaxItems()"]').disabled = false;
            document.querySelector('button[onclick="startGame()"]').disabled = false;
            
            // å•Ÿç”¨å¿ƒæƒ…ç¯©é¸æŒ‰éˆ•
            enableVotingMoodFilter();
            
            const game = games[gameId];
            document.getElementById('itemCount').max = game.items.length;
            if (selectedItemCount > 0 && selectedItemCount <= game.items.length) {
                document.getElementById('itemCount').value = selectedItemCount;
            } else document.getElementById('itemCount').value = game.items.length;
            if (document.getElementById('votingArea').classList.contains('hidden')) {
                voteHistory = []; document.getElementById('undoBtn').disabled = true;
            }
            
            // ä¿®æ”¹ï¼šå¾localStorageæ¢å¾©ç¯©é¸è¼¸å…¥æ¡†å…§å®¹
            const savedKeywordFilter = localStorage.getItem('keywordFilter');
            if (savedKeywordFilter !== null) {
                document.getElementById('keywordFilter').value = savedKeywordFilter;
            }
            
            // ä¿®æ”¹ï¼šå¾localStorageæ¢å¾©å¿ƒæƒ…ç¯©é¸ç‹€æ…‹
            createVotingMoodFilter();
        }

        function disableVotingMoodFilter() {
            const buttons = document.querySelectorAll('#votingMoodFilter .mood-filter-btn');
            buttons.forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
            });
        }

        function enableVotingMoodFilter() {
            const buttons = document.querySelectorAll('#votingMoodFilter .mood-filter-btn');
            buttons.forEach(btn => {
                btn.disabled = false;
                btn.style.opacity = '1';
            });
        }

        function updateItemCountMax() {
            const gameId = document.getElementById('gameSelect').value;
            if (!gameId) return;
            
            const keyword = document.getElementById('keywordFilter').value.toLowerCase().trim();
            let items = games[gameId].items;
            
            if (keyword) {
                items = items.filter(item => item.name.toLowerCase().includes(keyword));
            }
            
            // æ‡‰ç”¨å¿ƒæƒ…ç¯©é¸
            if (selectedMoodFilters.length > 0) {
                items = applyMoodFilter(items, selectedMoodFilters, votingMoodLogic);
            }
            
            document.getElementById('itemCount').max = items.length;
        }

        function createVotingMoodFilter() {
            const container = document.getElementById('votingMoodFilter');
            container.innerHTML = '';
            
            // è¨­ç½®ä¸‹æ‹‰é¸å–®çš„åˆå§‹å€¼
            const votingMoodLogicSelect = document.getElementById('votingMoodLogic');
            if (votingMoodLogicSelect) {
                votingMoodLogicSelect.value = votingMoodLogic;
            }
            
            // ä¸€è¡Œé¡¯ç¤ºå…¨éƒ¨å¿ƒæƒ…æŒ‰éˆ•
            moodEmojis.forEach(emoji => {
                const moodBtn = document.createElement('button');
                moodBtn.className = 'mood-filter-btn';
                moodBtn.textContent = emoji;
                moodBtn.dataset.emoji = emoji;
                
                // æª¢æŸ¥æ˜¯å¦å·²ç¶“é¸ä¸­
                if (selectedMoodFilters.includes(emoji)) {
                    moodBtn.classList.add('active');
                }
                
                moodBtn.onclick = function() {
                    toggleVotingMoodFilter(emoji, moodBtn);
                };
                
                container.appendChild(moodBtn);
            });
            
            // åˆå§‹ç‹€æ…‹ï¼šå¦‚æœæ²’æœ‰é¸æ“‡éŠæˆ²ï¼Œç¦ç”¨æŒ‰éˆ•
            if (!document.getElementById('gameSelect').value) {
                disableVotingMoodFilter();
            }
        }

        function toggleVotingMoodFilter(emoji, button) {
            if (selectedMoodFilters.includes(emoji)) {
                // å¦‚æœå·²ç¶“å­˜åœ¨ï¼Œç§»é™¤å®ƒ
                selectedMoodFilters = selectedMoodFilters.filter(m => m !== emoji);
                button.classList.remove('active');
            } else {
                // å¦‚æœä¸å­˜åœ¨ï¼Œæ·»åŠ å®ƒ
                selectedMoodFilters.push(emoji);
                button.classList.add('active');
            }
            
            // ä¿®æ”¹ï¼šä¿å­˜å¿ƒæƒ…ç¯©é¸ç‹€æ…‹åˆ°localStorage
            localStorage.setItem('selectedMoodFilters', JSON.stringify(selectedMoodFilters));
            
            // æ›´æ–°é …ç›®è¨ˆæ•¸æœ€å¤§å€¼
            updateItemCountMax();
        }

        // æ–°å¢ï¼šæ¸…é™¤æŠ•ç¥¨é ç¯©é¸åŠŸèƒ½
        function clearVotingFilters() {
            // æ¸…é™¤è¼¸å…¥æ¡†å…§å®¹
            document.getElementById('keywordFilter').value = '';
            localStorage.setItem('keywordFilter', '');
            
            // æ¸…é™¤å¿ƒæƒ…ç¯©é¸
            selectedMoodFilters = [];
            localStorage.setItem('selectedMoodFilters', JSON.stringify(selectedMoodFilters));
            
            // é‡æ–°å‰µå»ºå¿ƒæƒ…æŒ‰éˆ•ï¼ˆå…¨éƒ¨è®Šç‚ºæœªé¸ä¸­ç‹€æ…‹ï¼‰
            createVotingMoodFilter();
            
            // æ›´æ–°é …ç›®è¨ˆæ•¸æœ€å¤§å€¼
            updateItemCountMax();
        }

        // æ–°å¢ï¼šæ¸…é™¤è¨­å®šé ç¯©é¸åŠŸèƒ½
        function clearSettingsFilters() {
            // æ¸…é™¤è¼¸å…¥æ¡†å…§å®¹
            document.getElementById('itemFilter').value = '';
            
            // æ¸…é™¤å¿ƒæƒ…ç¯©é¸
            settingsMoodFilters = [];
            localStorage.setItem('settingsMoodFilters', JSON.stringify(settingsMoodFilters));
            
            // é‡æ–°å‰µå»ºå¿ƒæƒ…æŒ‰éˆ•ï¼ˆå…¨éƒ¨è®Šç‚ºæœªé¸ä¸­ç‹€æ…‹ï¼‰
            createSettingsMoodFilter();
            
            // æ›´æ–°é …ç›®åˆ—è¡¨
            filterItems();
        }

        // æ–°å¢ï¼šæ¸…é™¤çµ±è¨ˆé ç¯©é¸åŠŸèƒ½
        function clearStatsFilters() {
            // æ¸…é™¤è¼¸å…¥æ¡†å…§å®¹
            document.getElementById('rankingSearch').value = '';
            
            // æ¸…é™¤å¿ƒæƒ…ç¯©é¸
            statsMoodFilters = [];
            localStorage.setItem('statsMoodFilters', JSON.stringify(statsMoodFilters));
            
            // é‡æ–°å‰µå»ºå¿ƒæƒ…æŒ‰éˆ•ï¼ˆå…¨éƒ¨è®Šç‚ºæœªé¸ä¸­ç‹€æ…‹ï¼‰
            createStatsMoodFilter();
            
            // é‡æ–°è¼‰å…¥çµ±è¨ˆè³‡æ–™
            loadStats();
        }

        function createSettingsMoodFilter() {
			const container = document.getElementById('settingsMoodButtons');
			container.innerHTML = '';
			
			// è®¾ç½®ä¸‹æ‹‰é€‰å•çš„åˆå§‹å€¼
			const settingsMoodLogicSelect = document.getElementById('settingsMoodLogic');
			if (settingsMoodLogicSelect) {
				settingsMoodLogicSelect.value = settingsMoodLogic;
			}
			
			moodEmojis.forEach(emoji => {
				const moodBtn = document.createElement('button');
				moodBtn.className = 'mood-filter-btn';
				moodBtn.textContent = emoji;
				moodBtn.dataset.emoji = emoji;
				
				// æ£€æŸ¥æ˜¯å¦å·²ç»é€‰ä¸­
				if (settingsMoodFilters.includes(emoji)) {
					moodBtn.classList.add('active');
				}
				
				moodBtn.onclick = function() {
					toggleSettingsMoodFilter(emoji, moodBtn);
				};
				
				container.appendChild(moodBtn);
			});
		}

        function toggleSettingsMoodFilter(emoji, button) {
            if (settingsMoodFilters.includes(emoji)) {
                // å¦‚æœå·²ç¶“å­˜åœ¨ï¼Œç§»é™¤å®ƒ
                settingsMoodFilters = settingsMoodFilters.filter(m => m !== emoji);
                button.classList.remove('active');
            } else {
                // å¦‚æœä¸å­˜åœ¨ï¼Œæ·»åŠ å®ƒ
                settingsMoodFilters.push(emoji);
                button.classList.add('active');
            }
            
            // ä¿å­˜åˆ°localStorage
            localStorage.setItem('settingsMoodFilters', JSON.stringify(settingsMoodFilters));
            
            // æ›´æ–°é …ç›®åˆ—è¡¨
            filterItems();
        }

        // ä¿®æ”¹ï¼šè™•ç†æŠ•ç¥¨é ç¯©é¸è¼¸å…¥æ¡†çš„Enteréµäº‹ä»¶
        function handleKeywordFilterKeydown(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
                
                // ä½¿ç”¨ setTimeout ç¢ºä¿äº‹ä»¶è™•ç†å®Œå…¨å®Œæˆ
                setTimeout(() => {
                    startGame();
                }, 0);
                
                return false;
            }
        }

        function startGame() {
            // é˜²æ­¢é‡è¤‡åŸ·è¡Œ
            if (startGameExecuting) {
                return;
            }
            
            try {
                startGameExecuting = true;
                
                const gameId = document.getElementById('gameSelect').value;
                if (!gameId) return;
                currentGame = games[gameId];
                selectedExtractMode = document.getElementById('extractMode').value;
                localStorage.setItem('selectedExtractMode', selectedExtractMode);
                const itemCount = parseInt(document.getElementById('itemCount').value);
                selectedItemCount = itemCount; localStorage.setItem('selectedItemCount', selectedItemCount);
                if (itemCount < 4) { alert('åƒè³½é …ç›®æ•¸å¿…é ˆè‡³å°‘ç‚º4'); return; }

                // é—œéµå­—ç¯©é¸
                const keyword = document.getElementById('keywordFilter').value.toLowerCase().trim();
                let selectedItems = [...currentGame.items];
                
                // ä¿®æ”¹ï¼šä¿å­˜ç¯©é¸è¼¸å…¥æ¡†å…§å®¹åˆ°localStorage
                localStorage.setItem('keywordFilter', keyword);
                
                if (keyword) {
                    selectedItems = selectedItems.filter(item => item.name.toLowerCase().includes(keyword));
                }
                
                // æ‡‰ç”¨å¿ƒæƒ…ç¯©é¸
                if (selectedMoodFilters.length > 0) {
                    selectedItems = applyMoodFilter(selectedItems, selectedMoodFilters, votingMoodLogic);
                }
                
                if (selectedItems.length < 4) { 
                    alert('ç¯©é¸å¾Œçš„é …ç›®æ•¸ä¸è¶³4å€‹ï¼Œè«‹èª¿æ•´ç¯©é¸æ¢ä»¶'); 
                    return; 
                }
                
                uniformPool = []; // é‡ç½®å‡å‹»æŠ½å–æš«å­˜æ± 
                
                switch (selectedExtractMode) {
                    case 'leastVoted': selectedItems.sort((a, b) => a.votes - b.votes); break; // æœ€å°‘ç¥¨æ¬¡
                    case 'newest': selectedItems.sort((a, b) => b.addedTime - a.addedTime); break; // æœ€è¿‘åŠ å…¥
                    case 'uniform': // å‡å‹»æŠ½å–
                        // å¾æ‰€æœ‰é …ç›®ä¸­éš¨æ©Ÿé¸å–è¨­å®šçš„é …ç›®æ•¸
                        const shuffled = [...selectedItems].sort(() => 0.5 - Math.random());
                        uniformPool = shuffled.slice(0, itemCount);
                        break;
                    case 'strongest': 
                        selectedItems = sortItemsByRank(selectedItems);
                        break; // æ’åæœ€å¼·
                    case 'weakest': 
                        selectedItems = sortItemsByRank(selectedItems).reverse();
                        break; //æ’åæœ€å¼±
                    case 'middle': // æ’åä¸­æ®µ
                        selectedItems = sortItemsByRank(selectedItems);
                        const totalItems = selectedItems.length;
                        // ä¿®æ­£æ’åä¸­æ®µè¨ˆç®—ï¼šç¢ºä¿æŠ½å–ä¸­é–“çš„é …ç›®
                        const startIndex = Math.floor((totalItems - itemCount) / 2);
                        const endIndex = startIndex + itemCount;
                        selectedItems = selectedItems.slice(startIndex, endIndex);
                        break;
                    case 'highestWinRate': // å‹ç‡æœ€é«˜
                        selectedItems.sort((a, b) => {
                            const winRateA = a.votes > 0 ? (a.wins || 0) / a.votes : 0;
                            const winRateB = b.votes > 0 ? (b.wins || 0) / b.votes : 0;
                            return winRateB - winRateA;
                        });
                        break;
                    case 'lowestWinRate': // å‹ç‡æœ€ä½
                        selectedItems.sort((a, b) => {
                            const winRateA = a.votes > 0 ? (a.wins || 0) / a.votes : 0;
                            const winRateB = b.votes > 0 ? (b.wins || 0) / b.votes : 0;
                            return winRateA - winRateB;
                        });
                        break;
                    case 'middleWinRate': // å‹ç‡ä¸­æ®µï¼ˆæœ€æ¥è¿‘50%çš„é …ç›®ï¼‰
                        selectedItems.sort((a, b) => {
                            const winRateA = a.votes > 0 ? (a.wins || 0) / a.votes : 0;
                            const winRateB = b.votes > 0 ? (b.wins || 0) / b.votes : 0;
                            const diffA = Math.abs(winRateA - 0.5);
                            const diffB = Math.abs(winRateB - 0.5);
                            return diffA - diffB;
                        });
                        // åªå–å‰itemCountå€‹æœ€æ¥è¿‘50%å‹ç‡çš„é …ç›®
                        selectedItems = selectedItems.slice(0, itemCount);
                        break;
                    case 'nearAverage': // è¿‘å¹³å‡åˆ†ï¼ˆæœ€æ¥è¿‘çœŸå¯¦å¹³å‡åˆ†çš„é …ç›®ï¼‰
                        // ä¿®æ”¹ï¼šè¨ˆç®—çœŸå¯¦å¹³å‡åˆ†
                        let totalScore = 0;
                        selectedItems.forEach(item => totalScore += item.score);
                        const avgScore = selectedItems.length > 0 ? totalScore / selectedItems.length : 1500;
                        
                        selectedItems.sort((a, b) => {
                            const diffA = Math.abs(a.score - avgScore);
                            const diffB = Math.abs(b.score - avgScore);
                            return diffA - diffB;
                        });
                        // åªå–å‰itemCountå€‹æœ€æ¥è¿‘çœŸå¯¦å¹³å‡åˆ†çš„é …ç›®
                        selectedItems = selectedItems.slice(0, itemCount);
                        break;
                    case 'maxError': // æœ€å¤§èª¤å·®
                        selectedItems.sort((a, b) => {
                            const errorA = calculateError(a);
                            const errorB = calculateError(b);
                            // èª¤å·®ç‚ºç„¡é™å¤§çš„æ’åœ¨æœ€å‰é¢
                            if (errorA === Infinity && errorB !== Infinity) return -1;
                            if (errorA !== Infinity && errorB === Infinity) return 1;
                            return errorB - errorA; // èª¤å·®å¤§çš„æ’å…ˆ
                        });
                        // åªå–å‰itemCountå€‹èª¤å·®æœ€å¤§çš„é …ç›®
                        selectedItems = selectedItems.slice(0, itemCount);
                        break;
                }

                activeItems = selectedExtractMode === 'uniform' ? uniformPool : 
                             selectedExtractMode === 'middle' || selectedExtractMode === 'middleWinRate' || selectedExtractMode === 'nearAverage' || selectedExtractMode === 'maxError' ? selectedItems : 
                             selectedItems.slice(0, itemCount);
                             
                if (activeItems.length < 2) { alert('é¸æ“‡çš„é …ç›®æ•¸ä¸è¶³'); return; }

                document.getElementById('votingArea').classList.remove('hidden');
                document.getElementById('voteSlider').value = 50;
                const slider = document.getElementById('voteSlider');
                
                // é‡æ–°è¨­ç½®æ»‘é¼ äº‹ä»¶ç›£è½å™¨
                slider.onmousedown = function(e) {
                    // åªæœ‰å·¦éµæŒ‰ä¸‹æ™‚æ‰è¨­ç½®æ¨™è¨˜
                    if (e.button === 0) {
                        isLeftMouseDownOnSlider = true;
                    }
                };
                
                slider.onmouseup = function(e) {
                    // åªæœ‰å·¦éµæ”¾é–‹ä¸”ä¹‹å‰æ˜¯å·¦éµæŒ‰ä¸‹çš„ç‹€æ…‹æ‰è§¸ç™¼æŠ•ç¥¨
                    if (e.button === 0 && isLeftMouseDownOnSlider) {
                        submitVote();
                    }
                    isLeftMouseDownOnSlider = false;
                };
                
                slider.ontouchend = submitVote;
                // é˜²æ­¢å³éµè§¸ç™¼æŠ•ç¥¨
                slider.oncontextmenu = function(e) { e.preventDefault(); return false; };
                
                voteHistory = []; document.getElementById('undoBtn').disabled = true;
                currentPair = null;
                
                // ä¿æŒstatsVisibleç‹€æ…‹ä¸è®Š
                if (statsVisible) {
                    document.getElementById('toggleStatsButton').textContent = 'ğŸ‘ï¸';
                    updateItemStats();
                    document.getElementById('stats1').classList.remove('hidden');
                    document.getElementById('stats2').classList.remove('hidden');
                } else {
                    document.getElementById('toggleStatsButton').textContent = 'ğŸ‘ï¸';
                    document.getElementById('stats1').classList.add('hidden');
                    document.getElementById('stats2').classList.add('hidden');
                }
                
                loadNewPair();
            } finally {
                // ç¢ºä¿æ¨™èªŒè¢«é‡ç½®
                startGameExecuting = false;
            }
        }

        function loadNewPair(replacePosition = null) {
            if (!activeItems || activeItems.length < 2) return;
            if (replacePosition === null || !currentPair) {
                const idx1 = Math.floor(Math.random() * activeItems.length);
                let idx2 = Math.floor(Math.random() * activeItems.length);
                while (idx2 === idx1) idx2 = Math.floor(Math.random() * activeItems.length);
                currentPair = [activeItems[idx1], activeItems[idx2]];
                loadBothVideos();
                createMoodButtons();
            } else {
                const positions = replacePosition === 'both' ? [0, 1] : [replacePosition];
                positions.forEach(pos => {
                    let newItemIndex;
                    do { newItemIndex = Math.floor(Math.random() * activeItems.length); }
                    while (activeItems[newItemIndex].id === currentPair[0].id || activeItems[newItemIndex].id === currentPair[1].id);
                    currentPair[pos] = activeItems[newItemIndex];
                    document.getElementById(`option${pos + 1}Title`).textContent = currentPair[pos].name;
                    const link = getRandomValidLink(currentPair[pos]);
                    currentVideoLinks[pos] = link;
                    loadVideo(`video${pos + 1}Container`, link, pos + 1);
                });
                if (replacePosition === 'both') loadBothVideos();
                createMoodButtons();
            }
            // æ¯æ¬¡è¼‰å…¥æ–°å°æˆ°çµ„åˆæ™‚æ›´æ–°çµ±è¨ˆè³‡æ–™
            updateItemStats();
        }

        function createMoodButtons() {
            // ç‚ºå…©å€‹é¸é …å‰µå»ºå¿ƒæƒ…æŒ‰éˆ•
            [1, 2].forEach(optionNum => {
                const moodButtonsContainer = document.getElementById(`mood${optionNum}Buttons`);
                moodButtonsContainer.innerHTML = '';
                
                moodEmojis.forEach((emoji, index) => {
                    const moodBtn = document.createElement('button');
                    moodBtn.className = 'mood-btn';
                    moodBtn.textContent = emoji;
                    moodBtn.dataset.emoji = emoji;
                    
                    // æª¢æŸ¥ç•¶å‰é …ç›®æ˜¯å¦å·²ç¶“æœ‰é€™å€‹å¿ƒæƒ…æ¨™è¨˜
                    const item = currentPair[optionNum - 1];
                    if (item.moods && item.moods.includes(emoji)) {
                        moodBtn.classList.add('active');
                    }
                    
                    moodBtn.onclick = function() {
                        toggleMood(optionNum, emoji, moodBtn);
                    };
                    
                    moodButtonsContainer.appendChild(moodBtn);
                });
            });
        }

        function toggleMood(optionNum, emoji, button) {
            const item = currentGame.items.find(i => i.id === currentPair[optionNum - 1].id);
            if (!item) return;
            
            // åˆå§‹åŒ–å¿ƒæƒ…æ•¸çµ„
            if (!item.moods) item.moods = [];
            
            // åˆ‡æ›å¿ƒæƒ…ç‹€æ…‹
            if (item.moods.includes(emoji)) {
                // å¦‚æœå·²ç¶“å­˜åœ¨ï¼Œç§»é™¤å®ƒ
                item.moods = item.moods.filter(m => m !== emoji);
                button.classList.remove('active');
            } else {
                // å¦‚æœä¸å­˜åœ¨ï¼Œæ·»åŠ å®ƒ
                item.moods.push(emoji);
                button.classList.add('active');
            }
            
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å„²
            localStorage.setItem('games', JSON.stringify(games));
            syncData();
        }

        function createStatsMoodFilter() {
			const container = document.getElementById('statsMoodButtons');
			container.innerHTML = '';
			
			// è®¾ç½®ä¸‹æ‹‰é€‰å•çš„åˆå§‹å€¼
			const statsMoodLogicSelect = document.getElementById('statsMoodLogic');
			if (statsMoodLogicSelect) {
				statsMoodLogicSelect.value = statsMoodLogic;
			}
			
			moodEmojis.forEach(emoji => {
				const moodBtn = document.createElement('button');
				moodBtn.className = 'mood-filter-btn';
				moodBtn.textContent = emoji;
				moodBtn.dataset.emoji = emoji;
				
				// æ£€æŸ¥æ˜¯å¦å·²ç»é€‰ä¸­
				if (statsMoodFilters.includes(emoji)) {
					moodBtn.classList.add('active');
				}
				
				moodBtn.onclick = function() {
					toggleStatsMoodFilter(emoji, moodBtn);
				};
				
				container.appendChild(moodBtn);
			});
		}

        function toggleStatsMoodFilter(emoji, button) {
            if (statsMoodFilters.includes(emoji)) {
                // å¦‚æœå·²ç¶“å­˜åœ¨ï¼Œç§»é™¤å®ƒ
                statsMoodFilters = statsMoodFilters.filter(m => m !== emoji);
                button.classList.remove('active');
            } else {
                // å¦‚æœä¸å­˜åœ¨ï¼Œæ·»åŠ å®ƒ
                statsMoodFilters.push(emoji);
                button.classList.add('active');
            }
            
            // ä¿å­˜åˆ°localStorage
            localStorage.setItem('statsMoodFilters', JSON.stringify(statsMoodFilters));
            
            // é‡æ–°è¼‰å…¥çµ±è¨ˆè³‡æ–™
            loadStats();
        }

        function loadBothVideos() {
            ['option1Title', 'option2Title'].forEach((id, idx) => 
                document.getElementById(id).textContent = currentPair[idx].name);
            [0, 1].forEach(idx => {
                const link = getRandomValidLink(currentPair[idx]);
                currentVideoLinks[idx] = link;
                loadVideo(`video${idx + 1}Container`, link, idx + 1);
            });
        }

        function loadVideo(containerId, link, playerNum) {
            const container = document.getElementById(containerId);
            const item = currentGame.items.find(i => i.id === currentPair[playerNum - 1].id);
            const isInvalid = item?.invalidLinks?.includes(link);
            
            if (!link) {
                container.innerHTML = '<div style="color: var(--danger); background: #fff; padding: 20px; text-align: center; border-radius: 10px;">ç„¡å½±ç‰‡é€£çµ</div>';
                return;
            }

            if (playerNum === 1 && player1) { try { player1.destroy(); } catch(e) {} player1 = null; }
            else if (playerNum === 2 && player2) { try { player2.destroy(); } catch(e) {} player2 = null; }

            const buttons = `
                <button class="invalid-btn ${isInvalid ? 'active' : ''}" onclick="toggleInvalidLink(${playerNum})">âš ï¸</button>
                <button class="reload-btn" onclick="reloadVideo(${playerNum})">
                    <svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
                </button>`;

            if (link.includes('youtube.com') || link.includes('youtu.be')) {
                let videoId = '';
                if (link.includes('youtu.be/')) videoId = link.split('youtu.be/')[1].split(/[?&#]/)[0];
                else if (link.includes('youtube.com/watch')) {
                    const match = link.match(/[?&]v=([^&#]+)/);
                    if (match) videoId = match[1];
                } else if (link.includes('youtube.com/embed/')) videoId = link.split('embed/')[1].split(/[?&#]/)[0];
                else if (link.includes('youtube.com/shorts/')) videoId = link.split('shorts/')[1].split(/[?&#]/)[0];
                
                if (videoId) {
                    const playerId = `youtube-player-${playerNum}`;
                    container.innerHTML = `${buttons}<div id="${playerId}"></div>`;
                    if (youtubeReady) {
                        const player = new YT.Player(playerId, {
                            height: '100%', width: '100%', videoId: videoId,
                            playerVars: { autoplay: 0, controls: 1, rel: 0, modestbranding: 1, playsinline: 1 },
                            events: { onReady: event => event.target.mute() }
                        });
                        if (playerNum === 1) player1 = player;
                        else player2 = player;
                    } else {
                        container.innerHTML = `${buttons}<iframe src="https://www.youtube-nocookie.com/embed/${videoId}?enablejsapi=1&rel=0&modestbranding=1&playsinline=1&mute=1" frameborder="0" allowfullscreen></iframe>`;
                    }
                }
            } else if (link.includes('bilibili.com')) {
                let bvMatch = link.match(/BV[\w]+/);
                if (bvMatch) container.innerHTML = `${buttons}<iframe src="https://player.bilibili.com/player.html?bvid=${bvMatch[0]}&high_quality=1&autoplay=0" scrolling="no" frameborder="0" allowfullscreen></iframe>`;
                else {
                    const avMatch = link.match(/av(\d+)/);
                    if (avMatch) container.innerHTML = `${buttons}<iframe src="https://player.bilibili.com/player.html?aid=${avMatch[1]}&high_quality=1&autoplay=0" scrolling="no" frameborder="0" allowfullscreen></iframe>`;
                }
            }
            
            // æ›´æ–°çµ±è¨ˆè³‡è¨Šä»¥é¡¯ç¤ºæ–°çš„å½±ç‰‡URL
            if (statsVisible) updateItemStats();
        }

        function voteExtreme(value) { 
            if (cooldownActive) return;
            document.getElementById('voteSlider').value = value; 
            submitVote(); 
        }
        
        function submitVote() { 
            if (cooldownActive) return;
            if (currentGame && currentPair) processVote(parseInt(document.getElementById('voteSlider').value)); 
        }
        
        function submitTie() { 
            if (cooldownActive) return;
            if (currentGame && currentPair) processVote(50); 
        }

        function startCooldown() {
            cooldownActive = true;
            
            // ç¦ç”¨æ‰€æœ‰æŠ•ç¥¨ç›¸é—œæ§åˆ¶é …ï¼ŒåŒ…æ‹¬å¾©åŸæŒ‰éˆ•
            document.getElementById('voteSlider').disabled = true;
            document.querySelectorAll('.flex-center .btn').forEach(btn => {
                btn.disabled = true;
            });
            
            // 2ç§’å¾ŒçµæŸå†·å»
            setTimeout(() => {
                cooldownActive = false;
                document.getElementById('voteSlider').disabled = false;
                document.querySelectorAll('.flex-center .btn').forEach(btn => {
                    // å¾©åŸæŒ‰éˆ•æ ¹æ“švoteHistoryç‹€æ…‹æ±ºå®šæ˜¯å¦å•Ÿç”¨
                    if (btn.id === 'undoBtn') {
                        btn.disabled = (voteHistory.length === 0);
                    } else {
                        btn.disabled = false;
                    }
                });
            }, 2000);
        }

        function processVote(sliderValue) {
            // é–‹å§‹å†·å»
            startCooldown();
            
            // ä¿å­˜ç•¶å‰å¿ƒæƒ…ç‹€æ…‹åˆ°æŠ•ç¥¨æ­·å²ä¸­
            const oldMoods = {
                item1: [...(currentPair[0].moods || [])],
                item2: [...(currentPair[1].moods || [])]
            };
            
            voteHistory.push({
                pair: [...currentPair], value: sliderValue,
                oldScores: { item1: currentPair[0].score, item2: currentPair[1].score },
                oldWins: { item1: currentPair[0].wins || 0, item2: currentPair[1].wins || 0 },
                oldLosses: { item1: currentPair[0].losses || 0, item2: currentPair[1].losses || 0 },
                oldMoods: oldMoods // ä¿å­˜å¿ƒæƒ…ç‹€æ…‹
            });

            // è¨ˆç®—å…©å€‹é …ç›®çš„èª¤å·®
            let error1 = calculateError(currentPair[0]);
            let error2 = calculateError(currentPair[1]);
            
            // å¦‚æœèª¤å·®æ˜¯Infinityï¼Œå‰‡ç”¨700ä»£æ›¿
            if (error1 === Infinity) error1 = 700 ;
            if (error2 === Infinity) error2 = 700 ;
            
            // è¨ˆç®—å¹³å‡èª¤å·®
            // const avgError = (error1 + error2) / 2;
            
            // å°‡å¹³å‡èª¤å·®æ˜ å°„åˆ°16-80çš„ç¯„åœï¼Œæœ€å¤§èª¤å·®è¨­ç‚º500
            let k1 = 16 + (error1 / 700) * (80 - 16);
			let k2 = 16 + (error2 / 700) * (80 - 16);
            
            // ç¢ºä¿kå€¼åœ¨16åˆ°80ä¹‹é–“
            k1 = Math.max(16, Math.min(80, k1));
			k2 = Math.max(16, Math.min(80, k2));

            const scoreA = currentPair[0].score, scoreB = currentPair[1].score;
            const winRateA = 1 - (sliderValue / 100), winRateB = sliderValue / 100;
            const expectedA = 1 / (1 + Math.pow(10, (scoreB - scoreA) / 400));
            const expectedB = 1 / (1 + Math.pow(10, (scoreA - scoreB) / 400));
            
            const item1 = currentGame.items.find(item => item.id === currentPair[0].id);
            const item2 = currentGame.items.find(item => item.id === currentPair[1].id);
            
            if (item1 && item2) {
                const newScore1 = Math.round(item1.score + k1 * (winRateA - expectedA));
                const newScore2 = Math.round(item2.score + k2 * (winRateB - expectedB));
                
                // ä¿®æ”¹ï¼šåˆ†æ•¸æ”¹è®Šå‹•ç•«æ”¹åˆ°æŠ•ç¥¨æ»‘å‹•æ¢çš„å·¦å³æ–¹ç©ºç™½ä½ç½®
                const leftElement = document.getElementById('sliderScoreChangeLeft');
                const rightElement = document.getElementById('sliderScoreChangeRight');
                
                const change1 = newScore1 - item1.score;
                const change2 = newScore2 - item2.score;
				
				console.log(`k1 = ${k1} , change = ${change1}`) ;
				console.log(`k2 = ${k2} , change = ${change2}`) ;
                
                // è¨­ç½®å‹•ç•«ç‹€æ…‹æ¨™èªŒ
                scoreAnimationActive = true;
                
                // å·¦é‚Šå‹•ç•«ï¼ˆé¸é …1ï¼‰
                leftElement.textContent = change1 > 0 ? `+${change1}` : `${change1}` ;
                leftElement.className = `slider-score-change left ${change1 > 0 ? 'positive' : change1 < 0 ? 'negative' : 'zero' }`;
                leftElement.style.animation = 'none'; 
                leftElement.offsetHeight; 
                leftElement.style.animation = null;
                
                // å³é‚Šå‹•ç•«ï¼ˆé¸é …2ï¼‰
                rightElement.textContent = change2 > 0 ? `+${change2}` : `${change2}` ;
                rightElement.className = `slider-score-change right ${change2 > 0 ? 'positive' : change2 < 0 ? 'negative' : 'zero' }`;
                rightElement.style.animation = 'none'; 
                rightElement.offsetHeight; 
                rightElement.style.animation = null;
                
                item1.score = newScore1; item2.score = newScore2;
                item1.votes++; item2.votes++;
                ['wins', 'losses'].forEach(prop => { if (!item1[prop]) item1[prop] = 0; if (!item2[prop]) item2[prop] = 0; });
                
                if (sliderValue < 50) { item1.wins++; item2.losses++; }
                else if (sliderValue > 50) { item2.wins++; item1.losses++; }
                
                currentGame.votes.push({ timestamp: Date.now(), item1: currentPair[0].id, item2: currentPair[1].id, value: sliderValue });
                localStorage.setItem('games', JSON.stringify(games));
                syncData();
                
                const replacePosition = sliderValue === 50 ? 'both' : sliderValue < 50 ? 1 : 0;
                setTimeout(() => {
                    loadNewPair(replacePosition);
                    document.getElementById('voteSlider').value = 50;
                }, 1500);
                
                // å‹•ç•«çµæŸå¾Œé‡ç½®å‹•ç•«ç‹€æ…‹
                setTimeout(() => {
                    scoreAnimationActive = false;
                }, 2000);
            }
        }

        function undoVote() {
            if (voteHistory.length === 0) return;
            const lastVote = voteHistory.pop();
            currentGame.votes.pop();
            
            const item1 = currentGame.items.find(item => item.id === lastVote.pair[0].id);
            const item2 = currentGame.items.find(item => item.id === lastVote.pair[1].id);
            
            if (item1 && item2) {
                ['score', 'wins', 'losses'].forEach(prop => {
                    item1[prop] = lastVote[prop === 'score' ? 'oldScores' : `old${prop.charAt(0).toUpperCase() + prop.slice(1)}`].item1;
                    item2[prop] = lastVote[prop === 'score' ? 'oldScores' : `old${prop.charAt(0).toUpperCase() + prop.slice(1)}`].item2;
                });
                
                // å¾©åŸå¿ƒæƒ…ç‹€æ…‹
                if (lastVote.oldMoods) {
                    item1.moods = [...lastVote.oldMoods.item1];
                    item2.moods = [...lastVote.oldMoods.item2];
                }
                
                item1.votes--; item2.votes--;
                localStorage.setItem('games', JSON.stringify(games));
                syncData();
                
                currentPair = lastVote.pair;
                ['option1Title', 'option2Title'].forEach((id, idx) => 
                    document.getElementById(id).textContent = currentPair[idx].name);
                [0, 1].forEach(idx => {
                    const link = getRandomValidLink(currentPair[idx]);
                    currentVideoLinks[idx] = link;
                    loadVideo(`video${idx + 1}Container`, link, idx + 1);
                });
                document.getElementById('voteSlider').value = 50;
                
                // é‡æ–°å‰µå»ºå¿ƒæƒ…æŒ‰éˆ•ä»¥åæ˜ å¾©åŸå¾Œçš„å¿ƒæƒ…ç‹€æ…‹
                createMoodButtons();
                
                if (statsVisible) updateItemStats();
                if (voteHistory.length === 0) document.getElementById('undoBtn').disabled = true;
            }
        }

        function updateStatsGameSelect() {
            const select = document.getElementById('statsGameSelect');
            const currentValue = select.value;
            select.innerHTML = '<option value="">è«‹é¸æ“‡éŠæˆ²</option>';
            Object.values(games).forEach(game => {
                const option = document.createElement('option');
                option.value = game.id; option.textContent = game.name;
                select.appendChild(option);
            });
            if (currentValue) select.value = currentValue;
        }

        function searchRanking() {
            const searchText = document.getElementById('rankingSearch').value.toLowerCase();
            const rankingItems = document.querySelectorAll('#rankingList .list-item');
            let visibleCount = 0;
            
            rankingItems.forEach(item => {
                const itemName = item.querySelector('.item-name');
                if (itemName) {
                    const isVisible = itemName.textContent.toLowerCase().includes(searchText);
                    item.style.display = isVisible ? '' : 'none';
                    if (isVisible) visibleCount++;
                }
            });
            
            // æ›´æ–°æ’è¡Œæ¦œæ¨™é¡Œç‚ºï¼š"æ’è¡Œæ¦œ ([ç•¶å‰é¡¯ç¤ºçš„é …ç›®æ•¸]/[è©²éŠæˆ²çš„ç¸½é …ç›®æ•¸])"
            const gameId = document.getElementById('statsGameSelect').value;
            const totalItems = gameId ? games[gameId].items.length : 0;
            const titleText = `æ’è¡Œæ¦œ (${visibleCount}/${totalItems})`;
            document.getElementById('rankingTitle').textContent = titleText;
        }

        function loadStats() {
            const gameId = document.getElementById('statsGameSelect').value;
            selectedGameId = gameId; localStorage.setItem('selectedGameId', selectedGameId);
            if (!gameId) { document.getElementById('statsContent').classList.add('hidden'); return; }

            // ä¿å­˜æœå°‹å­—ä¸²
            const searchText = document.getElementById('rankingSearch').value;

            const game = games[gameId];
            document.getElementById('statsContent').classList.remove('hidden');
            document.getElementById('totalItems').textContent = game.items.length;
            document.getElementById('totalVotes').textContent = game.votes.length;
            
			/*
			// å¹³å‡å…¨æŠ½å–
            let H = 0, n = game.items.length;
            for(let k = 1; k < n; ++k) H += 1/k;
			let expectedValue = Math.round(n*(n-1)/2*H) ;
			*/
			let expectedValue = 25 * game.items.length ; // æ¯é …ç›®50ç¥¨æ¬¡
            document.getElementById('expectedVotes').textContent = expectedValue ;
            
            // ä¿®æ”¹ï¼šå°‡æœ€ä½åˆ†æ•¸ã€å¹³å‡åˆ†æ•¸ã€ä¸­ä½åˆ†æ•¸ã€æœ€é«˜åˆ†æ•¸åˆ†é–‹é¡¯ç¤º
            let minScore = Infinity, maxScore = -Infinity, totalScore = 0;
            let scores = [];
            game.items.forEach(item => {
                if (item.score < minScore) minScore = item.score;
                if (item.score > maxScore) maxScore = item.score;
                totalScore += item.score;
                scores.push(item.score);
            });
            
            // è¨ˆç®—ä¸­ä½åˆ†æ•¸
            scores.sort((a, b) => a - b);
            let medianScore;
            const mid = Math.floor(scores.length / 2);
            if (scores.length % 2 === 0) {
                medianScore = (scores[mid - 1] + scores[mid]) / 2;
            } else {
                medianScore = scores[mid];
            }
            
            const avgScore = game.items.length > 0 ? (totalScore / game.items.length).toFixed(2) : 1500;
            document.getElementById('minScore').textContent = minScore;
            document.getElementById('avgScore').textContent = avgScore;
            document.getElementById('medianScore').textContent = medianScore;
            document.getElementById('maxScore').textContent = maxScore;
            
            // ä¿®æ”¹ï¼šè¨ˆç®—å¹³å‡èª¤å·®ï¼ˆé™¤äº†âˆï¼‰
            let totalError = 0, validErrorCount = 0;
            game.items.forEach(item => {
                const error = calculateError(item);
                if (error !== Infinity) {
                    totalError += error;
                    validErrorCount++;
                }
            });
            const avgError = validErrorCount > 0 ? (totalError / validErrorCount).toFixed(2) : 0;
            document.getElementById('avgError').textContent = avgError;

            const sortBy = document.getElementById('sortBy').value;
            let sortedItems = [...game.items];
            
            // æ‡‰ç”¨å¿ƒæƒ…ç¯©é¸
            if (statsMoodFilters.length > 0) {
                sortedItems = applyMoodFilter(sortedItems, statsMoodFilters, statsMoodLogic);
            }
            
            // å»ºç«‹æ‰€æœ‰é …ç›®çš„çœŸå¯¦æ’åè¡¨ï¼ˆæŒ‰ç…§åˆ†æ•¸->èª¤å·®->å‹ç‡->ç¥¨æ¬¡æ’åºï¼‰
            const allItemsRanked = sortItemsByRank(game.items);
            const rankMap = new Map();
            allItemsRanked.forEach((item, index) => {
                rankMap.set(item.id, index + 1);
            });

            switch(sortBy) {
                case 'rank':
                case 'score':
                    sortedItems = sortItemsByRank(sortedItems);
                    break;
                case 'winRate': 
                    sortedItems.sort((a, b) => {
                        const winRateA = a.votes > 0 ? (a.wins || 0) / a.votes : 0;
                        const winRateB = b.votes > 0 ? (b.wins || 0) / b.votes : 0;
                        return winRateB - winRateA;
                    }); 
                    break;
                case 'votes': sortedItems.sort((a, b) => b.votes - a.votes); break;
                case 'time': sortedItems.sort((a, b) => (b.addedTime || 0) - (a.addedTime || 0)); break;
                case 'error': // ä¾èª¤å·®æ’åºï¼ˆèª¤å·®ç‚ºç„¡é™å¤§çš„æ’æœ€å…ˆï¼‰
                    sortedItems.sort((a, b) => {
                        const errorA = calculateError(a);
                        const errorB = calculateError(b);
                        // èª¤å·®ç‚ºç„¡é™å¤§çš„æ’åœ¨æœ€å‰é¢
                        if (errorA === Infinity && errorB !== Infinity) return -1;
                        if (errorA !== Infinity && errorB === Infinity) return 1;
                        return errorB - errorA; // èª¤å·®å¤§çš„æ’å…ˆ
                    });
                    break;
            }
            
            const rankingList = document.getElementById('rankingList');
            rankingList.innerHTML = '';
            sortedItems.forEach((item, index) => {
                const winRate = item.votes > 0 ? ((item.wins || 0) / item.votes * 100).toFixed(1) : '0.0';
                const p = item.votes > 0 ? ( item.wins || 0 ) / item.votes : 0 ;
                let error = calculateError(item); // ä½¿ç”¨æ–°çš„è¨ˆç®—èª¤å·®å‡½æ•¸
                error = error === Infinity ? 'âˆ' : Math.round(error) ;
                const rankingItem = document.createElement('div');
                rankingItem.className = 'list-item';
                // ä½¿ç”¨å…¨å±€æ’åï¼Œè€Œä¸æ˜¯ç¯©é¸å¾Œçš„æ’å
                const displayRank = rankMap.get(item.id);
                
                // å‰µå»ºå¿ƒæƒ…é¡¯ç¤ºå€åŸŸ
                let moodDisplay = '';
                if (item.moods && item.moods.length > 0) {
                    moodDisplay = `<div class="mood-display">${item.moods.join('')}</div>`;
                }

                rankingItem.innerHTML = `
                    <span style="font-size: 1.5em; font-weight: bold; color: var(--primary); margin-right: 20px;">#${displayRank}</span>
                    <span class="item-name" style="flex: 1; font-weight: bold;">${item.name}</span>
                    <div style="display: flex; align-items: center;">
                        ${moodDisplay}
                        <span style="font-size: 1.2em; color: var(--success);">åˆ†æ•¸: ${item.score}Â±${error} | å‹ç‡: ${winRate}% | ç¥¨æ¬¡: ${item.votes}</span>
                    </div>`;
                rankingList.appendChild(rankingItem);
            });

            // æ¢å¾©æœå°‹å­—ä¸²ä¸¦è§¸ç™¼æœå°‹
            document.getElementById('rankingSearch').value = searchText;
            
            // æ›´æ–°æ’è¡Œæ¦œæ¨™é¡Œç‚ºï¼š"æ’è¡Œæ¦œ ([ç•¶å‰é¡¯ç¤ºçš„é …ç›®æ•¸]/[è©²éŠæˆ²çš„ç¸½é …ç›®æ•¸])"
            const titleText = `æ’è¡Œæ¦œ (${sortedItems.length}/${game.items.length})`;
            document.getElementById('rankingTitle').textContent = titleText;
            
            if (searchText) searchRanking();
        }

        function refreshStats() {
            games = JSON.parse(localStorage.getItem('games')) || {};
            updateStatsGameSelect();
            const gameId = document.getElementById('statsGameSelect').value;
            if (gameId) loadStats();
        }

        function clearStats() {
            const gameId = document.getElementById('statsGameSelect').value;
            if (!gameId) { alert('è«‹å…ˆé¸æ“‡éŠæˆ²'); return; }
            if (confirm('ç¢ºå®šè¦æ¸…é™¤é€™å€‹éŠæˆ²çš„æ‰€æœ‰æŠ•ç¥¨æ•¸æ“šå—ï¼Ÿæ­¤æ“ä½œç„¡æ³•å¾©åŸï¼')) {
                const game = games[gameId];
                game.items.forEach(item => {
                    item.score = 1500; item.votes = 0; item.wins = 0; item.losses = 0;
                    item.moods = []; // åŒæ™‚æ¸…é™¤å¿ƒæƒ…æ¨™è¨˜
                });
                game.votes = [];
                localStorage.setItem('games', JSON.stringify(games));
                syncData();
                loadStats(); alert('çµ±è¨ˆæ•¸æ“šå·²æ¸…é™¤');
            }
        }

        function getFormattedDate() {
            const now = new Date();
            return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
        }

        function exportSettings() {
            const settingsData = {};
            Object.values(games).forEach(game => {
                settingsData[game.id] = {
                    id: game.id, name: game.name,
                    items: game.items.map(item => ({
                        id: item.id, name: item.name, links: item.links || [],
                        invalidLinks: item.invalidLinks || [], addedTime: item.addedTime,
                        moods: item.moods || [] // å°å‡ºå¿ƒæƒ…æ¨™è¨˜
                    }))
                };
            });
            downloadFile(settingsData, `è¨­å®š${getFormattedDate()}.json`);
        }

        function exportStats() {
            const statsData = {};
            Object.values(games).forEach(game => {
                statsData[game.id] = {
                    id: game.id, name: game.name, votes: game.votes,
                    items: game.items.map(item => ({
                        id: item.id, name: item.name, score: item.score, votes: item.votes,
                        wins: item.wins || 0, losses: item.losses || 0,
                        moods: item.moods || [] // å°å‡ºå¿ƒæƒ…æ¨™è¨˜
                    }))
                };
            });
            downloadFile(statsData, `çµ±è¨ˆ${getFormattedDate()}.json`);
        }

        function downloadFile(data, filename) {
            const dataStr = JSON.stringify(data, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url; link.download = filename; link.click();
            URL.revokeObjectURL(url);
        }

        function importSettings(event) { importFile(event, 'settings'); }
        function importStats(event) { importFile(event, 'stats'); }

        function importFile(event, type) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    const isSettings = type === 'settings';
                    const message = isSettings ? 'åŒ¯å…¥è¨­å®šå°‡æœƒè¦†è“‹ç¾æœ‰éŠæˆ²è¨­å®šï¼ˆä½†ä¿ç•™çµ±è¨ˆè³‡æ–™ï¼‰ï¼Œç¢ºå®šè¦ç¹¼çºŒå—ï¼Ÿ' : 'åŒ¯å…¥çµ±è¨ˆå°‡æœƒè¦†è“‹ç¾æœ‰æŠ•ç¥¨è³‡æ–™ï¼Œç¢ºå®šè¦ç¹¼çºŒå—ï¼Ÿ';
                    
                    if (confirm(message)) {
                        Object.values(importedData).forEach(importedGame => {
                            if (isSettings) {
                                if (games[importedGame.id]) {
                                    const existingGame = games[importedGame.id];
                                    importedGame.votes = existingGame.votes || [];
                                    importedGame.items.forEach(item => {
                                        const existingItem = existingGame.items.find(ei => ei.id === item.id);
                                        if (existingItem) {
                                            ['score', 'votes', 'wins', 'losses'].forEach(prop => 
                                                item[prop] = existingItem[prop] || (prop === 'score' ? 1500 : 0));
                                        } else {
                                            item.score = 1500; item.votes = 0; item.wins = 0; item.losses = 0;
                                        }
                                        if (!item.links) item.links = item.link ? [item.link] : [];
                                        if (!item.invalidLinks) item.invalidLinks = [];
                                        if (!item.moods) item.moods = [];
                                    });
                                } else {
                                    importedGame.votes = [];
                                    importedGame.items.forEach(item => {
                                        item.score = 1500; item.votes = 0; item.wins = 0; item.losses = 0;
                                        if (!item.links) item.links = item.link ? [item.link] : [];
                                        if (!item.invalidLinks) item.invalidLinks = [];
                                        if (!item.moods) item.moods = [];
                                    });
                                }
                                games[importedGame.id] = importedGame;
                            } else {
                                if (games[importedGame.id]) {
                                    games[importedGame.id].votes = importedGame.votes || [];
                                    importedGame.items.forEach(importedItem => {
                                        const item = games[importedGame.id].items.find(i => i.id === importedItem.id);
                                        if (item) {
                                            ['score', 'votes', 'wins', 'losses', 'moods'].forEach(prop => 
                                                item[prop] = importedItem[prop] || (prop === 'score' ? 1500 : (prop === 'moods' ? [] : 0)));
                                        }
                                    });
                                }
                            }
                        });
                        localStorage.setItem('games', JSON.stringify(games));
                        syncData();
                        if (isSettings) updateGamesList();
                        else loadStats();
                        alert(`${isSettings ? 'è¨­å®š' : 'çµ±è¨ˆ'}åŒ¯å…¥æˆåŠŸï¼`);
                    }
                } catch (error) { alert('åŒ¯å…¥å¤±æ•—ï¼šæª”æ¡ˆæ ¼å¼éŒ¯èª¤'); }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // æ¸…é™¤æ‰€æœ‰ç„¡æ•ˆé€£çµ - ä¿®æ”¹ç‚ºåˆªé™¤æ•´è¡Œç„¡æ•ˆé€£çµ
        function clearAllInvalidLinks() {
            if (!selectedGameForEdit) { alert('è«‹å…ˆé¸æ“‡è¦ç·¨è¼¯çš„éŠæˆ²'); return; }
            
            if (confirm('ç¢ºå®šè¦åˆªé™¤æ‰€æœ‰é …ç›®çš„ç„¡æ•ˆé€£çµå—ï¼Ÿæ­¤æ“ä½œç„¡æ³•å¾©åŸï¼')) {
                const game = games[selectedGameForEdit];
                let deletedCount = 0;
                
                game.items.forEach(item => {
                    if (item.invalidLinks && item.invalidLinks.length > 0) {
                        // å¾linksä¸­åˆªé™¤æ‰€æœ‰åœ¨invalidLinksä¸­çš„é€£çµ
                        const originalLinkCount = item.links.length;
                        item.links = item.links.filter(link => !item.invalidLinks.includes(link));
                        deletedCount += (originalLinkCount - item.links.length);
                        // æ¸…ç©ºinvalidLinks
                        item.invalidLinks = [];
                    }
                });
                
                localStorage.setItem('games', JSON.stringify(games));
                syncData();
                updateItemsListWithPagination();
                alert(`å·²åˆªé™¤ ${deletedCount} å€‹ç„¡æ•ˆé€£çµï¼`);
            }
        }

        // è·¨ç€è¦½å™¨åˆ†é åŒæ­¥
        function syncData() {
            // ç™¼å‡ºè‡ªå®šç¾©äº‹ä»¶é€šçŸ¥å…¶ä»–æ¨™ç±¤é æ•¸æ“šå·²æ›´æ–°
            localStorage.setItem('games_sync', Date.now().toString());
        }

        // ç›£è½é›¢é–‹é é¢äº‹ä»¶
        window.addEventListener('beforeunload', function (e) {
            if (isEditing) {
                e.preventDefault();
                e.returnValue = 'æ‚¨æ­£åœ¨ç·¨è¼¯é …ç›®ï¼Œç¢ºå®šè¦é›¢é–‹å—ï¼Ÿ';
                return e.returnValue;
            }
        });

        // æ–°å¢ï¼šæ”¶èµ·é …ç›®ç®¡ç†åŠŸèƒ½
        function toggleItemsManagement() {
			// å¦‚æœæ­£åœ¨ç·¨è¼¯é …ç›®ï¼Œä¿å­˜ç•¶å‰ç·¨è¼¯å…§å®¹
            if (isEditing && editingItemId) {
                saveEditingItemData();
            }
            document.getElementById('itemsManagement').classList.add('hidden');
        }

        document.addEventListener('DOMContentLoaded', function() {
            migrateOldData(); updateGamesList(); updateGameSelect();
            createVotingMoodFilter();
            
            // å¾localStorageè®€å–å¿ƒæƒ…ç¯©é¸é‚è¼¯
            votingMoodLogic = localStorage.getItem('votingMoodLogic') || 'and';
            settingsMoodLogic = localStorage.getItem('settingsMoodLogic') || 'and';
            statsMoodLogic = localStorage.getItem('statsMoodLogic') || 'and';
            
            // è¨­ç½®ä¸‹æ‹‰é¸å–®çš„åˆå§‹å€¼
            const votingMoodLogicSelect = document.getElementById('votingMoodLogic');
            if (votingMoodLogicSelect) {
                votingMoodLogicSelect.value = votingMoodLogic;
            }
            const settingsMoodLogicSelect = document.getElementById('settingsMoodLogic');
            if (settingsMoodLogicSelect) {
                settingsMoodLogicSelect.value = settingsMoodLogic;
            }
            const statsMoodLogicSelect = document.getElementById('statsMoodLogic');
            if (statsMoodLogicSelect) {
                statsMoodLogicSelect.value = statsMoodLogic;
            }
            
            // ç‚ºå¿ƒæƒ…é‚è¼¯ä¸‹æ‹‰é¸å–®æ·»åŠ äº‹ä»¶ç›£è½
            document.getElementById('votingMoodLogic').addEventListener('change', function() {
                votingMoodLogic = this.value;
                localStorage.setItem('votingMoodLogic', votingMoodLogic);
                updateItemCountMax();
            });
            
            document.getElementById('settingsMoodLogic').addEventListener('change', function() {
                settingsMoodLogic = this.value;
                localStorage.setItem('settingsMoodLogic', settingsMoodLogic);
                filterItems();
            });
            
            document.getElementById('statsMoodLogic').addEventListener('change', function() {
                statsMoodLogic = this.value;
                localStorage.setItem('statsMoodLogic', statsMoodLogic);
                loadStats();
            });
            
            // ç‚ºè¨­å®šé å’Œçµ±è¨ˆé æ·»åŠ äº‹ä»¶ç›£è½
            document.getElementById('itemFilter').addEventListener('keyup', filterItems);
            document.getElementById('pageSize').addEventListener('change', changePageSize);
            document.getElementById('statsGameSelect').addEventListener('change', loadStats);
            document.getElementById('sortBy').addEventListener('change', loadStats);
            document.getElementById('rankingSearch').addEventListener('keyup', searchRanking);
            document.getElementById('importStatsFile').addEventListener('change', importStats);
            
            if (selectedGameId) {
                document.getElementById('gameSelect').value = selectedGameId;
                updateGameSettings();
            }
            if (selectedExtractMode) document.getElementById('extractMode').value = selectedExtractMode;
            
            // ç‚ºitemCountæ·»åŠ Enteréµäº‹ä»¶
            document.getElementById('itemCount').addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    startGame();
                }
            });
            
            // ç‚ºkeywordFilteræ·»åŠ Enteréµäº‹ä»¶
            document.getElementById('keywordFilter').addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    startGame();
                }
            });
            
            // ä¿®æ”¹ï¼šä¿å­˜ç¯©é¸è¼¸å…¥æ¡†å…§å®¹åˆ°localStorage
            document.getElementById('keywordFilter').addEventListener('input', function(e) {
                localStorage.setItem('keywordFilter', e.target.value);
            });
            
            // ç›£è½storageäº‹ä»¶ä»¥å¯¦ç¾è·¨åˆ†é åŒæ­¥
            window.addEventListener('storage', function(e) {
                if (e.key === 'games_sync') {
                    // é‡æ–°å¾localStorageåŠ è¼‰æ•¸æ“š
                    games = JSON.parse(localStorage.getItem('games')) || {};
                    
                    // æ›´æ–°UI
                    updateGamesList();
                    updateGameSelect();
                    updateStatsGameSelect();
                    
                    // å¦‚æœç•¶å‰åœ¨æŠ•ç¥¨é ä¸”æ­£åœ¨é€²è¡ŒéŠæˆ²ï¼Œé‡æ–°åŠ è¼‰ç•¶å‰å°æˆ°çµ„åˆ
                    if (currentGame && currentPair) {
                        // æ›´æ–°currentGameå’ŒcurrentPair
                        currentGame = games[currentGame.id];
                        if (currentGame) {
                            currentPair = currentPair.map(p => 
                                currentGame.items.find(i => i.id === p.id) || p
                            );
                            loadBothVideos();
                            createMoodButtons();
                            if (statsVisible) updateItemStats();
                        }
                    }
                    
                    // å¦‚æœç•¶å‰åœ¨çµ±è¨ˆé ï¼Œé‡æ–°è¼‰å…¥çµ±è¨ˆ
                    if (document.getElementById('stats').classList.contains('active')) {
                        loadStats();
                    }
                }
            });
        });
    </script>
</body>
</html>
