<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç„¡é™å°æ±º</title>
    <style>
        :root {
            --primary: #667eea; --secondary: #764ba2; --success: #48bb78;
            --danger: #f56565; --info: #4299e1; --warning: #9f7aea; --gray: #718096;
            --frozen: #00b7eb;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            min-height: 100vh; color: #333;
        }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; color: white; margin-bottom: 0px; padding: 0px; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .nav-buttons { display: flex; justify-content: center; gap: 20px; margin-bottom: 15px; }
        .btn {
            padding: 12px 30px; border: none; border-radius: 25px; font-size: 16px;
            font-weight: bold; cursor: pointer; transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0,0,0,0.2); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-nav { background: white; color: #333; }
        .btn-nav.active { background: #4a5568; color: white; }
        .btn-primary { background: var(--success); color: white; }
        .btn-info { background: var(--info); color: white; }
        .btn-warning { background: var(--warning); color: white; }
        .btn-danger { background: var(--danger); color: white; }
        .btn-gray { background: var(--gray); color: white; }
        .btn-frozen { background: var(--frozen); color: white; }
		#toggleStatsButton.active { background: var(--info); color: white; }
        .page { display: none; animation: fadeIn 0.5s; }
        .page.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .card { background: white; border-radius: 20px; padding: 30px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; font-weight: bold; margin-bottom: 5px; }
        .form-control {
            width: 100%; padding: 10px; border: 2px solid #e2e8f0;
            border-radius: 10px; font-size: 16px;
        }
        .vs-container { display: grid; grid-template-columns: 1fr auto 1fr; gap: 20px; align-items: center; margin-bottom: 30px; }
		.vs-container .btn-info {
			width: 50px;
			height: 50px;
			background: rgba(255,255,255,0.95);
			border: 2px solid var(--info);
			border-radius: 50%;
			cursor: pointer;
			transition: all 0.3s;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 16px;
			box-shadow: 0 2px 8px rgba(0,0,0,0.2);
			padding: 0;
			margin: 5px;
		}
		.vs-container .btn-info:hover {
			transform: translateY(-2px);
			box-shadow: 0 4px 12px rgba(0,0,0,0.3);
			background: white;
		}
		.vs-container .btn-info[onclick="reloadBothVideos()"] {
			position: relative;
		}
		.vs-container .btn-info[onclick="reloadBothVideos()"] span {
			display: inline-block;
			transition: transform 0.3s;
		}
		.vs-container .btn-info[onclick="reloadBothVideos()"]:hover span {
			transform: rotate(-180deg);
		}
        .option-card {
			background: #f7fafc; border-radius: 15px; padding: 20px; text-align: center;
			transition: all 0.3s;
			position: relative;
			min-height: 200px;
		}
        .option-card:hover { transform: scale(1.05); background: #edf2f7; box-shadow: 0 10px 25px rgba(0,0,0,0.15); }
        .option-title { font-size: 1.5em; font-weight: bold; margin-bottom: 15px; color: #2d3748; }
        .video-container {
            width: 100%; aspect-ratio: 16/9; background: #000; border-radius: 10px;
            overflow: hidden; margin-bottom: 15px; position: relative;
        }
        .video-container iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; }
        .reload-btn, .invalid-btn {
            position: absolute; top: 10px; background: rgba(255,255,255,0.9);
            border: none; border-radius: 50%; cursor: pointer; z-index: 10; transition: all 0.3s;
        }
        .reload-btn { right: 10px; width: 35px; height: 35px; display: flex; align-items: center; justify-content: center; }
        .reload-btn:hover { background: white; transform: rotate(180deg); }
        .invalid-btn { left: 10px; padding: 5px 10px; border-radius: 15px; font-size: 12px; }
        .invalid-btn.active { background: var(--danger); color: white; }
        .vs-text { font-size: 3em; font-weight: bold; color: #e53e3e; text-shadow: 2px 2px 4px rgba(0,0,0,0.1); }
        .item-stats { background: rgba(255,255,255,0.95); border-radius: 10px; padding: 10px; margin-top: 10px; font-size: 0.9em; }
        .score-change {
			margin-top: 10px; font-size: 1.5em; font-weight: bold; opacity: 0;
			animation: scoreFloat 2s ease-out;
			position: absolute;
			bottom: 10px;
			left: 0;
			right: 0;
			text-align: center;
			z-index: 5;
		}
        .score-change.positive { color: var(--success); }
        .score-change.negative { color: var(--danger); }
        @keyframes scoreFloat { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(30px); } }
        .vote-slider-container {
			background: linear-gradient(90deg, var(--success) 0%, #f7fafc 50%, var(--danger) 100%);
			border-radius: 50px;
			padding: 5px;
			margin: 0px auto;
			max-width: 600px;
			position: relative;
			display: flex;
			align-items: center;
			justify-content: space-between;
		}	
        .vote-slider {
			flex: 1;
			width: 600px;
			height: 60px;
			-webkit-appearance: none;
			appearance: none;
			background: transparent;
			outline: none;
			cursor: pointer;
			margin: 0;
		}
        .vote-slider::-webkit-slider-thumb {
			-webkit-appearance: none;
			width: 50px;
			height: 50px;
			background: white;
			cursor: pointer;
			border-radius: 50%;
			box-shadow: 0 4px 10px rgba(0,0,0,0.3);
			z-index: 10;
			position: relative;
		}
		.vote-slider::-webkit-slider-thumb:hover {
			transform: translateY(-2px);
			box-shadow: 0 4px 12px rgba(0,0,0,0.3);
			background: white;
		}
        .lock-btn-container {
			display: flex;
			align-items: center;
			justify-content: center;
			width: 60px;
			position: relative;
			z-index: 20;
		}
        .lock-btn, .freeze-btn {
			width: 50px;
			height: 50px;
			background: rgba(255,255,255,0.95);
			border-radius: 50%;
			cursor: pointer;
			z-index: 30;
			transition: all 0.3s;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 16px;
			box-shadow: 0 2px 8px rgba(0,0,0,0.2);
		}
        .lock-btn {
            border: 2px solid var(--warning);
        }
        .freeze-btn {
            border: 2px solid var(--frozen);
        }
		.lock-btn:hover, .freeze-btn:hover {
			transform: translateY(-2px);
			box-shadow: 0 4px 12px rgba(0,0,0,0.3);
			background: white;
		}
        .lock-btn.active { background: var(--warning); color: white; }
        .freeze-btn.active { background: var(--frozen); color: white; }
        .flex-center { display: flex; justify-content: center; gap: 20px; margin: 20px auto; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-top: 20px; }
        .stat-card {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white; border-radius: 15px; padding: 20px; text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
		.grid .stat-card {
			height: 120px;
			display: flex;
			flex-direction: column;
			justify-content: center;
		}
        .stat-value { font-size: 2.5em; font-weight: bold; margin-bottom: 10px; }
        .list-item {
            background: #f7fafc; border-radius: 10px; padding: 15px; margin-bottom: 10px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .list-item.editing { background: #e6fffa; border: 2px solid var(--info); }
        .list-item.frozen { border: 2px solid var(--frozen); }
        .item-info { flex: 1; display: flex; gap: 15px; align-items: center; }
        .item-preview { width: 160px; height: 90px; background: #000; border-radius: 5px; overflow: hidden; position: relative; flex-shrink: 0; }
        .item-preview iframe { width: 100%; height: 100%; border: none; }
        .pagination { display: flex; gap: 5px; align-items: center; justify-content: center; }
        .hidden { display: none !important; }
        .invalid-link { color: var(--danger) !important; text-decoration: line-through; }
        .filter-controls { display: flex; gap: 10px; align-items: center; }
        .checkbox-container { display: flex; align-items: center; gap: 5px; }
        .toggle-btn { 
            padding: 8px 16px; border: 2px solid var(--gray); border-radius: 20px; 
            background: white; color: var(--gray); cursor: pointer; transition: all 0.3s;
        }
        .toggle-btn.active { 
            background: var(--danger); color: white; border-color: var(--danger);
        }
        .toggle-btn-frozen { 
            padding: 8px 16px; border: 2px solid var(--frozen); border-radius: 20px; 
            background: white; color: var(--frozen); cursor: pointer; transition: all 0.3s;
        }
        .toggle-btn-frozen.active { 
            background: var(--frozen); color: white; border-color: var(--frozen);
        }
        .game-settings-row {
            display: flex; gap: 20px; align-items: center; justify-content: center; flex-wrap: wrap; margin-bottom: 30px;
        }
        .game-settings-row .form-group {
            margin-bottom: 0;
        }
        .game-settings-row label {
            margin-right: 5px;
        }
        .mood-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .mood-btn {
            font-size: 1.5em;
            background: none;
            border: 2px solid #e2e8f0;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            transition: all 0.3s;
        }
		.mood-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0,0,0,0.2); }
        .mood-btn.active {
            background: var(--primary);
            border-color: var(--primary);
        }
		.mood-btn.active:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0,0,0,0.2); }
        .mood-display {
            display: flex;
            gap: 5px;
            margin-right: 10px;
        }
        .mood-filter-btn {
            font-size: 1.2em;
            background: none;
            border: 2px solid #e2e8f0;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            cursor: pointer;
            transition: all 0.3s;
        }
		.mood-filter-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0,0,0,0.2); }
		.mood-filter-buttons {
			display: flex;
			gap: 5px;
			flex-wrap: nowrap;
		}
        .mood-filter-btn.active {
            background: var(--primary);
            border-color: var(--primary);
        }
		.mood-filter-btn.active:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0,0,0,0.2); }
        .mood-filter-container {
            display: flex;
            gap: 5px;
            align-items: center;
            flex-wrap: nowrap;
            padding: 5px 0;
        }
        .mood-filter-row {
            display: flex;
            gap: 5px;
            width: 100%;
            justify-content: center;
        }
        .clear-invalid-btn {
            background: var(--warning) !important;
            color: white !important;
        }
        .voting-mood-filter-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }
        .voting-mood-filter-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .voting-keyword-filter {
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative;
        }
        .clear-filter-btn {
            position: absolute;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.2em;
            cursor: pointer;
            color: var(--gray);
            transition: all 0.3s;
        }
        .clear-filter-btn:hover {
            color: var(--danger);
            transform: scale(1.1);
        }
        .edit-mood-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        .edit-mood-btn {
            font-size: 1.2em;
            background: none;
            border: 2px solid #e2e8f0;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .edit-mood-btn.active {
            background: var(--primary);
            border-color: var(--primary);
            transform: scale(1.0);
        }
		.edit-mood-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0,0,0,0.2); }
        .item-mood-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        .item-mood-btn {
            font-size: 1.2em;
            background: none;
            border: 2px solid #e2e8f0;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            cursor: pointer;
            transition: all 0.3s;
        }
		.item-mood-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0,0,0,0.2); }
        .item-mood-btn.active {
            background: var(--primary);
            border-color: var(--primary);
        }
		.item-mood-btn.active:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0,0,0,0.2); }
        .current-video-url {
            font-size: 0.8em;
            color: var(--gray);
            margin-top: 5px;
            word-break: break-all;
            max-height: 60px;
            overflow-y: auto;
            background: rgba(0,0,0,0.05);
            padding: 5px;
            border-radius: 5px;
        }
        .slider-score-change {
            position: absolute;
            top: -40px;
            font-size: 1.8em;
            font-weight: bold;
            opacity: 0;
            z-index: 10;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .slider-score-change.positive { color: var(--success); }
        .slider-score-change.negative { color: var(--danger); }
        .slider-score-change.left { 
            left: 10%; 
            animation: scoreFloatLeft 2s ease-out;
        }
        .slider-score-change.right { 
            right: 10%; 
            animation: scoreFloatRight 2s ease-out;
        }
		.slider-score-change.zero { color: var(--gray); }
        @keyframes scoreFloatLeft { 
            0% { opacity: 1; transform: translateX(0); } 
            100% { opacity: 0; transform: translateX(-50px); } 
        }
        @keyframes scoreFloatRight { 
            0% { opacity: 1; transform: translateX(0); } 
            100% { opacity: 0; transform: translateX(50px); } 
        }
        .mood-logic-select {
            padding: 5px 10px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }
        .mood-logic-select:focus {
            outline: none;
            border-color: var(--primary);
        }
        .form-row {
            display: flex;
            align-items: flex-end;
            gap: 15px;
            margin-bottom: 20px;
        }
        .form-row .form-group {
            margin-bottom: 0;
            flex: 1;
        }
        .items-management-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .score-chart-container {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
        }
        .score-chart {
            width: 100%;
            height: 300px;
        }
        .ranking-item {
            cursor: pointer;
            transition: all 0.3s;
        }
        .ranking-item:hover {
            background: #edf2f7 !important;
        }
        .ranking-item.expanded {
            background: #f0fff4 !important;
            border: 2px solid var(--success);
        }
        .ranking-item.frozen { border: 2px solid var(--frozen); }
		.ranking-separator {
			background: rgba(245, 101, 101, 0.1) !important;
			border: 2px solid rgba(245, 101, 101, 0.3) !important;
			border-radius: 10px !important;
			margin: 10px 0 !important;
			height: 10px !important;
			padding: 15px !important;
		}
        .no-history-data {
            text-align: center;
            padding: 0px;
            color: var(--gray);
            font-style: italic;
        }
        .chart-controls {
            display: flex;
            gap: 10px;
            margin-right: 10px;
        }
        .distribution-chart-container {
            width: 100%;
			height: 120%;
			margin-top: 0px;
			flex: 1;
        }
        .distribution-chart {
            width: 100%;
            height: 100%;
        }
        
        /* å¹³å°ç­›é€‰æŒ‰é’®æ ·å¼ */
        .platform-filter-buttons {
			display: flex;
			gap: 10px;
			justify-content: center;
			margin: 10px 0;
		}
		.platform-filter-btn {
			width: 50px;
			height: 50px;
			background: rgba(255,255,255,0.95);
			border: 2px solid var(--info);
			border-radius: 50%;
			cursor: pointer;
			transition: all 0.3s;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 16px;
			box-shadow: 0 2px 8px rgba(0,0,0,0.2);
			padding: 0;
			position: relative;
		}
		.platform-filter-btn:hover {
			transform: translateY(-2px);
			box-shadow: 0 4px 12px rgba(0,0,0,0.3);
			background: white;
		}
		.platform-filter-btn.active {
			color: white;
		}
		.platform-filter-btn:not(.active)::after {
			content: "";
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: linear-gradient(135deg, transparent 42%, rgba(255,0,0,0.8) 42%, rgba(255,0,0,0.8) 58%, transparent 58%);
			border-radius: 50%;
		}
		.youtube-logo, .bilibili-logo {
			width: 30px;
			height: 30px;
			background-size: contain;
			background-repeat: no-repeat;
			background-position: center;
			transition: all 0.3s;
		}
		.youtube-logo {
			background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="red" d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/></svg>');
		}
		.bilibili-logo {
			background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%2300a1d6" d="M18.223 3.086a1.25 1.25 0 0 1 0 1.768L17.08 5.996h1.17A3.75 3.75 0 0 1 22 9.746v7.5a3.75 3.75 0 0 1-3.75 3.75H5.75A3.75 3.75 0 0 1 2 17.246v-7.5a3.75 3.75 0 0 1 3.75-3.75h1.18L5.777 4.854a1.25 1.25 0 1 1 1.767-1.768l2.652 2.652c.079.079.145.165.198.257h3.213c.053-.092.12-.178.199-.257l2.651-2.652a1.25 1.25 0 0 1 1.768 0zm.027 5.42H5.75a1.25 1.25 0 0 0-1.25 1.25v7.5a1.25 1.25 0 0 0 1.25 1.25h12.5a1.25 1.25 0 0 0 1.25-1.25v-7.5a1.25 1.25 0 0 0-1.25-1.25zm-10 2.5c.69 0 1.25.56 1.25 1.25v1.25a1.25 1.25 0 1 1-2.5 0v-1.25c0-.69.56-1.25 1.25-1.25zm7.5 0c.69 0 1.25.56 1.25 1.25v1.25a1.25 1.25 0 1 1-2.5 0v-1.25c0-.69.56-1.25 1.25-1.25z"/></svg>');
		}
		.platform-filter-btn.active .youtube-logo {
			background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="red" d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/></svg>');
		}
		.platform-filter-btn.active .bilibili-logo {
			background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%2300a1d6" d="M18.223 3.086a1.25 1.25 0 0 1 0 1.768L17.08 5.996h1.17A3.75 3.75 0 0 1 22 9.746v7.5a3.75 3.75 0 0 1-3.75 3.75H5.75A3.75 3.75 0 0 1 2 17.246v-7.5a3.75 3.75 0 0 1 3.75-3.75h1.18L5.777 4.854a1.25 1.25 0 1 1 1.767-1.768l2.652 2.652c.079.079.145.165.198.257h3.213c.053-.092.12-.178.199-.257l2.651-2.652a1.25 1.25 0 0 1 1.768 0zm.027 5.42H5.75a1.25 1.25 0 0 0-1.25 1.25v7.5a1.25 1.25 0 0 0 1.25 1.25h12.5a1.25 1.25 0 0 0 1.25-1.25v-7.5a1.25 1.25 0 0 0-1.25-1.25zm-10 2.5c.69 0 1.25.56 1.25 1.25v1.25a1.25 1.25 0 1 1-2.5 0v-1.25c0-.69.56-1.25 1.25-1.25zm7.5 0c.69 0 1.25.56 1.25 1.25v1.25a1.25 1.25 0 1 1-2.5 0v-1.25c0-.69.56-1.25 1.25-1.25z"/></svg>');
		}
		.platform-filter-btn:not(.active) .youtube-logo {
			background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23666" d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/></svg>');
		}
				.platform-filter-btn:not(.active) .bilibili-logo {
			background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23666" d="M18.223 3.086a1.25 1.25 0 0 1 0 1.768L17.08 5.996h1.17A3.75 3.75 0 0 1 22 9.746v7.5a3.75 3.75 0 0 1-3.75 3.75H5.75A3.75 3.75 0 0 1 2 17.246v-7.5a3.75 3.75 0 0 1 3.75-3.75h1.18L5.777 4.854a1.25 1.25 0 1 1 1.767-1.768l2.652 2.652c.079.079.145.165.198.257h3.213c.053-.092.12-.178.199-.257l2.651-2.652a1.25 1.25 0 0 1 1.768 0zm.027 5.42H5.75a1.25 1.25 0 0 0-1.25 1.25v7.5a1.25 1.25 0 0 0 1.25 1.25h12.5a1.25 1.25 0 0 0 1.25-1.25v-7.5a1.25 1.25 0 0 0-1.25-1.25zm-10 2.5c.69 0 1.25.56 1.25 1.25v1.25a1.25 1.25 0 1 1-2.5 0v-1.25c0-.69.56-1.25 1.25-1.25zm7.5 0c.69 0 1.25.56 1.25 1.25v1.25a1.25 1.25 0 1 1-2.5 0v-1.25c0-.69.56-1.25 1.25-1.25z"/></svg>');
		}

        /* æ”¾å¤§åœ–è¡¨ */
        .chart-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            cursor: pointer;
        }
        .chart-modal-content {
			background: white;
			border-radius: 15px;
			padding: 30px;
			width: 90%;
			max-width: 1200px;
			max-height: 90%;
			overflow: auto;
			cursor: default;
		}
        .chart-modal-content h3 {
            text-align: center;
            margin-bottom: 20px;
            color: var(--primary);
        }
        .chart-modal-canvas {
            width: 100%;
            height: 500px;
        }

        /* æ’åå‹•ç•« */
        .ranking-animation-modal {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0,0,0,0.8);
			display: flex;
			justify-content: center;
			align-items: center;
			z-index: 1000;
			cursor: pointer; /* é¼ æ¨™ç§»åˆ°ä»‹é¢å¤–æ™‚è½‰ç‚ºæ‰‹æŒ‡ */
		}
		.ranking-animation-content {
			padding: 0px;
			width: 95%;
			max-width: 1400px;
			max-height: 100%;
			overflow: auto;
			cursor: default; /* å…§å®¹å€åŸŸä¿æŒé»˜èªé¼ æ¨™æ¨£å¼ */
		}
        .ranking-animation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .ranking-animation-canvas {
			width: 100%;
			background: #f8f9fa;
			border-radius: 10px;
			margin-bottom: 10px;
			position: relative;
		}
        .ranking-animation-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 0px;
        }
        .ranking-animation-info {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.2em;
            color: var(--primary);
        }
        .ranking-animation-sliders {
			display: flex;
			flex-direction: column;
			gap: 0px;
			margin: 0px 0;
			width: 100%;
			max-width: 800px;
			align-items: center; /* æ–°å¢ï¼šç½®ä¸­å°é½Š */
		}
        .slider-container {
			display: flex;
			align-items: center;
			gap: 15px;
			margin-bottom: 0px;
			width: 100%;
			justify-content: center; /* æ–°å¢ï¼šç½®ä¸­å°é½Š */
		}
        .slider-container label {
			min-width: 60px; /* å‡å°‘æ ‡ç­¾å®½åº¦ */
			font-weight: bold;
			font-size: 14px; /* å¯é€‰ï¼šå‡å°å­—ä½“å¤§å° */
		}
        .slider-container input[type="range"] {
			flex: 1; /* è®©æ»‘å—å æ®æ›´å¤šç©ºé—´ */
			min-width: 33%; /* è®¾ç½®æœ€å°å®½åº¦ */
		}
        .slider-value {
			min-width: 80px; /* è°ƒæ•´æ•°å€¼æ˜¾ç¤ºå®½åº¦ */
			text-align: right;
			font-size: 14px; /* å¯é€‰ï¼šå‡å°å­—ä½“å¤§å° */
		}
        .ranking-item-animation {
            position: absolute;
            transition: top 0.5s ease-in-out;
            width: 100%;
            display: flex;
            align-items: center;
        }

		/* å¹´åº¦çƒ­é—¨è¡¨æ ¼ */
		#annualHotTable {
			table-layout: fixed;
			width: 100%;
			min-width: 0; /* æ·»åŠ è¿™è¡Œé˜²æ­¢æœ€å°å®½åº¦å¯¼è‡´çš„æ»šåŠ¨ */
			border-collapse: collapse;
			margin-top: 15px;
		}
		
		#annualHotTable th {
			padding: 12px;
			text-align: left;
			background: linear-gradient(135deg, var(--primary), var(--secondary));
			color: white;
			font-weight: bold;
			position: sticky;
			top: 0;
		}

		#annualHotTable td {
			padding: 12px;
			border-bottom: 1px solid #e2e8f0;
		}
		
		#annualHotTable th, #annualHotTable td {
			padding: 12px;
			word-wrap: break-word;
			word-break: break-word;
			overflow: hidden;
			box-sizing: border-box; /* æ·»åŠ è¿™è¡Œç¡®ä¿paddingåŒ…å«åœ¨å®½åº¦å†… */
		}
		
		#annualHotTable th:nth-child(1), #annualHotTable td:nth-child(1) { width: 7%; }
		#annualHotTable th:nth-child(2), #annualHotTable td:nth-child(2) { width: 53%; }
		#annualHotTable th:nth-child(3), #annualHotTable td:nth-child(3) { width: 12%; }
		#annualHotTable th:nth-child(4), #annualHotTable td:nth-child(4) { width: 10%; }
		#annualHotTable th:nth-child(5), #annualHotTable td:nth-child(5) { width: 8%; }
		#annualHotTable th:nth-child(6), #annualHotTable td:nth-child(6) { width: 10%; }
		
		#annualHotTable tr {
			transition: all 0.3s;
			width: 100%;
			display: table-row; /* ç¡®ä¿è¡Œä¿æŒè¡¨æ ¼è¡Œå¸ƒå±€ */
		}

		#annualHotTable tr:nth-child(even) {
			background-color: #f8f9fa;
		}

		/* ä¿®æ”¹æ‚¬åœæ•ˆæœï¼Œç§»é™¤æ¨ªå‘ç§»åŠ¨é¿å…æº¢å‡º */
		#annualHotTable tr:hover {
			background-color: #edf2f7;
			/* ç§»é™¤transform: translateX(5px); é¿å…å¯¼è‡´æº¢å‡º */
			box-shadow: 0 4px 8px rgba(0,0,0,0.1);
		}
		
		/* ç¦æ­¢annualHotBodyçš„æ¨ªå‘æ»šåŠ¨æ¡ */
		#annualHotBody {
			overflow-x: hidden !important;
			width: 100%;
		}
		
		/* ç¡®ä¿å¼¹çª—å®¹å™¨ä¸ä¼šäº§ç”Ÿæ»šåŠ¨æ¡ */
		#annualHotModal {
			overflow: hidden !important;
		}
		
		/* å¹´åº¦çƒ­é—¨å¼¹çª—å†…å®¹åŒºåŸŸç¦æ­¢æ¨ªå‘æ»šåŠ¨ */
		#annualHotModal .chart-modal-content {
			overflow-x: hidden !important;
			overflow-y: auto !important;
			max-height: 80vh;
			width: 100%;
			max-width: 1000px;
			margin: 0 auto;
		}

		.score-increase {
			color: var(--success);
			font-weight: bold;
		}

		.score-decrease {
			color: var(--danger);
			font-weight: bold;
		}

		.score-no-change {
			color: var(--gray);
			font-weight: bold;
		}
		
		/* é«˜äº®åŠ¨ç”» */
		@keyframes highlightPulse {
			0% { 
				background-color: rgba(102, 126, 234, 0.1); 
				box-shadow: 0 0 0 0 rgba(102, 126, 234, 0.3);
			}
			50% { 
				background-color: rgba(102, 126, 234, 0.3); 
				box-shadow: 0 0 20px 10px rgba(102, 126, 234, 0.2);
			}
			100% { 
				background-color: rgba(102, 126, 234, 0.1); 
				box-shadow: 0 0 0 0 rgba(102, 126, 234, 0);
			}
		}
		
		.highlight-animation {
			animation: highlightPulse 3s ease-in-out;
		}
		
		/* æµ®å‹•æŒ‰éˆ•çš„æ¨£å¼ */
		.float-buttons {
			position: fixed;
			bottom: 20px;
			right: 20px;
			display: flex;
			flex-direction: column;
			gap: 10px;
			z-index: 1000;
		}
		
		.float-btn {
			width: 30px;
			height: 30px;
			border-radius: 50%;
			border: none;
			background: var(--primary);
			color: white;
			font-size: 1em;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			box-shadow: 0 4px 12px rgba(0,0,0,0.2);
			transition: all 0.3s;
		}
		
		.float-btn:hover {
			transform: translateY(-3px);
			box-shadow: 0 6px 16px rgba(0,0,0,0.3);
		}
		
		.float-btn.scroll-to-separator {
			background: var(--danger);
			font-size: 0.1em;
			font-weight: bold;
		}
		
		/* æ·»åŠ å“åº”å¼å¤„ç†ï¼Œç¡®ä¿åœ¨å°å±å¹•ä¸Šä¹Ÿèƒ½æ­£å¸¸æ˜¾ç¤º */
		@media (max-width: 768px) {
			.vote-slider-container {
				max-width: 95%;
				margin: 0px auto;
				width: calc(100% - 200px);
			}
			
			.vote-slider {
				width: 100%;
				max-width: 100%;
				height: 50px;
			}
			
			.vote-slider::-webkit-slider-thumb {
				width: 40px;
				height: 40px;
			}
			
			.lock-btn, .freeze-btn {
				width: 40px;
				height: 40px;
			}
			
			/* çµ±è¨ˆé çš„ä¸€èˆ¬é …ç›®çš„é«˜åº¦è¨­ç‚º2å€ï¼Œä¸¦åˆ†ç‚º3è¡Œ */
			.list-item.ranking-item {
				min-height: 100px !important;
				padding: 15px !important;
				height: auto !important;
			}
			
			.list-item.ranking-item .item-name {
				font-size: 1.1em !important;
				margin-bottom: 4px !important;
				display: block !important;
				width: 100% !important;
			}
			
			.list-item.ranking-item .mood-display {
				margin: 4px 0 !important;
				display: block !important;
				width: 100% !important;
				text-align: left !important;
			}
			
			.list-item.ranking-item > div > div:first-child {
				flex-direction: column !important;
				align-items: flex-start !important;
				height: auto !important;
			}
			
			.list-item.ranking-item > div > div:first-child > span:first-child {
				width: 100% !important;
				margin-bottom: 5px !important;
				font-size: 1.3em !important;
			}
			
			.list-item.ranking-item > div > div:first-child > div {
				margin-top: 8px !important;
				flex-direction: column !important;
				align-items: flex-start !important;
				width: 100% !important;
			}
			
			.list-item.ranking-item > div > div:first-child > div > span {
				margin-top: 5px !important;
				font-size: 0.95em !important;
				line-height: 1.4 !important;
			}
			
			/* ä¸é™åˆ¶ "gameSettings" å…§çš„å…ƒç´ åœ¨åŒä¸€è¡Œ */
			#gameSettings {
				flex-wrap: wrap !important;
				gap: 10px !important;
			}
			
			#annualHotModal .chart-modal-content {
				max-width: 95vw;
				padding: 15px;
			}
			
			#annualHotTable th, #annualHotTable td {
				padding: 8px;
				font-size: 14px;
			}
			
			#annualHotTable th:nth-child(1), #annualHotTable td:nth-child(1) { width: 7%; }
			#annualHotTable th:nth-child(2), #annualHotTable td:nth-child(2) { width: 53%; }
			#annualHotTable th:nth-child(3), #annualHotTable td:nth-child(3) { width: 12%; }
			#annualHotTable th:nth-child(4), #annualHotTable td:nth-child(4) { width: 10%; }
			#annualHotTable th:nth-child(5), #annualHotTable td:nth-child(5) { width: 8%; }
			#annualHotTable th:nth-child(6), #annualHotTable td:nth-child(6) { width: 10%; }
		}
    </style>
</head>
<body>
    <div class="container">
        <div class="header"><h1>ğŸ”¥ ç„¡é™å°æ±º ğŸ”¥</h1></div>
        <div class="nav-buttons">
            <button class="btn btn-nav" onclick="showPage('settings')">âš™ï¸è¨­å®š</button>
            <button class="btn btn-nav active" onclick="showPage('voting')">ğŸ—³ï¸æŠ•ç¥¨</button>
            <button class="btn btn-nav" onclick="showPage('stats')">ğŸ“Šçµ±è¨ˆ</button>
        </div>

        <div id="voting" class="page active">
            <div class="card">
                <div class="game-settings-row">
                    <div class="form-group">
                        <label for="gameSelect">é¸æ“‡éŠæˆ²ï¼š</label>
                        <select id="gameSelect" class="form-control" style="width: auto; display: inline-block;" onchange="updateGameSettings()">
                            <option value="">è«‹é¸æ“‡éŠæˆ²</option>
                        </select>
                    </div>
                    <div id="gameSettings" style="display: flex; gap: 20px; align-items: center;">
                        <div class="form-group">
                            <label for="extractMode">æŠ½å–æ¨¡å¼ï¼š</label>
                            <select id="extractMode" class="form-control" style="width: auto; display: inline-block;">
								<option value="quickConverge">å¿«é€Ÿæ”¶æ–‚</option>
								<option value="similarScore">åˆ†æ•¸ç›¸è¿‘</option>
								<option value="leastVolatility">æ³¢å‹•æœ€å°</option>
								<option value="highestTrend">å‡ç‡æœ€é«˜</option>
								<option value="lowestTrend">é™ç‡æœ€é«˜</option>
								<option value="uniform">å‡å‹»éš¨æ©Ÿ</option>
								<option value="strongest">åæ¬¡æœ€é«˜</option>
								<option value="middle">åæ¬¡ä¸­æ®µ</option>
								<option value="weakest">åæ¬¡æœ€ä½</option>
								<option value="highestWinRate">å‹ç‡æœ€é«˜</option>
								<option value="middleWinRate">å‹ç‡ä¸­æ®µ</option>
								<option value="lowestWinRate">å‹ç‡æœ€ä½</option>
								<option value="nearAverage">è¿‘å¹³å‡åˆ†</option>
								<option value="leastVoted">æœ€å°‘ç¥¨æ¬¡</option>
								<option value="maxError">æœ€å¤§èª¤å·®</option>
								<option value="newest">æœ€è¿‘åŠ å…¥</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <div class="voting-mood-filter-container">
                                <div style="display: flex; align-items: center; gap: 10px; justify-content: center;">
                                    <select id="votingMoodLogic" class="mood-logic-select" onchange="updateItemCountMax()">
                                        <option value="and">å’Œ</option>
                                        <option value="or">æˆ–</option>
                                        <option value="not">é</option>
                                    </select>
                                    <div class="voting-mood-filter-buttons" id="votingMoodFilter"></div>
                                </div>
                                <div class="voting-keyword-filter">
                                    <input type="text" id="keywordFilter" class="form-control" style="width: 300px; padding-right: 35px;" placeholder="ä»¥é—œéµå­—ç¯©é¸..." oninput="updateItemCountMax()" onkeydown="handleKeywordFilterKeydown(event)">
                                    <button type="button" class="clear-filter-btn" onclick="clearVotingFilters()">âŒ</button>
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="itemCount">åƒè³½é …ç›®æ•¸ï¼š</label>
                            <input type="number" id="itemCount" min="4" value="0" class="form-control" style="width: 120px; display: inline-block;">
                            <button class="btn btn-danger" onclick="setMaxItems()" style="margin-left: 5px;">å…¨éƒ¨</button>
                        </div>
                        <div class="form-group">
                            <label>&nbsp;</label>
                            <button class="btn btn-primary" onclick="startGame()">é–‹å§‹</button>
                        </div>
                    </div>
                </div>

                <div id="votingArea" class="hidden">
                    <div class="vs-container">
                        <div class="option-card" id="option1Card" onmouseenter="handleVideoHover(1)">
                            <div class="option-title" id="option1Title">é¸é … 1</div>
                            <div class="video-container" id="video1Container"></div>
                            <div class="mood-buttons" id="mood1Buttons"></div>
                            <div class="item-stats hidden" id="stats1"></div>
                            <div class="score-change" id="scoreChange1"></div>
                        </div>
                        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 0px;">
							<button class="btn btn-info" onclick="reloadBothVideos()" title="é‡æ–°è¼‰å…¥å½±ç‰‡"><span>ğŸ”„</span></button>
							<div class="platform-filter-buttons" style="display: flex; justify-content: center; width: 100%;">
								<button id="youtubeFilterBtn" class="platform-filter-btn" title="ç¦ç”¨YouTubeé€£çµ" onclick="togglePlatformFilter('youtube')">
									<div class="youtube-logo"></div>
								</button>
								<button id="bilibiliFilterBtn" class="platform-filter-btn" title="ç¦ç”¨Bilibilié€£çµ" onclick="togglePlatformFilter('bilibili')">
									<div class="bilibili-logo"></div>
								</button>
							</div>
							<div class="vs-text">VS</div>
							<div id="gameStatusInfo" style="text-align: center; margin-top: 10px; margin-bottom: 10px; font-size: 0.9em; color: white; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 10px; display: none;">
								<div><span id="currentPlayingGame"></span></div>
								<div><span id="currentExtractMode">(?)</span> æ¨¡å¼</div>
								<div>æŠ½é¸æ±  <span id="currentPoolSize">0</span> é …</div>
								<div>å·²æŠ• <span id="currentVoteCount">0</span> æ¬¡</div>
							</div>
							<button id="toggleStatsButton" class="btn btn-info" onclick="toggleStats()" title="é¡¯ç¤º/éš±è—é …ç›®è³‡è¨Š">ğŸ‘ï¸</button>
						</div>
                        <div class="option-card" id="option2Card" onmouseenter="handleVideoHover(2)">
                            <div class="option-title" id="option2Title">é¸é … 2</div>
                            <div class="video-container" id="video2Container"></div>
                            <div class="mood-buttons" id="mood2Buttons"></div>
                            <div class="item-stats hidden" id="stats2"></div>
                            <div class="score-change" id="scoreChange2"></div>
                        </div>
                    </div>

					<div class="vote-controls-container" style="display: flex; align-items: center; justify-content: center; max-width: 700px; margin: 30px auto; position: relative;">
						<div class="lock-btn-container" style="margin-right: 60px;">
							<div style="display: flex; flex-direction: row; gap: 10px;">
								<button class="freeze-btn" id="freezeBtnLeft" title="å‡çµå·¦é¢çš„é …ç›®" onclick="toggleFreeze('left')">â„ï¸</button>
								<button class="lock-btn" id="lockBtnLeft" title="é–å®šå·¦é¢çš„é …ç›®" onclick="toggleLock('left')">ğŸ”’</button>
							</div>
						</div>
						
						<div class="vote-slider-container">
							<div id="sliderScoreChangeLeft" class="slider-score-change"></div>
							<div id="sliderScoreChangeRight" class="slider-score-change"></div>
							<input type="range" class="vote-slider" id="voteSlider" min="0" max="100" value="50" title="æ»‘å‹•é€²è¡ŒæŠ•ç¥¨">
						</div>
						
						<div class="lock-btn-container" style="margin-left: 60px;">
							<div style="display: flex; flex-direction: row; gap: 10px;">
								<button class="lock-btn" id="lockBtnRight" title="é–å®šå³é¢çš„é …ç›®" onclick="toggleLock('right')">ğŸ”’</button>
								<button class="freeze-btn" id="freezeBtnRight" title="å‡çµå³é¢çš„é …ç›®" onclick="toggleFreeze('right')">â„ï¸</button>
							</div>
						</div>
					</div>
					
                    <div class="flex-center">
                        <button class="btn btn-primary" onclick="voteExtreme(0)" title="æœ€å¤§ç¨‹åº¦æ”¯æŒå·¦é …">æœ€å·¦</button>
                        <button class="btn btn-gray" onclick="submitTie()" title="æ‰“å€‹å¹³æ‰‹">å¹³æ‰‹</button>
                        <button class="btn btn-danger" onclick="voteExtreme(100)" title="æœ€å¤§ç¨‹åº¦æ”¯æŒå³é …">æœ€å³</button>
                    </div>
                    <div class="flex-center">
                        <button class="btn btn-warning" id="undoBtn" onclick="undoVote()" title="å¾©åŸåˆ°ä¸Šä¸€æ¬¡çš„æŠ•ç¥¨" disabled>å¾©åŸ</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="settings" class="page">
            <div class="card">
                <h2>éŠæˆ²ç®¡ç†</h2>
                <div class="form-row">
                    <div class="form-group">
                        <label for="gameName">éŠæˆ²åç¨±</label>
                        <input type="text" id="gameName" class="form-control" placeholder="ä¾‹å¦‚ï¼šæœ€æ„›æ­Œæ›²å°æ±º">
                    </div>
                    <button class="btn btn-primary" onclick="createGame()">å‰µå»ºéŠæˆ²</button>
                </div>

                <div class="flex-center">
                    <button class="btn btn-info" onclick="exportSettings()">åŒ¯å‡ºè¨­å®š</button>
                    <button class="btn btn-warning" onclick="document.getElementById('importFile').click()">åŒ¯å…¥è¨­å®š</button>
                    <input type="file" id="importFile" accept=".json" onchange="importSettings(event)" class="hidden">
                </div>

                <div id="gamesList"><h3>ç¾æœ‰éŠæˆ²</h3></div>

                <div id="itemsManagement" class="hidden" style="margin-top: 30px; padding-top: 30px; border-top: 2px solid #e2e8f0;">
                    <div class="items-management-header">
                        <h2>é …ç›®ç®¡ç†</h2>
                        <button class="btn btn-gray" onclick="toggleItemsManagement()">æ”¶èµ·é …ç›®ç®¡ç†</button>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="itemsInput">æ‰¹æ¬¡æ–°å¢é …ç›®</label>
                            <textarea id="itemsInput" class="form-control" style="min-height: 150px;" placeholder="æ¯è¡Œè¼¸å…¥ä¸€å€‹é …ç›®ï¼Œæ ¼å¼ï¼šé …ç›®åç¨±,å½±ç‰‡é€£çµ"></textarea>
                        </div>
                        <button class="btn btn-primary" onclick="addItems()">æ‰¹æ¬¡æ–°å¢</button>
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; margin: 20px 0;">
                        <h3 id="itemsListTitle">é …ç›®åˆ—è¡¨</h3>
                        <div class="filter-controls">
                            <button class="toggle-btn clear-invalid-btn" onclick="clearAllInvalidLinks()" style="padding: 8px 16px;">æ¸…é™¤æ‰€æœ‰ç„¡æ•ˆé€£çµ</button>
                            <button class="toggle-btn" id="showInvalidOnlyBtn" onclick="toggleInvalidFilter()">ç„¡æ•ˆé€£çµ</button>
                            <button class="toggle-btn-frozen" id="showFrozenOnlyBtn" onclick="toggleFrozenFilter()">å‡çµé …ç›®</button>
                            <div class="mood-filter-container" id="settingsMoodFilter">
								<select id="settingsMoodLogic" class="mood-logic-select">
									<option value="and">å’Œ</option>
									<option value="or">æˆ–</option>
									<option value="not">é</option>
								</select>
								<div class="mood-filter-buttons" id="settingsMoodButtons"></div>
							</div>
                            <div class="voting-keyword-filter">
                                <input type="text" id="itemFilter" placeholder="éæ¿¾é …ç›®..." class="form-control" style="width: 200px; padding-right: 35px;">
                                <button type="button" class="clear-filter-btn" onclick="clearSettingsFilters()">âŒ</button>
                            </div>
                            <select id="pageSize">
                                <option value="10" selected>10</option>
                                <option value="50">50</option>
                                <option value="100">100</option>
                            </select>
                        </div>
                    </div>
                    <div class="pagination" id="paginationTop"></div>
                    <div id="itemsList"></div>
                    <div class="pagination" id="paginationBottom"></div>
                </div>
            </div>
        </div>

        <div id="stats" class="page">
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2>æŠ•ç¥¨çµ±è¨ˆ</h2>
                    <button class="btn btn-primary" onclick="refreshStats()">ğŸ”„ é‡æ–°æ•´ç†</button>
                </div>
                
                <div class="flex-center" style="text-align: center; margin-bottom: 20px;">
					<button class="btn btn-primary" onclick="showAnnualHot()">å¹´åº¦ç†±é–€</button>
                    <label for="statsGameSelect" style="display: flex; align-items: center;">é¸æ“‡éŠæˆ²ï¼š</label>
                    <select id="statsGameSelect" class="form-control" style="width: auto; display: inline-block;">
                        <option value="">è«‹é¸æ“‡éŠæˆ²</option>
                    </select>
					<button class="btn btn-info" onclick="exportStats()">åŒ¯å‡ºçµ±è¨ˆ</button>
                    <button class="btn btn-warning" onclick="document.getElementById('importStatsFile').click()">åŒ¯å…¥çµ±è¨ˆ</button>
					<button class="btn btn-danger" onclick="clearStats()">æ¸…é™¤æ•¸æ“š</button>
                    <input type="file" id="importStatsFile" accept=".json" class="hidden">
                </div>
				
				<!-- å¹´åº¦çƒ­é—¨å¼¹çª— -->
				<div id="annualHotModal" class="chart-modal hidden">
					<div class="chart-modal-content" style="max-width: 1000px; max-height: 80vh;">
						<h3 style="margin: 0px 0; text-align: center;">å¹´åº¦ç†±é–€é …ç›®</h3>
						<div style="margin: 0px 0; text-align: center;">
							<small>çµ±è¨ˆæ‰€æœ‰éŠæˆ²ä¸­ï¼Œæœ€è¿‘366æ—¥å…§æŠ•ç¥¨æ¬¡æ•¸æœ€å¤šçš„é …ç›®ã€‚</small>
						</div>
						<div style="overflow-x: auto;">
							<table id="annualHotTable" style="width: 100%; border-collapse: collapse; margin-top: 15px;">
								<thead>
									<tr style="background: linear-gradient(135deg, var(--primary), var(--secondary)); color: white;">
										<th style="padding: 12px; text-align: left; border-radius: 5px 0 0 0;">æ’å</th>
										<th style="padding: 12px; text-align: left;">é …ç›®åç¨±</th>
										<th style="padding: 12px; text-align: left;">æ‰€å±¬éŠæˆ²</th>
										<th style="padding: 12px; text-align: left;">åˆ†æ•¸è®Šå‹•</th>
										<th style="padding: 12px; text-align: left;">ç¥¨æ¬¡</th>
										<th style="padding: 12px; text-align: left; border-radius: 0 5px 0 0;">ç›®å‰åˆ†æ•¸</th>
									</tr>
								</thead>
								<tbody id="annualHotBody">
									<!-- åŠ¨æ€ç”Ÿæˆæ•°æ® -->
								</tbody>
							</table>
						</div>
						<div style="margin-top: 20px; text-align: center;">
							<button class="btn btn-primary" onclick="closeAnnualHotModal()">é—œé–‰</button>
						</div>
					</div>
				</div>

                <div id="statsContent" class="hidden">
                    <div class="grid">
						<div class="stat-card" onclick="toggleScoreDistributionChart(true)">
							<div class="distribution-chart-container">
								<canvas id="scoreDistributionChart" class="distribution-chart"></canvas>
							</div>
							<div>åˆ†æ•¸åˆ†å¸ƒ</div>
						</div>
						<div class="stat-card" onclick="playRankingAnimation()">
                            <div class="stat-value">ğŸ¬</div>
                            <div>æ’­æ”¾æ­·å²æ’ä½å‹•ç•«</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="totalItems">0</div>
                            <div>ç¸½é …ç›®æ•¸</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="totalVotes">0</div>
                            <div>ç¸½æŠ•ç¥¨æ•¸</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="expectedVotes">0</div>
                            <div>æœŸæœ›ç¥¨æ•¸</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="avgError">0</div>
                            <div>èª¤å·®çš„å¹³å‡å€¼</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="avgScore">1500</div>
                            <div>åˆ†æ•¸çš„å¹³å‡å€¼</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="medianScore">1500</div>
                            <div>åˆ†æ•¸çš„ä¸­ä½æ•¸</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="maxScore">1500</div>
                            <div>åˆ†æ•¸çš„æœ€å¤§å€¼</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="minScore">1500</div>
                            <div>åˆ†æ•¸çš„æœ€å°å€¼</div>
                        </div>
						<div class="stat-card">
							<div class="stat-value" id="stdDevScore">0</div>
							<div>åˆ†æ•¸çš„æ¨™æº–å·®</div>
						</div>
						<div class="stat-card" id="lastVoteDateCard">
							<div class="stat-value" id="lastVoteDate" style="font-size: 1.5em; margin-bottom: 5px;">?</div>
							<div class="stat-value" id="lastVoteDate2" style="font-size: 1em; margin-bottom: 5px;">?</div>
							<div>æœ€å¾ŒæŠ•ç¥¨æ—¥æœŸ</div>
						</div>
                    </div>

                    <div style="margin-top: 30px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 id="rankingTitle">æ’è¡Œæ¦œ</h3>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <div class="chart-controls">
									<button class="btn btn-info" onclick="statsHelp()" style="padding: 10px 15px; border-radius: 10px;">èªªæ˜</button>
                                    <button class="btn btn-info" onclick="collapseAllCharts()" style="padding: 10px 15px; border-radius: 10px;">æ”¶èµ·åœ–</button>
                                </div>
                                <div class="mood-filter-container" id="statsMoodFilter">
									<select id="statsMoodLogic" class="mood-logic-select">
										<option value="and">å’Œ</option>
										<option value="or">æˆ–</option>
										<option value="not">é</option>
									</select>
									<div class="mood-filter-buttons" id="statsMoodButtons"></div>
								</div>
                                <div class="voting-keyword-filter">
                                    <input type="text" id="rankingSearch" placeholder="æœå°‹é …ç›®..." class="form-control" style="width: 200px; padding-right: 35px;">
                                    <button type="button" class="clear-filter-btn" onclick="clearStatsFilters()">âŒ</button>
                                </div>
                                <select id="sortBy" class="form-control" style="width: 95px">
                                    <option value="rank">ä¾åæ¬¡</option>
                                    <option value="score">ä¾åˆ†æ•¸</option>
									<option value="error">ä¾èª¤å·®</option>
                                    <option value="winRate">ä¾å‹ç‡</option>
									<option value="volatility">ä¾æ³¢å‹•</option>
									<option value="trend">ä¾è¶¨å‹¢</option>
                                    <option value="votes">ä¾ç¥¨æ¬¡</option>
                                    <option value="time">ä¾æ–°åŠ </option>
                                </select>
                            </div>
                        </div>
                        <div id="rankingList"></div>
                    </div>
                </div>
            </div>
			<!-- æµ®å‹•æŒ‰éˆ•å®¹å™¨ -->
			<div class="float-buttons" id="floatButtons" style="display: none;">
				<button class="float-btn" onclick="scrollToTop()" title="æ»¾å‹•åˆ°é é ‚">â†‘</button>
				<!-- åˆ†éš”ç·šæŒ‰éˆ•å°‡ç”±JavaScriptå‹•æ…‹ç”Ÿæˆ -->
			</div>
        </div>
    </div>
	<center>
		ver 0.3&emsp;~tyovery~&emsp;2025-12<br />
		ver 0.2&emsp;~tyovery~&emsp;2025-11<br />
		ver 0.1&emsp;~tyovery~&emsp;2025-10<br /><br />
	</center>

    <!-- æ–°å¢ï¼šæ”¾å¤§åœ–è¡¨çš„æ¨¡æ…‹æ¡† -->
    <div id="scoreDistributionModal" class="chart-modal hidden">
        <div class="chart-modal-content">
            <canvas id="scoreDistributionChartLarge" class="chart-modal-canvas"></canvas>
        </div>
    </div>

    <div id="rankingAnimationModal" class="ranking-animation-modal hidden">
		<div class="ranking-animation-content">
			<canvas id="rankingAnimationCanvas" class="ranking-animation-canvas"></canvas>
			<div class="ranking-animation-controls">
				<button class="btn btn-warning" id="firstFrameBtn" onclick="firstRankingFrame()">é¦–æ ¼</button>
				<button class="btn btn-info" id="prevBtn" onclick="prevRankingFrame()">ä¸Šä¸€æ ¼</button>
				<button class="btn btn-primary" id="playPauseBtn" onclick="toggleRankingAnimation()">æ’­æ”¾</button>
				<button class="btn btn-info" id="nextBtn" onclick="nextRankingFrame()">ä¸‹ä¸€æ ¼</button>
				<button class="btn btn-warning" id="lastFrameBtn" onclick="lastRankingFrame()">å°¾æ ¼</button>
			</div>
			<div class="ranking-animation-sliders">
				<div class="slider-container">
					<label for="itemCountSlider">é …ç›®æ•¸ï¼š<span class="slider-value" id="itemCountValue">30</span></label>
					<input type="range" id="itemCountSlider" min="10" max="50" value="30" class="form-control">
					<label for="frameSlider">é€²åº¦ï¼š<span class="slider-value" id="frameValue">0/0</span></label>
					<input type="range" id="frameSlider" min="0" max="100" value="0" class="form-control">
					<label for="speedSlider">é€Ÿåº¦ï¼š<span class="slider-value" id="speedValue">1 ç•«æ ¼/ç§’</span></label>
					<input type="range" id="speedSlider" min="1" max="30" value="1" class="form-control">
				</div>
			</div>
		</div>
	</div>
	
	<div id="contextMenu" class="context-menu" style="display: none; position: absolute; background: white; border: 1px solid #ccc; border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1000;">
		<ul id="contextMenuList" style="list-style: none; margin: 0; padding: 5px 10px;">
			<!-- åŠ¨æ€ç”Ÿæˆèœå•é¡¹ -->
		</ul>
	</div>

    <script src="https://www.youtube.com/iframe_api"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        let games = JSON.parse(localStorage.getItem('games')) || {};
        let currentGame = null, currentPair = null, selectedGameForEdit = null;
        let activeItems = [], voteHistory = [], editingItemId = null, renamingGameId = null;
        let player1 = null, player2 = null, youtubeReady = false, currentPlayingPlayer = null;
        let selectedGameId = localStorage.getItem('selectedGameId') || '';
        let selectedItemCount = parseInt(localStorage.getItem('selectedItemCount')) || 0;
        let selectedExtractMode = localStorage.getItem('selectedExtractMode') || 'quickConverge';
		let currentGameExtractMode = '';
        let currentPage = 1, itemsPerPage = 10, statsVisible = localStorage.getItem('statsVisible') === 'true', filteredItems = [];
        let currentVideoLinks = [null, null], visibleItemObserver = null;
        let showInvalidOnly = false;
        let showFrozenOnly = false;
        let cooldownActive = false;
        let uniformPool = [];
        let isLeftMouseDownOnSlider = false;
        let isEditing = false;
        const moodEmojis = ['ğŸŒ', 'ğŸ”¥', 'ğŸ’—', 'ğŸŒ±', 'ğŸ“', 'ğŸ˜­', 'ğŸ•Šï¸'];
        
        let selectedMoodFilters = JSON.parse(localStorage.getItem('selectedMoodFilters')) || [];
        let statsMoodFilters = JSON.parse(localStorage.getItem('statsMoodFilters')) || [];
        let settingsMoodFilters = JSON.parse(localStorage.getItem('settingsMoodFilters')) || [];
        
        let votingMoodLogic = localStorage.getItem('votingMoodLogic') || 'and';
        let settingsMoodLogic = localStorage.getItem('settingsMoodLogic') || 'and';
        let statsMoodLogic = localStorage.getItem('statsMoodLogic') || 'and';

        let editingItemData = {};

        let startGameExecuting = false;

        let scoreAnimationActive = false;

        let expandedItemIds = JSON.parse(localStorage.getItem('expandedItemIds')) || [];

        let lockedLeft = false;
        let lockedRight = false;
        let frozenLeft = false;
        let frozenRight = false;

        // åˆ†æ•¸åˆ†å¸ƒåœ–å¯¦ä¾‹
        let scoreDistributionChart = null;
        let scoreDistributionChartLarge = null;
        
        // å¹³å°ç¯©é¸ç‹€æ…‹
		let platformFilters = JSON.parse(localStorage.getItem('platformFilters')) || { youtube: true, bilibili: true };

        // æ’åå‹•ç•«ç›¸é—œè®Šé‡
        let rankingAnimationData = [];
        let currentRankingFrame = 0;
        let rankingAnimationInterval = null;
        let rankingAnimationSpeed = 1000; // æ¯«ç§’
        let rankingAnimationCanvas = null;
        let rankingAnimationCtx = null;
		let rankingItemCount = 30; // é è¨­é¡¯ç¤º15é …
		let RANKING_ITEM_HEIGHT = 20; // æ’­æ”¾æ­·å²æ’ä½å‹•ç•« ä¸€å€‹é …ç›®çš„é«˜åº¦ (10~30)
		const RANKING_START_Y = 80;
		
		let animationManager = {
			isAnimating: false,
			animationQueue: [],
			currentAnimation: null,
			
			// æ·»åŠ åŠ¨ç”»åˆ°é˜Ÿåˆ—
			addToQueue: function(callback) {
				this.animationQueue.push(callback);
				this.processQueue();
			},
			
			// å¤„ç†åŠ¨ç”»é˜Ÿåˆ—
			processQueue: function() {
				if (this.isAnimating || this.animationQueue.length === 0) return;
				
				this.isAnimating = true;
				const nextAnimation = this.animationQueue.shift();
				this.currentAnimation = nextAnimation;
				
				// æ‰§è¡ŒåŠ¨ç”»å¹¶ç­‰å¾…å®Œæˆ
				nextAnimation(() => {
					this.isAnimating = false;
					setTimeout(() => this.processQueue(), 50); // ç»™ä¸€ç‚¹å»¶è¿Ÿè®©æµè§ˆå™¨æ¸²æŸ“
				});
			},
			
			// æ¸…ç©ºé˜Ÿåˆ—
			clearQueue: function() {
				this.animationQueue = [];
				this.isAnimating = false;
				this.currentAnimation = null;
			},
			
			// æ£€æŸ¥æ˜¯å¦æœ‰åŠ¨ç”»åœ¨è¿›è¡Œ
			isBusy: function() {
				return this.isAnimating;
			}
		};

        function calculateError(item) {
			const n = item.votes ;
			const p = calculateWinRate(item) ;
			if (n == 0 || p == 0 || p == 1 ) return Infinity ;
			return 340.48687381214944 / Math.sqrt( n*p*(1-p) ) ;
        }

        function calculateWinRate(item) {
            const N = item.votes;
            const W = item.wins ?? 0;
            const L = item.losses ?? 0;
            if (N == 0) return 0.5;
            return (N + W - L) / (2 * N);
        }
		
		// è¨ˆç®—æœˆåº¦æ³¢å‹•çš„å‡½æ•¸
		function calculateRecentVolatility(item) {
			if (!item.scoreHistory || item.scoreHistory.length === 0) {
				return 0;
			}
			
			const now = Date.now();
			const thirtyDaysAgo = now - (30 * 24 * 60 * 60 * 1000);
			
			// éæ¿¾æœ€è¿‘30å¤©çš„åˆ†æ•¸è¨˜éŒ„
			const recentScores = item.scoreHistory
				.filter(record => record.timestamp >= thirtyDaysAgo)
				.map(record => record.score);
			
			if (recentScores.length === 0) {
				return 0;
			}
			
			const maxScore = Math.max(...recentScores);
			const minScore = Math.min(...recentScores);
			
			return maxScore - minScore;
		}
		
		// ç²å–æœˆåº¦æ³¢å‹•é¡¯ç¤ºç¬¦è™Ÿçš„å‡½æ•¸
		function getRecentVolatilitySymbol(item) {
			if (!item.scoreHistory || item.scoreHistory.length < 3) {
				return "?";
			}
			
			const now = Date.now();
			const thirtyDaysAgo = now - (30 * 24 * 60 * 60 * 1000);
			
			// éæ¿¾æœ€è¿‘30å¤©çš„åˆ†æ•¸è¨˜éŒ„
			const recentScores = item.scoreHistory
				.filter(record => record.timestamp >= thirtyDaysAgo)
				.map(record => record.score);
			
			if (recentScores.length < 3) {
				return "?";
			}
			
			const volatility = calculateRecentVolatility(item);
			if (volatility === 0) {
				return "â‰ˆ";
			}
			
			// ç²å–æœ€åˆå’Œæœ€å¾Œåˆ†æ•¸
			const firstScore = recentScores[0];
			const lastScore = recentScores[recentScores.length - 1];
			const scoreDiff = lastScore - firstScore;
			const absScoreDiff = Math.abs(scoreDiff);
			
			// å¦‚æœåˆ†æ•¸è®ŠåŒ–é”åˆ°æ³¢å‹•å€¼çš„50%
			if (absScoreDiff >= volatility * 0.95) {
				return scoreDiff > 0 ? "â†‘" : "â†“";
			} else {
				return "â‰ˆ";
			}
		}

        function migrateOldData() {
            Object.values(games).forEach(game => {
                game.items.forEach(item => {
                    if (typeof item.link === 'string') {
                        item.links = [item.link];
                        delete item.link;
                    } else if (!item.links) item.links = [];
                    if (!item.invalidLinks) item.invalidLinks = [];
                    ['wins', 'losses'].forEach(prop => { if (item[prop] === undefined) item[prop] = 0; });
                    if (!item.moods) item.moods = [];
                    if (!item.scoreHistory) item.scoreHistory = [];
                    if (item.frozen === undefined) item.frozen = false;
                });
            });
            localStorage.setItem('games', JSON.stringify(games));
        }

        function onYouTubeIframeAPIReady() { youtubeReady = true; }

        function handleVideoHover(optionNum) {
            currentPlayingPlayer = optionNum;
            try {
                if (optionNum === 1) {
                    if (player1?.unMute) { player1.unMute(); player1.playVideo(); }
                    if (player2?.mute) { player2.mute(); player2.pauseVideo(); }
                } else {
                    if (player2?.unMute) { player2.unMute(); player2.playVideo(); }
                    if (player1?.mute) { player1.mute(); player1.pauseVideo(); }
                }
            } catch (e) { console.log('Video control not available'); }
        }

        function toggleInvalidLink(optionNum) {
            if (!currentPair) return;
            const item = currentGame.items.find(i => i.id === currentPair[optionNum - 1].id);
            const currentLink = currentVideoLinks[optionNum - 1];
            if (!item || !currentLink) return;
            
            if (!item.invalidLinks) item.invalidLinks = [];
            const btn = document.querySelector(`#video${optionNum}Container .invalid-btn`);
            
            if (item.invalidLinks.includes(currentLink)) {
                item.invalidLinks = item.invalidLinks.filter(link => link !== currentLink);
                btn.classList.remove('active');
            } else {
                item.invalidLinks.push(currentLink);
                btn.classList.add('active');
            }
            localStorage.setItem('games', JSON.stringify(games));
            syncData();
        }

        function toggleLock(side) {
            if (side === 'left') {
                if (lockedLeft) {
                    lockedLeft = false;
                    document.getElementById('lockBtnLeft').classList.remove('active');
                } else {
                    lockedLeft = true;
                    lockedRight = false;
                    document.getElementById('lockBtnLeft').classList.add('active');
                    document.getElementById('lockBtnRight').classList.remove('active');
                }
            } else {
                if (lockedRight) {
                    lockedRight = false;
                    document.getElementById('lockBtnRight').classList.remove('active');
                } else {
                    lockedRight = true;
                    lockedLeft = false;
                    document.getElementById('lockBtnRight').classList.add('active');
                    document.getElementById('lockBtnLeft').classList.remove('active');
                }
            }
        }

        function toggleFreeze(side) {
            if (!currentPair) return;
            
            const item = currentGame.items.find(i => i.id === currentPair[side === 'left' ? 0 : 1].id);
            if (!item) return;
            
            if (side === 'left') {
                if (frozenLeft) {
                    frozenLeft = false;
                    document.getElementById('freezeBtnLeft').classList.remove('active');
                    item.frozen = false;
                } else {
                    frozenLeft = true;
                    document.getElementById('freezeBtnLeft').classList.add('active');
                    item.frozen = true;
                }
            } else {
                if (frozenRight) {
                    frozenRight = false;
                    document.getElementById('freezeBtnRight').classList.remove('active');
                    item.frozen = false;
                } else {
                    frozenRight = true;
                    document.getElementById('freezeBtnRight').classList.add('active');
                    item.frozen = true;
                }
            }
            
            localStorage.setItem('games', JSON.stringify(games));
            syncData();
        }
        
        // æ–°å¢å¹³å°ç¯©é¸åŠŸèƒ½
        function togglePlatformFilter(platform) {
			platformFilters[platform] = !platformFilters[platform];
			localStorage.setItem('platformFilters', JSON.stringify(platformFilters));
			
			// æ›´æ–°æŒ‰é’®æ ·å¼
			updatePlatformFilterButtons();
			
			// ç«‹å³é‡æ–°åŠ è½½å½“å‰å½±ç‰‡ä»¥åº”ç”¨ç­›é€‰
			/*
			if (currentPair) {
				reloadBothVideos();
			}*/
		}
		
		function updatePlatformFilterButtons() {
			const youtubeBtn = document.getElementById('youtubeFilterBtn');
			const bilibiliBtn = document.getElementById('bilibiliFilterBtn');
			
			if (youtubeBtn) {
				if (platformFilters.youtube) {
					youtubeBtn.classList.add('active');
				} else {
					youtubeBtn.classList.remove('active');
				}
			}
			
			if (bilibiliBtn) {
				if (platformFilters.bilibili) {
					bilibiliBtn.classList.add('active');
				} else {
					bilibiliBtn.classList.remove('active');
				}
			}
		}
        
        // ä¿®æ”¹getRandomValidLinkå‡½æ•¸ä»¥æ”¯æŒå¹³å°ç¯©é¸
        function getRandomValidLink(item) {
			if (!item?.links?.length) return null;
			
			// å…ˆè·å–æ‰€æœ‰æœ‰æ•ˆé“¾æ¥ï¼ˆæ’é™¤æ— æ•ˆé“¾æ¥ï¼‰
			let validLinks = item.links.filter(link => !item.invalidLinks?.includes(link));
			
			if (validLinks.length === 0) {
				validLinks = [...item.links];
			}
			
			// æ ¹æ®å¹³å°ç­›é€‰æ¡ä»¶è¿‡æ»¤é“¾æ¥
			let filteredLinks = validLinks.filter(link => {
				const isYoutube = link.includes('youtube.com') || link.includes('youtu.be');
				const isBilibili = link.includes('bilibili.com');
				
				// åªæœ‰å½“å¹³å°ç­›é€‰å¼€å¯æ—¶æ‰åŒ…å«å¯¹åº”å¹³å°çš„é“¾æ¥
				if (isYoutube && !platformFilters.youtube) return false;
				if (isBilibili && !platformFilters.bilibili) return false;
				
				// å¦‚æœé“¾æ¥ä¸æ˜¯YouTubeä¹Ÿä¸æ˜¯Bilibiliï¼Œåˆ™ä¿ç•™ï¼ˆå…è®¸å…¶ä»–å¹³å°ï¼‰
				return true;
			});
			
			// å¦‚æœç­›é€‰åæ²¡æœ‰é“¾æ¥ï¼Œè¿”å›null
			if (filteredLinks.length === 0) {
				return null;
			}
			
			// å¦‚æœæœ‰å½“å‰é“¾æ¥ä¸”åœ¨å½“å‰å¯ç”¨é“¾æ¥ä¸­ï¼Œä¼˜å…ˆæ’é™¤å½“å‰é“¾æ¥
			let availableLinks = [...filteredLinks];
			const currentLink1 = currentVideoLinks[0];
			const currentLink2 = currentVideoLinks[1];
			
			if (availableLinks.length > 1) {
				if (currentLink1 && availableLinks.includes(currentLink1)) {
					availableLinks = availableLinks.filter(link => link !== currentLink1);
				}
				if (currentLink2 && availableLinks.includes(currentLink2)) {
					availableLinks = availableLinks.filter(link => link !== currentLink2);
				}
			}
			
			// å¦‚æœæ’é™¤å½“å‰é“¾æ¥åè¿˜æœ‰å¯é€‰é“¾æ¥ï¼Œä»å…¶ä¸­éšæœºé€‰æ‹©
			if (availableLinks.length > 0) {
				return availableLinks[Math.floor(Math.random() * availableLinks.length)];
			}
			
			// å¦åˆ™ä»æ‰€æœ‰ç­›é€‰åçš„é“¾æ¥ä¸­éšæœºé€‰æ‹©
			return filteredLinks[Math.floor(Math.random() * filteredLinks.length)];
		}

        function toggleStats() {
			statsVisible = !statsVisible;
			localStorage.setItem('statsVisible', statsVisible);
			const btn = document.getElementById('toggleStatsButton');
			const stats1 = document.getElementById('stats1');
			const stats2 = document.getElementById('stats2');
			
			if (statsVisible) {
				btn.textContent = 'ğŸ‘ï¸';
				btn.classList.add('active');
				updateItemStats();
				stats1.classList.remove('hidden');
				stats2.classList.remove('hidden');
			} else {
				btn.textContent = 'ğŸ‘ï¸';
				btn.classList.remove('active');
				stats1.classList.add('hidden');
				stats2.classList.add('hidden');
			}
		}

        function sortItemsByRank(items) {
			return [...items].sort((a, b) => {
				// å…ˆæŒ‰åˆ†æ•¸é™åºæ’åˆ— (å–æ•´æ•¸, å› åˆ†æ•¸å·®åˆ¥å°æ™‚, å¯¦éš›åˆ†åˆ¥ä¸å¤§)
				const scoreA = Math.round(a.score) ;
				const scoreB = Math.round(b.score) ;
				if (scoreB !== scoreA) return scoreB - scoreA;
				
				// åˆ†æ•¸ç›¸åŒæ™‚ï¼ŒæŒ‰èª¤å·®å‡åºæ’åˆ— (å–æ•´æ•¸, å› èª¤å·®å·®åˆ¥å°æ™‚, å¯¦éš›åˆ†åˆ¥ä¸å¤§)
				const errorA = Math.round( a.error ?? calculateError(a) ) ;
				const errorB = Math.round( b.error ?? calculateError(b) ) ;
				
				// è™•ç†ç‰¹æ®Šå€¼ï¼šInfinity, undefined, null çš„å„ªå…ˆåº¦æœ€ä½
				if (errorA === Infinity && errorB === Infinity) return 0;
				if (errorA === Infinity) return 1; // Açš„èª¤å·®æ˜¯Infinityï¼Œæ’åœ¨å¾Œé¢
				if (errorB === Infinity) return -1; // Bçš„èª¤å·®æ˜¯Infinityï¼Œæ’åœ¨å¾Œé¢
				
				if (errorA === undefined || errorA === null) return 1;
				if (errorB === undefined || errorB === null) return -1;
				
				if (errorA !== errorB) return errorA - errorB;
				
				// èª¤å·®ä¹Ÿç›¸åŒæ™‚ï¼ŒæŒ‰å‹ç‡é™åºæ’åˆ— (å–3ä½å°æ•¸, å› å‹ç‡å·®åˆ¥å°æ™‚, å¯¦éš›åˆ†åˆ¥ä¸å¤§)
				const winRateA = calculateWinRate(a).toFixed(3) ;
				const winRateB = calculateWinRate(b).toFixed(3) ;
				if (winRateB !== winRateA) return winRateB - winRateA;
				
				// æœ€å¾ŒæŒ‰ç¥¨æ¬¡é™åºæ’åˆ—
				return b.votes - a.votes;
			});
		}

		function updateItemStats() {
			if (!currentPair || !currentGame) return;
			
			const sortedItems = sortItemsByRank(currentGame.items);
			
			[0, 1].forEach(idx => {
				const item = currentPair[idx];
				const rank = sortedItems.findIndex(i => i.id === item.id) + 1;
				const winRate = ( calculateWinRate(item) * 100 ).toFixed(1) ;
				const recentVolatility = calculateRecentVolatility(item);
				const volatilitySymbol = getRecentVolatilitySymbol(item);
				let error = calculateError(item);
				error = error === Infinity ? 'âˆ' : Math.round(error) ;
				
				const allLinks = [...new Set([...(item.links || []), ...(item.invalidLinks || [])])];
				const totalLinkCount = allLinks.length;
				const validLinks = allLinks.filter(link => !item.invalidLinks?.includes(link));
				const validLinkCount = validLinks.length;
				
				const currentVideoUrl = currentVideoLinks[idx] || '[æ²’æœ‰]' ;
				
				// è®¡ç®—ä¸Šæ¬¡æŠ•ç¥¨å¤©æ•°
				let lastVoteString = '(?)' ;
				if (item.scoreHistory && item.scoreHistory.length > 0) {
					const lastVoteTime = Math.max(...item.scoreHistory.map(record => record.timestamp));
					const currentTime = Date.now();
					// let diffHours = (currentTime - lastVoteTime) / (1000 * 60 * 60) ;
					let diffTime = (currentTime - lastVoteTime) / 1e3 ; // ç§’
					lastVoteString = diffTime <= 3 ? 'å‰›å‰›' :
					diffTime <= 60 ? ~~diffTime + 'ç§’å‰' :
					( diffTime /= 60 ) <= 60 ? ~~diffTime + 'åˆ†é˜å‰' :
					( diffTime /= 60 ) <= 24 ? ~~diffTime + 'å°æ™‚å‰' :
					~~(diffTime/24) + 'å¤©å‰' ;
				}
				
				document.getElementById(`stats${idx + 1}`).innerHTML = `
					<div>æ’å: ${rank} | åˆ†æ•¸: ${item.score}Â±${error} | å‹ç‡: ${winRate}% | æ³¢å‹•: ${recentVolatility}${volatilitySymbol} | ç¥¨æ¬¡: ${item.votes} | ä¸Šæ¬¡: ${lastVoteString} | é€£çµ: ${validLinkCount}/${totalLinkCount}</div>
					<div class="current-video-url">${currentVideoUrl}</div>`;
			});
		}

        function setMaxItems() {
			const gameId = document.getElementById('gameSelect').value;
			if (gameId) {
				const keyword = document.getElementById('keywordFilter').value.toLowerCase().trim();
				let items = games[gameId].items;
			   
				if (keyword) {
					items = items.filter(item => item.name.toLowerCase().includes(keyword));
				}
			   
				if (selectedMoodFilters.length > 0) {
					items = applyMoodFilter(items, selectedMoodFilters, votingMoodLogic);
				}
			   
				items = items.filter(item => !item.frozen);
			   
				const maxCount = items.length;
				document.getElementById('itemCount').value = maxCount;

				// è‡ªå‹•å„²å­˜ç›®å‰è¨­å®šçš„åƒè³½é …ç›®æ•¸
				selectedItemCount = maxCount;
				localStorage.setItem('selectedItemCount', selectedItemCount);
			}
		}

        function applyMoodFilter(items, moodFilters, logic) {
            if (moodFilters.length === 0) return items;
            
            return items.filter(item => {
                const itemMoods = item.moods || [];
                
                switch(logic) {
                    case 'and':
                        return moodFilters.every(mood => itemMoods.includes(mood));
                    case 'or':
                        return moodFilters.some(mood => itemMoods.includes(mood));
                    case 'not':
                        return !moodFilters.some(mood => itemMoods.includes(mood));
                    default:
                        return true;
                }
            });
        }

        function reloadVideo(optionNum) {
			if (!currentPair) return;
			const item = currentPair[optionNum - 1];
			if (item?.links?.length > 0) {
				const selectedLink = getRandomValidLink(item);
				currentVideoLinks[optionNum - 1] = selectedLink;
				loadVideo(`video${optionNum}Container`, selectedLink, optionNum);
				if (statsVisible) updateItemStats();
			}
		}

        function reloadBothVideos() {
			[1, 2].forEach(optionNum => {
				if (!currentPair) return;
				const item = currentPair[optionNum - 1];
				if (item?.links?.length > 0) {
					const selectedLink = getRandomValidLink(item);
					currentVideoLinks[optionNum - 1] = selectedLink;
					loadVideo(`video${optionNum}Container`, selectedLink, optionNum);
				}
			});
			if (statsVisible) updateItemStats();
		}

        function showPage(pageName) {
			if (isEditing && editingItemId) {
				saveEditingItemData();
			}
			
			document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
			document.getElementById(pageName).classList.add('active');
			document.querySelectorAll('.btn-nav').forEach(btn => btn.classList.remove('active'));
			event.target.classList.add('active');

			if (pageName === 'voting') {
				clearScoreAnimations();
				updateGameSelect();
				createVotingMoodFilter();
				
				// ç¡®ä¿ç»Ÿè®¡æ˜¾ç¤ºæŒ‰é’®çŠ¶æ€æ­£ç¡®
				const toggleStatsBtn = document.getElementById('toggleStatsButton');
				if (statsVisible) {
					toggleStatsBtn.classList.add('active');
				} else {
					toggleStatsBtn.classList.remove('active');
				}
				
				// ä»localStorageåŠ è½½å¹³å°ç­›é€‰çŠ¶æ€
				const savedPlatformFilters = localStorage.getItem('platformFilters');
				if (savedPlatformFilters) {
					platformFilters = JSON.parse(savedPlatformFilters);
				}
				
				// æ›´æ–°å¹³å°ç­›é€‰æŒ‰é’®çŠ¶æ€
				updatePlatformFilterButtons();
				
				if (selectedGameId) {
					document.getElementById('gameSelect').value = selectedGameId;
					updateGameSettings();
				}
				if (selectedExtractMode) document.getElementById('extractMode').value = selectedExtractMode;
				if (selectedItemCount) document.getElementById('itemCount').value = selectedItemCount;
			} else if (pageName === 'stats') {
				updateStatsGameSelect();
				createStatsMoodFilter();
				if (selectedGameId) {
					document.getElementById('statsGameSelect').value = selectedGameId;
					loadStats();
				}
			} else if (pageName === 'settings') {
				createSettingsMoodFilter();
				setTimeout(() => {
					if (selectedGameForEdit) {
						updateItemsListWithPagination();
					}
				}, 100);
			}
		}

        function clearScoreAnimations() {
            const leftElement = document.getElementById('sliderScoreChangeLeft');
            const rightElement = document.getElementById('sliderScoreChangeRight');
            
            if (leftElement) {
                leftElement.textContent = '';
                leftElement.className = 'slider-score-change';
            }
            
            if (rightElement) {
                rightElement.textContent = '';
                rightElement.className = 'slider-score-change';
            }
            
            scoreAnimationActive = false;
        }

        function saveEditingItemData() {
            if (!editingItemId) return;
            
            const nameInput = document.getElementById(`edit-name-${editingItemId}`);
            const linksInput = document.getElementById(`edit-links-${editingItemId}`);
            
            if (nameInput && linksInput) {
                editingItemData[editingItemId] = {
                    name: nameInput.value,
                    links: linksInput.value,
                    moods: [...(games[selectedGameForEdit].items.find(i => i.id === editingItemId)?.moods || [])]
                };
            }
        }

        function createGame() {
            const gameName = document.getElementById('gameName').value.trim();
            if (!gameName) { alert('è«‹è¼¸å…¥éŠæˆ²åç¨±'); return; }
            const gameId = Date.now().toString();
            games[gameId] = { id: gameId, name: gameName, items: [], votes: [] };
            localStorage.setItem('games', JSON.stringify(games));
            syncData();
            document.getElementById('gameName').value = '';
            updateGamesList();
            alert('éŠæˆ²å‰µå»ºæˆåŠŸï¼');
        }

        function updateGamesList() {
			const gamesList = document.getElementById('gamesList');
			gamesList.innerHTML = '<h3>ç¾æœ‰éŠæˆ²</h3>';
			
			// è·å–æ¸¸æˆIDæ•°ç»„ç”¨äºæ’åº
			const gameIds = Object.keys(games);
			
			gameIds.forEach((gameId, index) => {
				const game = games[gameId];
				const gameItem = document.createElement('div');
				gameItem.className = 'list-item';
				if (renamingGameId === game.id) {
					gameItem.classList.add('editing');
					gameItem.innerHTML = `
						<div><input type="text" class="form-control" id="rename-input-${game.id}" value="${game.name}">
						<small>é …ç›®æ•¸: ${game.items.length}</small></div>
						<div style="display: flex; gap: 10px;">
							<button class="btn btn-primary" onclick="saveGameRename('${game.id}')">å„²å­˜</button>
							<button class="btn btn-gray" onclick="cancelGameRename()">å–æ¶ˆ</button>
						</div>`;
				} else {
					gameItem.innerHTML = `
						<div><div style="font-weight: bold; font-size: 1.2em;">${game.name}</div>
						<small>é …ç›®æ•¸: ${game.items.length}</small></div>
						<div style="display: flex; gap: 10px;">
							<button class="btn btn-primary" onclick="moveGameUp('${game.id}')" ${index === 0 ? 'disabled' : ''}>ä¸Šç§»</button>
							<button class="btn btn-primary" onclick="moveGameDown('${game.id}')" ${index === gameIds.length - 1 ? 'disabled' : ''}>ä¸‹ç§»</button>
							<button class="btn btn-warning" onclick="startRenameGame('${game.id}')">æ”¹å</button>
							<button class="btn btn-info" onclick="editGame('${game.id}')">ç®¡ç†é …ç›®</button>
							<button class="btn btn-danger" onclick="deleteGame('${game.id}')">åˆªé™¤</button>
						</div>`;
				}
				gamesList.appendChild(gameItem);
			});
		}
		
		function moveGameUp(gameId) {
			const gameIds = Object.keys(games);
			const currentIndex = gameIds.indexOf(gameId);
			
			if (currentIndex > 0) {
				// äº¤æ¢æ¸¸æˆé¡ºåº
				const temp = gameIds[currentIndex];
				gameIds[currentIndex] = gameIds[currentIndex - 1];
				gameIds[currentIndex - 1] = temp;
				
				// åˆ›å»ºæ–°çš„æœ‰åºæ¸¸æˆå¯¹è±¡
				const newGames = {};
				gameIds.forEach(id => {
					newGames[id] = games[id];
				});
				
				games = newGames;
				localStorage.setItem('games', JSON.stringify(games));
				syncData();
				updateGamesList();
			}
		}

		function moveGameDown(gameId) {
			const gameIds = Object.keys(games);
			const currentIndex = gameIds.indexOf(gameId);
			
			if (currentIndex < gameIds.length - 1) {
				// äº¤æ¢æ¸¸æˆé¡ºåº
				const temp = gameIds[currentIndex];
				gameIds[currentIndex] = gameIds[currentIndex + 1];
				gameIds[currentIndex + 1] = temp;
				
				// åˆ›å»ºæ–°çš„æœ‰åºæ¸¸æˆå¯¹è±¡
				const newGames = {};
				gameIds.forEach(id => {
					newGames[id] = games[id];
				});
				
				games = newGames;
				localStorage.setItem('games', JSON.stringify(games));
				syncData();
				updateGamesList();
			}
		}

        function startRenameGame(gameId) { renamingGameId = gameId; updateGamesList(); }

        function saveGameRename(gameId) {
            const newName = document.getElementById(`rename-input-${gameId}`).value.trim();
            if (newName) {
                games[gameId].name = newName;
                localStorage.setItem('games', JSON.stringify(games));
                syncData();
                renamingGameId = null;
                updateGamesList();
                updateGameSelect();
                updateStatsGameSelect();
            } else alert('éŠæˆ²åç¨±ä¸èƒ½ç‚ºç©º');
        }

        function cancelGameRename() { renamingGameId = null; updateGamesList(); }

        function toggleInvalidFilter() {
            showInvalidOnly = !showInvalidOnly;
            const btn = document.getElementById('showInvalidOnlyBtn');
            if (showInvalidOnly) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
            filterItems();
        }

        function toggleFrozenFilter() {
            showFrozenOnly = !showFrozenOnly;
            const btn = document.getElementById('showFrozenOnlyBtn');
            if (showFrozenOnly) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
            filterItems();
        }

        function filterItems() { currentPage = 1; updateItemsListWithPagination(); }

        function editGame(gameId) {
			if (isEditing && editingItemId) {
                saveEditingItemData();
            }
			
            selectedGameForEdit = gameId;
            document.getElementById('itemsManagement').classList.remove('hidden');
            currentPage = 1;
            updateItemsListWithPagination();
        }

        function setupIntersectionObserver() {
            if (visibleItemObserver) visibleItemObserver.disconnect();
            visibleItemObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const previewId = entry.target.id;
                        const itemId = previewId.replace('preview-', '');
                        const item = games[selectedGameForEdit].items.find(i => i.id === itemId);
                        if (item?.links?.length > 0 && !entry.target.innerHTML) {
                            loadPreviewVideo(previewId, item.links[0]);
                        }
                    }
                });
            }, { rootMargin: '50px' });
        }

        function deleteGame(gameId) {
            if (confirm('ç¢ºå®šè¦åˆªé™¤é€™å€‹éŠæˆ²å—ï¼Ÿ')) {
                delete games[gameId];
                localStorage.setItem('games', JSON.stringify(games));
                syncData();
                updateGamesList();
            }
        }

        function addItems() {
            if (!selectedGameForEdit) { alert('è«‹å…ˆé¸æ“‡è¦ç·¨è¼¯çš„éŠæˆ²'); return; }
            const itemsInput = document.getElementById('itemsInput').value.trim();
            if (!itemsInput) { alert('è«‹è¼¸å…¥é …ç›®è³‡æ–™'); return; }

            const game = games[selectedGameForEdit];
            const lines = itemsInput.split('\n');
            let addedCount = 0;
			
			console.log(game.items);
			
			const scores = game.items.map( item => item.score ) ;
			
			console.log(scores);
			
			const avgScore = game.items.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : 1500;
			const scoreStdDev = calculateStandardDeviation(scores);
			const defaultScore = Math.ceil( avgScore - scoreStdDev ); // é è¨­åˆ†æ•¸ç‚º ceil( Î¼ - Ïƒ )

            lines.forEach(line => {
                line = line.trim();
                if (!line) return;
                const parts = line.split(',');
                if (parts.length) {
                    const itemName = parts[0].trim();
                    const itemLink = parts.slice(1).join(',').trim();
                    if (itemName) {
                        game.items.push({
                            id: Date.now().toString() + '_' + Math.random(),
                            name: itemName, 
                            links: itemLink ? [itemLink] : [],
                            invalidLinks: [],
                            score: defaultScore, votes: 0, wins: 0, losses: 0, addedTime: Date.now(),
                            moods: [],
                            frozen: false,
                            scoreHistory: [{timestamp: Date.now(), score: defaultScore}]
                        });
                        addedCount++;
                    }
                }
            });

            if (addedCount > 0) {
                localStorage.setItem('games', JSON.stringify(games));
                syncData();
                document.getElementById('itemsInput').value = '';
                updateItemsListWithPagination();
                alert(`æˆåŠŸæ–°å¢ ${addedCount} å€‹é …ç›®ï¼`);
				updateGamesList();
            } else alert('æ²’æœ‰æœ‰æ•ˆçš„é …ç›®è¢«æ–°å¢ï¼Œè«‹æª¢æŸ¥æ ¼å¼');
        }

        function updateItemsListWithPagination() {
			if (!selectedGameForEdit) return;
			const game = games[selectedGameForEdit];
			const filterText = document.getElementById('itemFilter').value.toLowerCase();
			
			filteredItems = game.items.filter(item => {
				const matchesText = !filterText || item.name.toLowerCase().includes(filterText);
				const hasInvalidLinks = item.invalidLinks && item.invalidLinks.length > 0;
				const matchesInvalidFilter = !showInvalidOnly || hasInvalidLinks;
				const matchesFrozenFilter = !showFrozenOnly || item.frozen;
				const currentSettingsMoodLogic = document.getElementById('settingsMoodLogic').value;
				const matchesMoodFilter = applyMoodFilter([item], settingsMoodFilters, currentSettingsMoodLogic).length > 0;
				
				return matchesText && matchesInvalidFilter && matchesFrozenFilter && matchesMoodFilter;
			});
            
            filteredItems.sort((a, b) => (b.addedTime || 0) - (a.addedTime || 0));
            
            const totalItems = filteredItems.length;
            itemsPerPage = parseInt(document.getElementById('pageSize').value);
            const totalPages = Math.ceil(totalItems / itemsPerPage);
            if (currentPage > totalPages) currentPage = totalPages;
            if (currentPage < 1) currentPage = 1;
            
            document.getElementById('itemsListTitle').innerHTML = `${game.name}<br />(${totalItems}/${game.items.length})`;
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, totalItems);
            updateItemsList(filteredItems.slice(startIndex, endIndex));
            updatePagination(totalPages);
            
            setupIntersectionObserver();
            document.querySelectorAll('.item-preview').forEach(preview => {
                if (isElementInViewport(preview)) {
                    const itemId = preview.id.replace('preview-', '');
                    const item = game.items.find(i => i.id === itemId);
                    if (item?.links?.length > 0 && !preview.innerHTML) {
                        loadPreviewVideo(preview.id, item.links[0]);
                    }
                } else {
                    visibleItemObserver.observe(preview);
                }
            });
        }
        
        function changePageSize() {
            currentPage = 1;
            updateItemsListWithPagination();
        }

        function isElementInViewport(el) {
            if (!el) return false;
            const rect = el.getBoundingClientRect();
            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }

        function updatePagination(totalPages) {
            const html = `
                <button class="btn btn-gray" onclick="changePage(1)" ${currentPage === 1 ? 'disabled' : ''}>é¦–é </button>
                <button class="btn btn-gray" onclick="changePage(${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''}>ä¸Šä¸€é </button>
                <span>ç¬¬ ${currentPage} / ${totalPages} é </span>
                <button class="btn btn-gray" onclick="changePage(${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''}>ä¸‹ä¸€é </button>
                <button class="btn btn-gray" onclick="changePage(${totalPages})" ${currentPage === totalPages ? 'disabled' : ''}>æœ«é </button>`;
            ['paginationTop', 'paginationBottom'].forEach(id => document.getElementById(id).innerHTML = html);
        }

        function changePage(page) { currentPage = page; updateItemsListWithPagination(); }

        function updateItemsList(items) {
            const itemsList = document.getElementById('itemsList');
            itemsList.innerHTML = '';
            items.forEach(item => {
                const itemCard = document.createElement('div');
                itemCard.className = 'list-item';
                if (item.frozen) {
                    itemCard.classList.add('frozen');
                }
                if (editingItemId === item.id) {
                    itemCard.classList.add('editing');
                    const savedData = editingItemData[item.id];
                    const nameValue = savedData?.name || item.name;
                    const linksText = savedData?.links || (() => {
                        const allLinks = [...(item.links || [])];
                        item.invalidLinks?.forEach(link => {
                            if (!allLinks.includes(link)) {
                                allLinks.push(link);
                            }
                        });
                        return allLinks.map(link => 
                            item.invalidLinks?.includes(link) ? `[ç„¡æ•ˆ] ${link}` : link).join('\n') || '';
                    })();
                    
                    itemCard.innerHTML = `
                        <div class="item-info">
                            <div style="flex: 1;">
                                <div class="edit-mood-buttons" id="edit-mood-buttons-${item.id}"></div>
                                <input type="text" class="form-control" id="edit-name-${item.id}" value="${nameValue}" style="margin-bottom: 10px;">
                                <textarea class="form-control" id="edit-links-${item.id}" placeholder="æ¯è¡Œä¸€å€‹å½±ç‰‡é€£çµ" style="min-height: 80px;">${linksText}</textarea>
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn btn-primary" onclick="saveItem('${item.id}')">å„²å­˜</button>
                            <button class="btn btn-gray" onclick="cancelEdit()">å–æ¶ˆ</button>
                        </div>`;
                    
                    setTimeout(() => {
                        createEditMoodButtons(item.id, savedData?.moods || item.moods || []);
                    }, 0);
                } else {
                    const firstLink = item.links?.[0] || '';
                    const uniqueLinks = [...new Set(item.links || [])];
                    const linkCount = uniqueLinks.length;
                    const uniqueInvalidLinks = [...new Set(item.invalidLinks || [])];
                    const invalidCount = uniqueInvalidLinks.length;
                    const isFirstLinkInvalid = item.invalidLinks?.includes(firstLink);
                    
                    itemCard.innerHTML = `
                        <div class="item-info">
                            <div class="item-preview" id="preview-${item.id}"></div>
                            <div style="flex: 1;">
                                <div class="item-mood-buttons" id="item-mood-buttons-${item.id}"></div>
                                <div style="font-weight: bold;">${item.name}</div>
                                <div class="${isFirstLinkInvalid ? 'invalid-link' : ''}" style="color: var(--primary); font-size: 0.9em;">${firstLink}</div>
                                <div style="color: var(--gray); font-size: 0.85em;">å…± ${linkCount+invalidCount} å€‹å½±ç‰‡é€£çµ</div>
                                ${invalidCount > 0 ? `<div style="color: var(--danger); font-size: 0.85em;">âš ï¸ ${invalidCount} å€‹ç„¡æ•ˆé€£çµ</div>` : ''}
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px;">
							<button class="btn btn-primary" onclick="searchOnWeb('${item.id}','youtube')">YTæœå°‹</button>
							<button class="btn btn-primary" onclick="searchOnWeb('${item.id}','bilibili')">Bç«™æœå°‹</button>
                            <button class="btn btn-info" onclick="startEditItem('${item.id}')">ç·¨è¼¯</button>
                            <button class="btn ${item.frozen ? 'btn-frozen' : 'btn-gray'}" onclick="toggleFrozen('${item.id}')">${item.frozen ? 'è§£é™¤å‡çµ' : 'å‡çµ'}</button>
                            <button class="btn btn-danger" onclick="confirmRemoveItem('${item.id}')">ç§»é™¤</button>
                        </div>`;
                    
                    setTimeout(() => {
                        createItemMoodButtons(item.id, item.moods || []);
                    }, 0);
                }
                itemsList.appendChild(itemCard);
            });
        }

        function toggleFrozen(itemId) {
            const item = games[selectedGameForEdit].items.find(i => i.id === itemId);
            if (item) {
                item.frozen = !item.frozen;
                localStorage.setItem('games', JSON.stringify(games));
                syncData();
                updateItemsListWithPagination();
            }
        }

        function createItemMoodButtons(itemId, currentMoods) {
            const container = document.getElementById(`item-mood-buttons-${itemId}`);
            if (!container) return;
            
            container.innerHTML = '';
            
            moodEmojis.forEach(emoji => {
                const moodBtn = document.createElement('button');
                moodBtn.className = 'item-mood-btn';
                moodBtn.textContent = emoji;
                moodBtn.dataset.emoji = emoji;
                
                if (currentMoods.includes(emoji)) {
                    moodBtn.classList.add('active');
                }
                
                moodBtn.onclick = function() {
                    toggleItemMood(itemId, emoji, moodBtn);
                };
                
                container.appendChild(moodBtn);
            });
        }

        function toggleItemMood(itemId, emoji, button) {
            const item = games[selectedGameForEdit].items.find(i => i.id === itemId);
            if (!item) return;
            
            if (!item.moods) item.moods = [];
            
            if (item.moods.includes(emoji)) {
                item.moods = item.moods.filter(m => m !== emoji);
                button.classList.remove('active');
            } else {
                item.moods.push(emoji);
                button.classList.add('active');
            }
            
            localStorage.setItem('games', JSON.stringify(games));
            syncData();
        }

        function createEditMoodButtons(itemId, currentMoods) {
            const container = document.getElementById(`edit-mood-buttons-${itemId}`);
            if (!container) return;
            
            container.innerHTML = '';
            
            moodEmojis.forEach(emoji => {
                const moodBtn = document.createElement('button');
                moodBtn.className = 'edit-mood-btn';
                moodBtn.textContent = emoji;
                moodBtn.dataset.emoji = emoji;
                
                if (currentMoods.includes(emoji)) {
                    moodBtn.classList.add('active');
                }
                
                moodBtn.onclick = function() {
                    toggleEditMood(itemId, emoji, moodBtn);
                };
                
                container.appendChild(moodBtn);
            });
        }

        function toggleEditMood(itemId, emoji, button) {
            const item = games[selectedGameForEdit].items.find(i => i.id === itemId);
            if (!item) return;
            
            if (!item.moods) item.moods = [];
            
            if (item.moods.includes(emoji)) {
                item.moods = item.moods.filter(m => m !== emoji);
                button.classList.remove('active');
            } else {
                item.moods.push(emoji);
                button.classList.add('active');
            }
            
            if (editingItemData[itemId]) {
                editingItemData[itemId].moods = [...item.moods];
            }
        }

        function loadPreviewVideo(containerId, link) {
            const container = document.getElementById(containerId);
            if (!container || !link) return;
            if (link.includes('youtube.com') || link.includes('youtu.be')) {
                let videoId = '';
                if (link.includes('youtu.be/')) videoId = link.split('youtu.be/')[1].split(/[?&#]/)[0];
                else if (link.includes('youtube.com/watch')) {
                    const match = link.match(/[?&]v=([^&#]+)/);
                    if (match) videoId = match[1];
                } else if (link.includes('youtube.com/embed/')) videoId = link.split('embed/')[1].split(/[?&#]/)[0];
                else if (link.includes('youtube.com/shorts/')) videoId = link.split('shorts/')[1].split(/[?&#]/)[0];
                if (videoId) container.innerHTML = `<iframe src="https://www.youtube-nocookie.com/embed/${videoId}?controls=1&modestbranding=1&rel=0" frameborder="0" allowfullscreen></iframe>`;
            } else if (link.includes('bilibili.com')) {
                let bvMatch = link.match(/BV[\w]+/);
                if (bvMatch) container.innerHTML = `<iframe src="https://player.bilibili.com/player.html?bvid=${bvMatch[0]}&high_quality=1&autoplay=0" scrolling="no" frameborder="0" allowfullscreen></iframe>`;
                else {
                    const avMatch = link.match(/av(\d+)/);
                    if (avMatch) container.innerHTML = `<iframe src="https://player.bilibili.com/player.html?aid=${avMatch[1]}&high_quality=1&autoplay=0" scrolling="no" frameborder="0" allowfullscreen></iframe>`;
                }
            }
        }
		
		function searchOnWeb(itemId,site) {
			const item = games[selectedGameForEdit].items.find(i => i.id === itemId);
            if (item) {
				let link = '' ;
				switch(site)
				{
					case 'bilibili' :
						link = `https://search.bilibili.com/?keyword=${item.name}` ;
					break ;
					case 'youtube' :
						link = `https://www.youtube.com/results?search_query=${item.name}` ;
					break ;
				}
				window.open(link,'_blank') ;
			}
		}

        function startEditItem(itemId) {
			if (isEditing && editingItemId) {
                saveEditingItemData();
            }

            editingItemId = itemId; 
            isEditing = true;
            updateItemsListWithPagination(); 
        }

        function saveItem(itemId) {
            const item = games[selectedGameForEdit].items.find(i => i.id === itemId);
            if (item) {
                const newName = document.getElementById(`edit-name-${itemId}`).value.trim();
                const newLinksText = document.getElementById(`edit-links-${itemId}`).value.trim();
                if (newName) {
                    const allLinks = newLinksText.split('\n').map(link => link.trim()).filter(link => link);
                    const validLinks = [];
                    const invalidLinks = [];
                    
                    const linkSet = new Set();
                    
                    allLinks.forEach(link => {
                        if (link.startsWith('[ç„¡æ•ˆ] ')) {
                            const cleanLink = link.substring(5);
                            if (linkSet.has(cleanLink)) {
                                const index = validLinks.indexOf(cleanLink);
                                if (index > -1) {
                                    validLinks.splice(index, 1);
                                }
                            }
                            invalidLinks.push(cleanLink);
                            linkSet.add(cleanLink);
                        } else {
                            if (!linkSet.has(link)) {
                                validLinks.push(link);
                                linkSet.add(link);
                            }
                        }
                    });
                    
                    item.name = newName;
                    item.links = [...new Set(validLinks)];
                    item.invalidLinks = [...new Set(invalidLinks)];
                    localStorage.setItem('games', JSON.stringify(games));
                    syncData(); // åŒæ­¥åˆ°æ‰€æœ‰ç¶²é , ä½†æœƒä¸­æ–·æ’­æ”¾ä¸­çš„å½±ç‰‡.
                    editingItemId = null;
                    isEditing = false;
                    delete editingItemData[itemId];
                    updateItemsListWithPagination();
                } else alert('é …ç›®åç¨±ä¸èƒ½ç‚ºç©º');
            }
        }

        function cancelEdit() { 
            if (editingItemId) {
                delete editingItemData[editingItemId];
            }
            editingItemId = null; 
            isEditing = false;
            updateItemsListWithPagination(); 
        }

        function confirmRemoveItem(itemId) {
			if (isEditing && editingItemId) {
                saveEditingItemData();
            }
			
            const item = games[selectedGameForEdit].items.find(i => i.id === itemId);
            if (item && confirm(`ç¢ºå®šè¦ç§»é™¤ã€Œ${item.name}ã€å—ï¼Ÿ`)){
				removeItem(itemId);
				updateGamesList();
			}
        }

        function removeItem(itemId) {
            if (selectedGameForEdit) {
                games[selectedGameForEdit].items = games[selectedGameForEdit].items.filter(item => item.id !== itemId);
                localStorage.setItem('games', JSON.stringify(games));
                syncData();
                updateItemsListWithPagination();
            }
        }

        function updateGameSelect() {
            const gameSelect = document.getElementById('gameSelect');
            const currentValue = gameSelect.value;
            gameSelect.innerHTML = '<option value="">è«‹é¸æ“‡éŠæˆ²</option>';
            Object.values(games).forEach(game => {
				const option = document.createElement('option');
				option.value = game.id; option.textContent = game.name;
				gameSelect.appendChild(option);
            });
            if (currentValue) gameSelect.value = currentValue;
        }

        function updateGameSettings() {
			const gameId = document.getElementById('gameSelect').value;
			selectedGameId = gameId; 
			localStorage.setItem('selectedGameId', selectedGameId);
			
			document.getElementById('gameSettings').style.display = 'flex';
			
			if (!gameId) {
				document.getElementById('extractMode').disabled = true;
				document.getElementById('keywordFilter').disabled = true;
				document.getElementById('itemCount').disabled = true;
				document.querySelector('button[onclick="setMaxItems()"]').disabled = true;
				document.querySelector('button[onclick="startGame()"]').disabled = true;
				
				disableVotingMoodFilter();
				return;
			}
			
			document.getElementById('extractMode').disabled = false;
			document.getElementById('keywordFilter').disabled = false;
			
			// å¿«é€Ÿæ”¶æ–‚æ¨¡å¼ä¸‹ç¦ç”¨é …ç›®æ•¸è¼¸å…¥
			const extractMode = document.getElementById('extractMode').value;
			if (extractMode === 'quickConverge') {
				document.getElementById('itemCount').disabled = true;
				document.querySelector('button[onclick="setMaxItems()"]').disabled = true;
			} else {
				document.getElementById('itemCount').disabled = false;
				document.querySelector('button[onclick="setMaxItems()"]').disabled = false;
			}
			
			document.querySelector('button[onclick="startGame()"]').disabled = false;
			
			enableVotingMoodFilter();
			
			const game = games[gameId];
			const unfrozenItems = game.items.filter(item => !item.frozen);
			document.getElementById('itemCount').max = unfrozenItems.length;
			if (selectedItemCount > 0 && selectedItemCount <= unfrozenItems.length) {
				document.getElementById('itemCount').value = selectedItemCount;
			} else document.getElementById('itemCount').value = unfrozenItems.length;
			if (document.getElementById('votingArea').classList.contains('hidden')) {
				voteHistory = []; document.getElementById('undoBtn').disabled = true;
			}
			
			const savedKeywordFilter = localStorage.getItem('keywordFilter');
			if (savedKeywordFilter !== null) {
				document.getElementById('keywordFilter').value = savedKeywordFilter;
			}
			
			createVotingMoodFilter();
		}

        function disableVotingMoodFilter() {
            const buttons = document.querySelectorAll('#votingMoodFilter .mood-filter-btn');
            buttons.forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
            });
        }

        function enableVotingMoodFilter() {
            const buttons = document.querySelectorAll('#votingMoodFilter .mood-filter-btn');
            buttons.forEach(btn => {
                btn.disabled = false;
                btn.style.opacity = '1';
            });
        }

        function updateItemCountMax() {
			const gameId = document.getElementById('gameSelect').value;
			if (!gameId) return;
			
			const keyword = document.getElementById('keywordFilter').value.toLowerCase().trim();
			let items = games[gameId].items;
			
			if (keyword) {
				items = items.filter(item => item.name.toLowerCase().includes(keyword));
			}
			
			const currentVotingMoodLogic = document.getElementById('votingMoodLogic').value;
			if (selectedMoodFilters.length > 0) {
				items = applyMoodFilter(items, selectedMoodFilters, currentVotingMoodLogic);
			}
			
			items = items.filter(item => !item.frozen);
			
			document.getElementById('itemCount').max = items.length;
		}

        function createVotingMoodFilter() {
            const container = document.getElementById('votingMoodFilter');
            container.innerHTML = '';
            
            const votingMoodLogicSelect = document.getElementById('votingMoodLogic');
            if (votingMoodLogicSelect) {
                votingMoodLogicSelect.value = votingMoodLogic;
            }
            
            moodEmojis.forEach(emoji => {
                const moodBtn = document.createElement('button');
                moodBtn.className = 'mood-filter-btn';
                moodBtn.textContent = emoji;
                moodBtn.dataset.emoji = emoji;
                
                if (selectedMoodFilters.includes(emoji)) {
                    moodBtn.classList.add('active');
                }
                
                moodBtn.onclick = function() {
                    toggleVotingMoodFilter(emoji, moodBtn);
                };
                
                container.appendChild(moodBtn);
            });
            
            if (!document.getElementById('gameSelect').value) {
                disableVotingMoodFilter();
            }
        }

        function toggleVotingMoodFilter(emoji, button) {
            if (selectedMoodFilters.includes(emoji)) {
                selectedMoodFilters = selectedMoodFilters.filter(m => m !== emoji);
                button.classList.remove('active');
            } else {
                selectedMoodFilters.push(emoji);
                button.classList.add('active');
            }
            
            localStorage.setItem('selectedMoodFilters', JSON.stringify(selectedMoodFilters));
            
            updateItemCountMax();
        }

        function clearVotingFilters() {
            document.getElementById('keywordFilter').value = '';
            localStorage.setItem('keywordFilter', '');
            
            selectedMoodFilters = [];
            localStorage.setItem('selectedMoodFilters', JSON.stringify(selectedMoodFilters));
            
            createVotingMoodFilter();
            
            updateItemCountMax();
        }

        function clearSettingsFilters() {
            document.getElementById('itemFilter').value = '';
            // showFrozenOnly = false;
            // document.getElementById('showFrozenOnlyBtn').classList.remove('active');
            
            settingsMoodFilters = [];
            localStorage.setItem('settingsMoodFilters', JSON.stringify(settingsMoodFilters));
            
            createSettingsMoodFilter();
            
            filterItems();
        }

        function clearStatsFilters() {
            document.getElementById('rankingSearch').value = '';
            
            statsMoodFilters = [];
            localStorage.setItem('statsMoodFilters', JSON.stringify(statsMoodFilters));
            
            createStatsMoodFilter();
            
            loadStats();
        }

        function createSettingsMoodFilter() {
			const container = document.getElementById('settingsMoodButtons');
			container.innerHTML = '';
			
			const settingsMoodLogicSelect = document.getElementById('settingsMoodLogic');
			if (settingsMoodLogicSelect) {
				settingsMoodLogicSelect.value = settingsMoodLogic;
			}
			
			moodEmojis.forEach(emoji => {
				const moodBtn = document.createElement('button');
				moodBtn.className = 'mood-filter-btn';
				moodBtn.textContent = emoji;
				moodBtn.dataset.emoji = emoji;
				
				if (settingsMoodFilters.includes(emoji)) {
					moodBtn.classList.add('active');
				}
				
				moodBtn.onclick = function() {
					toggleSettingsMoodFilter(emoji, moodBtn);
				};
				
				container.appendChild(moodBtn);
			});
		}

        function toggleSettingsMoodFilter(emoji, button) {
            if (settingsMoodFilters.includes(emoji)) {
                settingsMoodFilters = settingsMoodFilters.filter(m => m !== emoji);
                button.classList.remove('active');
            } else {
                settingsMoodFilters.push(emoji);
                button.classList.add('active');
            }
            
            localStorage.setItem('settingsMoodFilters', JSON.stringify(settingsMoodFilters));
            
            filterItems();
        }

        function handleKeywordFilterKeydown(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
                
                setTimeout(() => {
                    startGame();
                }, 0);
                
                return false;
            }
        }

        function startGame() {
			if (startGameExecuting) {
				return;
			}
			
			try {
				startGameExecuting = true;
				
				const gameId = document.getElementById('gameSelect').value;
				if (!gameId) return;
				currentGame = games[gameId];
				
				// åœ¨é–‹å§‹éŠæˆ²æ™‚å›ºå®šæŠ½å–æ¨¡å¼åˆ°æ–°çš„è®Šé‡
				currentGameExtractMode = document.getElementById('extractMode').value;
				
				const itemCount = parseInt(document.getElementById('itemCount').value);
				selectedItemCount = itemCount;
				
				const keyword = document.getElementById('keywordFilter').value.toLowerCase().trim();
				let selectedItems = [...currentGame.items];
				
				if (keyword) {
					selectedItems = selectedItems.filter(item => item.name.toLowerCase().includes(keyword));
				}
				
				// ä½¿ç”¨å½“å‰ä¸‹æ‹‰èœå•çš„é‚è¼¯è¿›è¡Œå¿ƒæƒ…ç­›é€‰
				const currentVotingMoodLogic = document.getElementById('votingMoodLogic').value;
				if (selectedMoodFilters.length > 0) {
					selectedItems = applyMoodFilter(selectedItems, selectedMoodFilters, currentVotingMoodLogic);
				}
				
				selectedItems = selectedItems.filter(item => !item.frozen);
				
				if (selectedItems.length < 4) { 
					alert('ç¯©é¸å¾Œçš„é …ç›®æ•¸ä¸è¶³4å€‹ï¼Œè«‹èª¿æ•´ç¯©é¸æ¢ä»¶'); 
					return; 
				}

				uniformPool = [];
				
				// ä½¿ç”¨å›ºå®šçš„ currentGameExtractMode ä¾†æ±ºå®šæŠ½å–é‚è¼¯
				switch (currentGameExtractMode) {
					case 'leastVoted': selectedItems.sort((a, b) => a.votes - b.votes); break;
					case 'newest': selectedItems.sort((a, b) => b.addedTime - a.addedTime); break;
					case 'uniform':
						const shuffled = [...selectedItems].sort(() => 0.5 - Math.random());
						uniformPool = shuffled.slice(0, itemCount);
						break;
					case 'strongest': 
						selectedItems = sortItemsByRank(selectedItems);
						break;
					case 'weakest': 
						selectedItems = sortItemsByRank(selectedItems).reverse();
						break;
					case 'middle':
						selectedItems = sortItemsByRank(selectedItems);
						const totalItems = selectedItems.length;
						const startIndex = Math.floor((totalItems - itemCount) / 2);
						const endIndex = startIndex + itemCount;
						selectedItems = selectedItems.slice(startIndex, endIndex);
						break;
					case 'highestWinRate':
						selectedItems.sort((a, b) => {
							const winRateA = calculateWinRate(a);
							const winRateB = calculateWinRate(b);
							return winRateB - winRateA;
						});
						break;
					case 'lowestWinRate':
						selectedItems.sort((a, b) => {
							const winRateA = calculateWinRate(a);
							const winRateB = calculateWinRate(b);
							return winRateA - winRateB;
						});
						break;
					case 'middleWinRate':
						selectedItems.sort((a, b) => {
							const winRateA = calculateWinRate(a);
							const winRateB = calculateWinRate(b);
							const diffA = Math.abs(winRateA - 0.5);
							const diffB = Math.abs(winRateB - 0.5);
							return diffA - diffB;
						});
						selectedItems = selectedItems.slice(0, itemCount);
						break;
					case 'nearAverage':
						let totalScore = 0;
						selectedItems.forEach(item => totalScore += item.score);
						const avgScore = selectedItems.length > 0 ? totalScore / selectedItems.length : 1500;
						
						selectedItems.sort((a, b) => {
							const diffA = Math.abs(a.score - avgScore);
							const diffB = Math.abs(b.score - avgScore);
							return diffA - diffB;
						});
						selectedItems = selectedItems.slice(0, itemCount);
						break;
					case 'maxError':
						selectedItems.sort((a, b) => {
							const errorA = calculateError(a);
							const errorB = calculateError(b);
							if (errorA === Infinity && errorB !== Infinity) return -1;
							if (errorA !== Infinity && errorB === Infinity) return 1;
							return errorB - errorA;
						});
						selectedItems = selectedItems.slice(0, itemCount);
						break;
					case 'similarScore':
						selectedItems.sort((a, b) => a.score - b.score);

						const maxStartIndex = selectedItems.length - itemCount;
						const startIdx = Math.floor(Math.random() * (maxStartIndex + 1));
						
						selectedItems = selectedItems.slice(startIdx, startIdx + itemCount);
						break;
					case 'leastVolatility':
						// æ³¢å‹•æœ€å°æ¨¡å¼ï¼šæŒ‰æœˆåº¦æ³¢å‹•å‡åºæ’åˆ—ï¼Œé¸å–æ³¢å‹•æœ€å°çš„é …ç›®
						selectedItems.sort((a, b) => {
							const volatilityA = calculateRecentVolatility(a);
							const volatilityB = calculateRecentVolatility(b);
							return volatilityA - volatilityB;
						});
						selectedItems = selectedItems.slice(0, itemCount);
						break;
					case 'highestTrend':
						// å‡ç‡æœ€é«˜æ¨¡å¼ï¼šæŒ‰è¶‹åŠ¿å€¼ä»å¤§åˆ°å°æ’åºï¼Œé€‰æ‹©å‰ itemCount ä¸ª
						selectedItems.sort((a, b) => {
							const trendA = calculateTrendValue(a);
							const trendB = calculateTrendValue(b);
							return trendB - trendA; // é™åºæ’åˆ—ï¼Œè¶‹åŠ¿å€¼å¤§çš„åœ¨å‰
						});
						selectedItems = selectedItems.slice(0, itemCount);
						break;
					case 'lowestTrend':
						// é™ç‡æœ€é«˜æ¨¡å¼ï¼šæŒ‰è¶‹åŠ¿å€¼ä»å°åˆ°å¤§æ’åºï¼Œé€‰æ‹©å‰ itemCount ä¸ª
						selectedItems.sort((a, b) => {
							const trendA = calculateTrendValue(a);
							const trendB = calculateTrendValue(b);
							return trendA - trendB; // å‡åºæ’åˆ—ï¼Œè¶‹åŠ¿å€¼å°çš„åœ¨å‰
						});
						selectedItems = selectedItems.slice(0, itemCount);
						break;
					case 'quickConverge':
						break;
				}

				// ä½¿ç”¨å›ºå®šçš„ currentGameExtractMode ä¾†æ±ºå®š activeItems
				activeItems = currentGameExtractMode === 'quickConverge' ? selectedItems : 
							 currentGameExtractMode === 'uniform' ? uniformPool : 
							 currentGameExtractMode === 'middle' || currentGameExtractMode === 'middleWinRate' || currentGameExtractMode === 'nearAverage' || currentGameExtractMode === 'maxError' || currentGameExtractMode === 'similarScore' || currentGameExtractMode === 'leastVolatility' ? selectedItems : 
							 selectedItems.slice(0, itemCount);
							 
				if (currentGameExtractMode !== 'quickConverge' && activeItems.length < 4) { alert('é¸æ“‡çš„é …ç›®æ•¸ä¸è¶³ 4 å€‹'); return; }

				// æ›´æ–°éŠæˆ²ç‹€æ…‹ä¿¡æ¯ - ä½¿ç”¨å›ºå®šçš„æŠ½å–æ¨¡å¼åç¨±
				// åœ¨é–‹å§‹éŠæˆ²æ™‚å›ºå®šé¡¯ç¤ºç•¶å‰é¸æ“‡çš„éŠæˆ²åç¨±
				document.getElementById('currentPlayingGame').textContent = currentGame.name;
				voteHistory = [];
				updateGameStatusInfo();
				document.getElementById('gameStatusInfo').style.display = 'block';

				document.getElementById('votingArea').classList.remove('hidden');
				document.getElementById('voteSlider').value = 50;
				const slider = document.getElementById('voteSlider');
				
				slider.onmousedown = function(e) {
					if (e.button === 0) {
						isLeftMouseDownOnSlider = true;
					}
				};
				
				slider.onmouseup = function(e) {
					if (e.button === 0 && isLeftMouseDownOnSlider) {
						submitVote();
					}
					isLeftMouseDownOnSlider = false;
				};
				
				slider.ontouchend = submitVote;
				slider.oncontextmenu = function(e) { e.preventDefault(); return false; };
				
				voteHistory = []; document.getElementById('undoBtn').disabled = true;
				currentPair = null;
				
				lockedLeft = false;
				lockedRight = false;
				frozenLeft = false;
				frozenRight = false;
				document.getElementById('lockBtnLeft').classList.remove('active');
				document.getElementById('lockBtnRight').classList.remove('active');
				document.getElementById('freezeBtnLeft').classList.remove('active');
				document.getElementById('freezeBtnRight').classList.remove('active');
				
				if (statsVisible) {
					document.getElementById('toggleStatsButton').textContent = 'ğŸ‘ï¸';
					updateItemStats();
					document.getElementById('stats1').classList.remove('hidden');
					document.getElementById('stats2').classList.remove('hidden');
				} else {
					document.getElementById('toggleStatsButton').textContent = 'ğŸ‘ï¸';
					document.getElementById('stats1').classList.add('hidden');
					document.getElementById('stats2').classList.add('hidden');
				}
				
				loadNewPair();
			} finally {
				startGameExecuting = false;
			}
		}

        function loadNewPair(replacePosition = null) {
			if (!currentGame) return;
			
			// ä½¿ç”¨å›ºå®šçš„ currentGameExtractModeï¼Œè€Œä¸æ˜¯å®æ—¶ä»ä¸‹æ‹‰èœå•è¯»å–
			if (currentGameExtractMode === 'quickConverge') {
				// å¿«é€Ÿæ”¶æ–‚æ¨¡å¼
				if (replacePosition === null || !currentPair) {
					// åˆæ¬¡è¼‰å…¥æˆ–å®Œå…¨æ›´æ›
					if (lockedLeft && currentPair) {
						// é–å®šå·¦é‚Šï¼Œåªæ›´æ›å³é‚Š
						const lockedItem = currentPair[0];
						const otherItem = findClosestItem(lockedItem, activeItems.filter(item => item.id !== lockedItem.id));
						currentPair = [lockedItem, otherItem];
					} else if (lockedRight && currentPair) {
						// é–å®šå³é‚Šï¼Œåªæ›´æ›å·¦é‚Š
						const lockedItem = currentPair[1];
						const otherItem = findClosestItem(lockedItem, activeItems.filter(item => item.id !== lockedItem.id));
						currentPair = [otherItem, lockedItem];
					} else {
						// æ²’æœ‰é–å®šæˆ–åˆæ¬¡è¼‰å…¥
						const itemA = findMaxErrorItem(activeItems);
						const itemB = findClosestItem(itemA, activeItems.filter(item => item.id !== itemA.id));
						currentPair = [itemA, itemB];
					}
					loadBothVideos();
					createMoodButtons();
					updateFreezeButtons();
				} else {
					// éƒ¨åˆ†æ›´æ›
					const positions = replacePosition === 'both' ? [0, 1] : [replacePosition];
					positions.forEach(pos => {
						if ((pos === 0 && lockedLeft) || (pos === 1 && lockedRight)) {
							return;
						}
						
						let newItem;
						if (currentGameExtractMode === 'quickConverge') {
							if (lockedLeft && pos === 1) {
								newItem = findClosestItem(currentPair[0], activeItems.filter(item => item.id !== currentPair[0].id && item.id !== currentPair[1].id));
							} else if (lockedRight && pos === 0) {
								newItem = findClosestItem(currentPair[1], activeItems.filter(item => item.id !== currentPair[0].id && item.id !== currentPair[1].id));
							} else {
								if (pos === 0) {
									newItem = findMaxErrorItem(activeItems.filter(item => item.id !== currentPair[1].id));
								} else {
									newItem = findClosestItem(currentPair[0], activeItems.filter(item => item.id !== currentPair[0].id && item.id !== currentPair[1].id));
								}
							}
						} else {
							let newItemIndex;
							do { newItemIndex = Math.floor(Math.random() * activeItems.length); }
							while (activeItems[newItemIndex].id === currentPair[0].id || activeItems[newItemIndex].id === currentPair[1].id);
							newItem = activeItems[newItemIndex];
						}
						currentPair[pos] = newItem;
						document.getElementById(`option${pos + 1}Title`).textContent = currentPair[pos].name;
						const link = getRandomValidLink(currentPair[pos]);
						currentVideoLinks[pos] = link;
						loadVideo(`video${pos + 1}Container`, link, pos + 1);
					});
					if (replacePosition === 'both') loadBothVideos();
					createMoodButtons();
					updateFreezeButtons();
				}
			} else {
				// å…¶ä»–æ¨¡å¼
				if (!activeItems || activeItems.length < 2) return;
				if (replacePosition === null || !currentPair) {
					const idx1 = Math.floor(Math.random() * activeItems.length);
					let idx2 = Math.floor(Math.random() * activeItems.length);
					while (idx2 === idx1) idx2 = Math.floor(Math.random() * activeItems.length);
					currentPair = [activeItems[idx1], activeItems[idx2]];
					loadBothVideos();
					createMoodButtons();
					updateFreezeButtons();
				} else {
					const positions = replacePosition === 'both' ? [0, 1] : [replacePosition];
					positions.forEach(pos => {
						if ((pos === 0 && lockedLeft) || (pos === 1 && lockedRight)) {
							return;
						}
						
						let newItemIndex;
						do { newItemIndex = Math.floor(Math.random() * activeItems.length); }
						while (activeItems[newItemIndex].id === currentPair[0].id || activeItems[newItemIndex].id === currentPair[1].id);
						currentPair[pos] = activeItems[newItemIndex];
						document.getElementById(`option${pos + 1}Title`).textContent = currentPair[pos].name;
						const link = getRandomValidLink(currentPair[pos]);
						currentVideoLinks[pos] = link;
						loadVideo(`video${pos + 1}Container`, link, pos + 1);
					});
					if (replacePosition === 'both') loadBothVideos();
					createMoodButtons();
					updateFreezeButtons();
				}
			}
			updateItemStats();
		}
		
		function updateGameStatusInfo() {
			if (!currentGame || !activeItems) {
				document.getElementById('gameStatusInfo').style.display = 'none';
				return;
			}
			
			const extractModeNames = {
				'quickConverge': 'å¿«é€Ÿæ”¶æ–‚',
				'uniform': 'å‡å‹»éš¨æ©Ÿ',
				'maxError': 'æœ€å¤§èª¤å·®',
				'leastVoted': 'æœ€å°‘ç¥¨æ¬¡',
				'newest': 'æœ€è¿‘åŠ å…¥',
				'similarScore': 'åˆ†æ•¸ç›¸è¿‘',
				'weakest': 'åæ¬¡æœ€ä½',
				'lowestWinRate': 'å‹ç‡æœ€ä½',
				'middle': 'åæ¬¡ä¸­æ®µ',
				'nearAverage': 'è¿‘å¹³å‡åˆ†',
				'middleWinRate': 'å‹ç‡ä¸­æ®µ',
				'strongest': 'åæ¬¡æœ€é«˜',
				'highestWinRate': 'å‹ç‡æœ€é«˜',
				'leastVolatility': 'æ³¢å‹•æœ€å°',
				'highestTrend': 'å‡ç‡æœ€é«˜',
				'lowestTrend': 'é™ç‡æœ€é«˜'
			};
			
			// ä½¿ç”¨å›ºå®šçš„ currentGameExtractMode ä¾†é¡¯ç¤ºæ¨¡å¼åç¨±
			document.getElementById('currentExtractMode').textContent = extractModeNames[currentGameExtractMode] ?? currentGameExtractMode;
			document.getElementById('currentPoolSize').textContent = activeItems.length;
			document.getElementById('currentVoteCount').textContent = voteHistory.length;
		}
		
		function updateFreezeButtons() {
			if (!currentPair) return;
			
			// ç²å–ç•¶å‰é …ç›®çš„å‡çµç‹€æ…‹
			const item1 = currentGame.items.find(i => i.id === currentPair[0].id);
			const item2 = currentGame.items.find(i => i.id === currentPair[1].id);
			
			if (item1) {
				frozenLeft = item1.frozen || false;
				const freezeBtnLeft = document.getElementById('freezeBtnLeft');
				if (freezeBtnLeft) {
					if (frozenLeft) {
						freezeBtnLeft.classList.add('active');
					} else {
						freezeBtnLeft.classList.remove('active');
					}
				}
			}
			
			if (item2) {
				frozenRight = item2.frozen || false;
				const freezeBtnRight = document.getElementById('freezeBtnRight');
				if (freezeBtnRight) {
					if (frozenRight) {
						freezeBtnRight.classList.add('active');
					} else {
						freezeBtnRight.classList.remove('active');
					}
				}
			}
		}

        function findMaxErrorItem(items) {
            let maxError = -1;
            let maxErrorItem = null;
            
            items.forEach(item => {
                const error = calculateError(item);
                if (error > maxError) {
                    maxError = error;
                    maxErrorItem = item;
                }
            });
            
            if (!maxErrorItem) {
                maxErrorItem = items[Math.floor(Math.random() * items.length)];
            }

            return maxErrorItem;
        }

		// æ‰¾åˆ†æ•¸æœ€æ¥è¿‘ä¸”èª¤å·®æœ€å°çš„é …ç›®
        function findClosestItem(baseItem, items) {
			const baseError = calculateError(baseItem);
			
			/* // å¦‚æœ baseItem çš„èª¤å·®ç‚ºç„¡é™å¤§ï¼Œå‰‡é¸æ“‡èª¤å·®æœ€å°çš„é …ç›®
			if (baseError === Infinity) {
				let minError = Infinity;
				let minErrorItem = null;
				
				items.forEach(item => {
					const error = calculateError(item);
					if (error < minError) {
						minError = error;
						minErrorItem = item;
					}
				});
				
				return minErrorItem;
			}*/
			
			// å…ˆå˜—è©¦æ‰¾èª¤å·®ä¸ç‚º Infinity çš„é …ç›®
			let validItems = items.filter(item => {
				const error = calculateError(item);
				return error !== Infinity;
			});
			
			// å¦‚æœæ²’æœ‰èª¤å·®æœ‰æ•ˆçš„é …ç›®ï¼Œå‰‡ä½¿ç”¨æ‰€æœ‰é …ç›®
			if (validItems.length === 0) {
				validItems = items;
			}
			
			// åœ¨æœ‰æ•ˆé …ç›®ä¸­æ‰¾åˆ†æ•¸æœ€æ¥è¿‘ä¸”èª¤å·®æœ€å°çš„é …ç›®
			let closestItem = null;
			let minScoreDiff = Infinity;
			let minError = Infinity;
			
			validItems.forEach(item => {
				const scoreDiff = Math.abs(item.score - baseItem.score);
				const error = calculateError(item);
				
				if (scoreDiff < minScoreDiff || (scoreDiff === minScoreDiff && error < minError)) {
					minScoreDiff = scoreDiff;
					minError = error;
					closestItem = item;
				}
			});
			
			return closestItem;
		}

        function createMoodButtons() {
            [1, 2].forEach(optionNum => {
                const moodButtonsContainer = document.getElementById(`mood${optionNum}Buttons`);
                moodButtonsContainer.innerHTML = '';
                
                moodEmojis.forEach((emoji, index) => {
                    const moodBtn = document.createElement('button');
                    moodBtn.className = 'mood-btn';
                    moodBtn.textContent = emoji;
                    moodBtn.dataset.emoji = emoji;
                    
                    const item = currentPair[optionNum - 1];
                    if (item.moods && item.moods.includes(emoji)) {
                        moodBtn.classList.add('active');
                    }
                    
                    moodBtn.onclick = function() {
                        toggleMood(optionNum, emoji, moodBtn);
                    };
                    
                    moodButtonsContainer.appendChild(moodBtn);
                });
            });
        }

        function toggleMood(optionNum, emoji, button) {
            const item = currentGame.items.find(i => i.id === currentPair[optionNum - 1].id);
            if (!item) return;
            
            if (!item.moods) item.moods = [];
            
            if (item.moods.includes(emoji)) {
                item.moods = item.moods.filter(m => m !== emoji);
                button.classList.remove('active');
            } else {
                item.moods.push(emoji);
                button.classList.add('active');
            }
            
            localStorage.setItem('games', JSON.stringify(games));
            syncData();
        }

        function createStatsMoodFilter() {
			const container = document.getElementById('statsMoodButtons');
			container.innerHTML = '';
			
			const statsMoodLogicSelect = document.getElementById('statsMoodLogic');
			if (statsMoodLogicSelect) {
				statsMoodLogicSelect.value = statsMoodLogic;
			}
			
			moodEmojis.forEach(emoji => {
				const moodBtn = document.createElement('button');
				moodBtn.className = 'mood-filter-btn';
				moodBtn.textContent = emoji;
				moodBtn.dataset.emoji = emoji;
				
				if (statsMoodFilters.includes(emoji)) {
					moodBtn.classList.add('active');
				}
				
				moodBtn.onclick = function() {
					toggleStatsMoodFilter(emoji, moodBtn);
				};
				
				container.appendChild(moodBtn);
			});
		}

        function toggleStatsMoodFilter(emoji, button) {
            if (statsMoodFilters.includes(emoji)) {
                statsMoodFilters = statsMoodFilters.filter(m => m !== emoji);
                button.classList.remove('active');
            } else {
                statsMoodFilters.push(emoji);
                button.classList.add('active');
            }
            
            localStorage.setItem('statsMoodFilters', JSON.stringify(statsMoodFilters));
            
            loadStats();
        }

        function loadBothVideos() {
			['option1Title', 'option2Title'].forEach((id, idx) => 
				document.getElementById(id).textContent = currentPair[idx].name);
			[0, 1].forEach(idx => {
				const link = getRandomValidLink(currentPair[idx]);
				currentVideoLinks[idx] = link;
				loadVideo(`video${idx + 1}Container`, link, idx + 1);
			});
		}

        function loadVideo(containerId, link, playerNum) {
			const container = document.getElementById(containerId);
			const item = currentGame.items.find(i => i.id === currentPair[playerNum - 1].id);
			const isInvalid = item?.invalidLinks?.includes(link);
			
			// å¤„ç†æ²¡æœ‰é“¾æ¥æˆ–é“¾æ¥ä¸ºnullçš„æƒ…å†µ
			if (!link) {
				container.innerHTML = '<div style="color: var(--danger); background: #fff; padding: 20px; text-align: center; border-radius: 10px;">ç„¡ç¬¦åˆç¯©é¸æ¢ä»¶çš„å½±ç‰‡é€£çµ</div>';
				return;
			}

			// åŸæœ‰çš„è§†é¢‘åŠ è½½é€»è¾‘ä¿æŒä¸å˜
			if (playerNum === 1 && player1) { try { player1.destroy(); } catch(e) {} player1 = null; }
			else if (playerNum === 2 && player2) { try { player2.destroy(); } catch(e) {} player2 = null; }

			const buttons = `
				<button class="invalid-btn ${isInvalid ? 'active' : ''}" onclick="toggleInvalidLink(${playerNum})" title="æ¨™è¨˜ç‚ºç„¡æ•ˆå½±ç‰‡">âš ï¸</button>
				<button class="reload-btn" onclick="reloadVideo(${playerNum})" title="æ›´æ›å½±ç‰‡ä¾†æº">
					<svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
				</button>`;

			// åŸæœ‰çš„è§†é¢‘åµŒå…¥é€»è¾‘ä¿æŒä¸å˜
			if (link.includes('youtube.com') || link.includes('youtu.be')) {
				let videoId = '';
				if (link.includes('youtu.be/')) videoId = link.split('youtu.be/')[1].split(/[?&#]/)[0];
				else if (link.includes('youtube.com/watch')) {
					const match = link.match(/[?&]v=([^&#]+)/);
					if (match) videoId = match[1];
				} else if (link.includes('youtube.com/embed/')) videoId = link.split('embed/')[1].split(/[?&#]/)[0];
				else if (link.includes('youtube.com/shorts/')) videoId = link.split('shorts/')[1].split(/[?&#]/)[0];
				
				if (videoId) {
					const playerId = `youtube-player-${playerNum}`;
					container.innerHTML = `${buttons}<div id="${playerId}"></div>`;
					if (youtubeReady) {
						const player = new YT.Player(playerId, {
							height: '100%', width: '100%', videoId: videoId,
							playerVars: { autoplay: 0, controls: 1, rel: 0, modestbranding: 1, playsinline: 1 },
							events: { onReady: event => event.target.mute() }
						});
						if (playerNum === 1) player1 = player;
						else player2 = player;
					} else {
						container.innerHTML = `${buttons}<iframe src="https://www.youtube-nocookie.com/embed/${videoId}?enablejsapi=1&rel=0&modestbranding=1&playsinline=1&mute=1" frameborder="0" allowfullscreen></iframe>`;
					}
				}
			} else if (link.includes('bilibili.com')) {
				let bvMatch = link.match(/BV[\w]+/);
				if (bvMatch) container.innerHTML = `${buttons}<iframe src="https://player.bilibili.com/player.html?bvid=${bvMatch[0]}&high_quality=1&autoplay=0" scrolling="no" frameborder="0" allowfullscreen></iframe>`;
				else {
					const avMatch = link.match(/av(\d+)/);
					if (avMatch) container.innerHTML = `${buttons}<iframe src="https://player.bilibili.com/player.html?aid=${avMatch[1]}&high_quality=1&autoplay=0" scrolling="no" frameborder="0" allowfullscreen></iframe>`;
				}
			}
			
			if (statsVisible) updateItemStats();
		}

        function voteExtreme(value) { 
            if (cooldownActive) return;
            document.getElementById('voteSlider').value = value; 
            submitVote(); 
        }
        
        function submitVote() { 
            if (cooldownActive) return;
            if (currentGame && currentPair) processVote(parseInt(document.getElementById('voteSlider').value)); 
        }
        
        function submitTie() { 
            if (cooldownActive) return;
            if (currentGame && currentPair) processVote(50); 
        }

        function startCooldown() {
            cooldownActive = true;
            
            document.getElementById('voteSlider').disabled = true;
            document.querySelectorAll('.flex-center .btn').forEach(btn => {
                btn.disabled = true;
            });
            
            setTimeout(() => {
                cooldownActive = false;
                document.getElementById('voteSlider').disabled = false;
                document.querySelectorAll('.flex-center .btn').forEach(btn => {
                    if (btn.id === 'undoBtn') {
                        btn.disabled = (voteHistory.length === 0);
                    } else {
                        btn.disabled = false;
                    }
                });
            }, 2000);
        }

        function processVote(sliderValue) {
			startCooldown();
			
			const oldMoods = {
				item1: [...(currentPair[0].moods || [])],
				item2: [...(currentPair[1].moods || [])]
			};
			
			voteHistory.push({
				pair: [...currentPair], value: sliderValue,
				oldScores: { item1: currentPair[0].score, item2: currentPair[1].score },
				oldWins: { item1: currentPair[0].wins || 0, item2: currentPair[1].wins || 0 },
				oldLosses: { item1: currentPair[0].losses || 0, item2: currentPair[1].losses || 0 },
				oldMoods: oldMoods
			});

			// è¨ˆç®—é …ç›® çš„ èª¤å·®
			let error1 = calculateError(currentPair[0]);
			let error2 = calculateError(currentPair[1]);
			
			// æœ€å¤§èª¤å·®
			if (error1 === Infinity) error1 = 3500 ;
			if (error2 === Infinity) error2 = 3500 ;
			
			const scoreA = currentPair[0].score, scoreB = currentPair[1].score;
			const winRateA = 1 - (sliderValue / 100), winRateB = sliderValue / 100;
			const expectedA = 1 / (1 + Math.pow(10, (scoreB - scoreA) / 400));
			const expectedB = 1 / (1 + Math.pow(10, (scoreA - scoreB) / 400));
			const k_min = 16 ;
			const k_max = 481.648 ;
			
			let k1 = k_min + (k_max - k_min) * error1**2 / ( error1**2 + 463725.2449534823 ) ;
			let k2 = k_min + (k_max - k_min) * error2**2 / ( error2**2 + 463725.2449534823 ) ;

			k1 = Math.max(k_min, Math.min(k_max, k1));
			k2 = Math.max(k_min, Math.min(k_max, k2));
			
			const item1 = currentGame.items.find(item => item.id === currentPair[0].id);
			const item2 = currentGame.items.find(item => item.id === currentPair[1].id);
			
			if (item1 && item2) {
				const newScore1 = Math.round(item1.score + k1 * (winRateA - expectedA));
				const newScore2 = Math.round(item2.score + k2 * (winRateB - expectedB));
				
				const leftElement = document.getElementById('sliderScoreChangeLeft');
				const rightElement = document.getElementById('sliderScoreChangeRight');
				
				const change1 = newScore1 - item1.score;
				const change2 = newScore2 - item2.score;
				
				console.log(`k1 = ${k1} , change = ${change1}`);
				console.log(`k2 = ${k2} , change = ${change2}`);
				
				scoreAnimationActive = true;
				
				leftElement.textContent = change1 > 0 ? `+${change1}` : `${change1}` ;
				leftElement.className = `slider-score-change left ${change1 > 0 ? 'positive' : change1 < 0 ? 'negative' : 'zero' }`;
				leftElement.style.animation = 'none'; 
				leftElement.offsetHeight; 
				leftElement.style.animation = null;
				
				rightElement.textContent = change2 > 0 ? `+${change2}` : `${change2}` ;
				rightElement.className = `slider-score-change right ${change2 > 0 ? 'positive' : change2 < 0 ? 'negative' : 'zero' }`;
				rightElement.style.animation = 'none'; 
				rightElement.offsetHeight; 
				rightElement.style.animation = null;
				
				item1.score = newScore1;
				item2.score = newScore2;
				item1.votes++;
				item2.votes++;
				['wins', 'losses'].forEach(prop => { if (!item1[prop]) item1[prop] = 0; if (!item2[prop]) item2[prop] = 0; });
				
				item1.wins += 1 - sliderValue/100 ;
				item1.losses += sliderValue/100 ;
				item2.wins += sliderValue/100 ;
				item2.losses += 1 - sliderValue/100 ;
				
				const errorAfter1 = calculateError(item1);
				const errorAfter2 = calculateError(item2);
				
				const timestamp = Date.now();
				if (!item1.scoreHistory) item1.scoreHistory = [];
				if (!item2.scoreHistory) item2.scoreHistory = [];
				
				// è¨˜éŒ„åˆ†æ•¸æ™‚åŒæ™‚è¨˜éŒ„æŠ•ç¥¨å¾Œçš„èª¤å·®
				item1.scoreHistory.push({
					timestamp, 
					score: newScore1,
					error: errorAfter1
				});
				item2.scoreHistory.push({
					timestamp, 
					score: newScore2,
					error: errorAfter2
				});
				
				currentGame.votes.push({ timestamp: Date.now(), item1: currentPair[0].id, item2: currentPair[1].id, value: sliderValue });
				localStorage.setItem('games', JSON.stringify(games));
				syncData();
				
				// æ›´æ–°éŠæˆ²ç‹€æ…‹ä¿¡æ¯ - åªæ›´æ–°å·²æŠ•æ¬¡æ•¸
				document.getElementById('currentVoteCount').textContent = voteHistory.length;
				
				let replacePosition;
				// ä½¿ç”¨å›ºå®šçš„ currentGameExtractMode ä¾†æ±ºå®šæ›¿æ›é‚è¼¯
				if (currentGameExtractMode === 'quickConverge') {
					if (lockedLeft && lockedRight) {
						replacePosition = 'both';
					} else if (lockedLeft) {
						replacePosition = 1;
					} else if (lockedRight) {
						replacePosition = 0;
					} else {
						replacePosition = 'both';
					}
				} else {
					if (sliderValue === 50) {
						if (!lockedLeft && !lockedRight) {
							replacePosition = 'both';
						} else if (lockedLeft && !lockedRight) {
							replacePosition = 1;
						} else if (!lockedLeft && lockedRight) {
							replacePosition = 0;
						} else {
							replacePosition = 'both';
						}
					} else if (sliderValue < 50) {
						if (lockedLeft && lockedRight) {
							replacePosition = 'both';
						} else if (lockedLeft) {
							replacePosition = 1;
						} else if (lockedRight) {
							replacePosition = 0;
						} else {
							replacePosition = 1;
						}
					} else {
						if (lockedLeft && lockedRight) {
							replacePosition = 'both';
						} else if (lockedLeft) {
							replacePosition = 1;
						} else if (lockedRight) {
							replacePosition = 0;
						} else {
							replacePosition = 0;
						}
					}
				}
				
				setTimeout(() => {
					loadNewPair(replacePosition);
					document.getElementById('voteSlider').value = 50;
				}, 1500);
				
				setTimeout(() => {
					scoreAnimationActive = false;
				}, 2000);
			}
		}

        function undoVote() {
			if (voteHistory.length === 0) return;
			const lastVote = voteHistory.pop();
			currentGame.votes.pop();
			
			const item1 = currentGame.items.find(item => item.id === lastVote.pair[0].id);
			const item2 = currentGame.items.find(item => item.id === lastVote.pair[1].id);
			
			if (item1 && item2) {
				['score', 'wins', 'losses'].forEach(prop => {
					item1[prop] = lastVote[prop === 'score' ? 'oldScores' : `old${prop.charAt(0).toUpperCase() + prop.slice(1)}`].item1;
					item2[prop] = lastVote[prop === 'score' ? 'oldScores' : `old${prop.charAt(0).toUpperCase() + prop.slice(1)}`].item2;
				});
				
				if (lastVote.oldMoods) {
					item1.moods = [...lastVote.oldMoods.item1];
					item2.moods = [...lastVote.oldMoods.item2];
				}
				
				if (item1.scoreHistory && item1.scoreHistory.length > 0) {
					item1.scoreHistory.pop();
				}
				if (item2.scoreHistory && item2.scoreHistory.length > 0) {
					item2.scoreHistory.pop();
				}
				
				item1.votes--; item2.votes--;
				localStorage.setItem('games', JSON.stringify(games));
				syncData();
				
				// æ›´æ–°éŠæˆ²ç‹€æ…‹ä¿¡æ¯ - åªæ›´æ–°å·²æŠ•æ¬¡æ•¸
				document.getElementById('currentVoteCount').textContent = voteHistory.length;
				
				currentPair = lastVote.pair;
				['option1Title', 'option2Title'].forEach((id, idx) => 
					document.getElementById(id).textContent = currentPair[idx].name);
				[0, 1].forEach(idx => {
					const link = getRandomValidLink(currentPair[idx]);
					currentVideoLinks[idx] = link;
					loadVideo(`video${idx + 1}Container`, link, idx + 1);
				});
				document.getElementById('voteSlider').value = 50;
				
				createMoodButtons();
				
				if (statsVisible) updateItemStats();
				updateFreezeButtons();
				if (voteHistory.length === 0) document.getElementById('undoBtn').disabled = true;
			}
		}

        function updateStatsGameSelect() {
            const select = document.getElementById('statsGameSelect');
            const currentValue = select.value;
            select.innerHTML = '<option value="">è«‹é¸æ“‡éŠæˆ²</option>';
            Object.values(games).forEach(game => {
                const option = document.createElement('option');
                option.value = game.id; option.textContent = game.name;
                select.appendChild(option);
            });
            if (currentValue) select.value = currentValue;
        }

        function searchRanking() {
            const searchText = document.getElementById('rankingSearch').value.toLowerCase();
            const rankingItems = document.querySelectorAll('#rankingList .list-item');
            let visibleCount = 0;
            
            rankingItems.forEach(item => {
                const itemName = item.querySelector('.item-name');
                if (itemName) {
                    const isVisible = itemName.textContent.toLowerCase().includes(searchText);
                    item.style.display = isVisible ? '' : 'none';
                    if (isVisible) visibleCount++;
                }
            });
            
            const gameId = document.getElementById('statsGameSelect').value;
            const totalItems = gameId ? games[gameId].items.length : 0;
            const titleText = `æ’è¡Œæ¦œ (${visibleCount}/${totalItems})`;
            document.getElementById('rankingTitle').textContent = titleText;
        }
		
		function calculateStandardDeviation(scores) {
			if (scores.length === 0) return 0;
			
			const mean = scores.reduce((sum, score) => sum + score, 0) / scores.length;
			const squareDiffs = scores.map(score => Math.pow(score - mean, 2));
			const avgSquareDiff = squareDiffs.reduce((sum, diff) => sum + diff, 0) / scores.length;
			
			return Math.sqrt(avgSquareDiff);
		}

        function toggleScoreChart(itemId) {
			const rankingItem = document.getElementById(`ranking-item-${itemId}`);
			if (!rankingItem) return;
			
			const chartContainer = rankingItem.querySelector('.score-chart-container');
			if (!chartContainer) return;
			
			if (expandedItemIds.includes(itemId)) {
				chartContainer.style.display = 'none';
				chartContainer.innerHTML = '';
				rankingItem.classList.remove('expanded');
				expandedItemIds = expandedItemIds.filter(id => id !== itemId);
				localStorage.setItem('expandedItemIds', JSON.stringify(expandedItemIds));
				return;
			}
			
			rankingItem.classList.add('expanded');
			expandedItemIds.push(itemId);
			localStorage.setItem('expandedItemIds', JSON.stringify(expandedItemIds));
			
			chartContainer.style.display = 'block';
			renderScoreChart(itemId, chartContainer);
		}

        function renderScoreChart(itemId, chartContainer) {
			const gameId = document.getElementById('statsGameSelect').value;
			if (!gameId) return;
			
			const game = games[gameId];
			const item = game.items.find(i => i.id === itemId);
			if (!item || !item.scoreHistory || !item.scoreHistory.length ) {
				chartContainer.innerHTML = '<div class="no-history-data">æ²’æœ‰æ­·å²æ•¸æ“š</div>';
				return;
			}
			
			const canvas = document.createElement('canvas');
			canvas.className = 'score-chart';
			chartContainer.innerHTML = '';
			chartContainer.appendChild(canvas);
			
			const ctx = canvas.getContext('2d');
			
			const processedData = processScoreHistory(item.scoreHistory);
			const labels = processedData.labels;
			const data = processedData.data;
			const errors = processedData.errors;
			
			new Chart(ctx, {
				type: 'line',
				data: {
					labels: labels,
					datasets: [
						{
							label: `åˆ†æ•¸è®ŠåŒ–`,
							data: data,
							borderColor: '#667eea',
							backgroundColor: '#667eea',
							borderWidth: 2,
							fill: false,
							pointRadius: 3,
							pointHoverRadius: 5,
							tension: 0
						},
						{
							label: 'èª¤å·®ä¸Šç•Œ',
							data: data.map((score, index) => score + (errors[index] || Infinity)),
							borderColor: 'rgba(255, 99, 132, 0.3)',
							backgroundColor: 'rgba(255, 99, 132, 0.1)',
							borderWidth: 1,
							fill: '-1',
							pointRadius: 0,
							pointHoverRadius: 0,
							tension: 0
						},
						{
							label: 'èª¤å·®ä¸‹ç•Œ',
							data: data.map((score, index) => score - (errors[index] || Infinity)),
							borderColor: 'rgba(255, 99, 132, 0.3)',
							backgroundColor: 'rgba(255, 99, 132, 0.1)',
							borderWidth: 1,
							fill: '-2',
							pointRadius: 0,
							pointHoverRadius: 0,
							tension: 0
						}
					]
				},
				options: {
					responsive: true,
					maintainAspectRatio: false,
					layout: {
						padding: {
							left: 20
						}
					},
					scales: {
						y: {
							beginAtZero: false,
							title: {
								display: false
							}
						},
						x: {
							title: {
								display: true,
								text: 'æ—¥æœŸ'
							},
							ticks: {
								callback: function(value, index, values) {
									const label = this.getLabelForValue(value);
									if (Array.isArray(label)) {
										return label;
									}
									return label;
								},
								maxRotation: 0,
								autoSkip: true
							}
						}
					},
					plugins: {
						title: {
							display: true,
							text: `${item.name} åˆ†æ•¸è®ŠåŒ–è¶¨å‹¢`
						},
						legend: {
							display: true
						},
						tooltip: {
							callbacks: {
								title: function(tooltipItems) {
									const label = tooltipItems[0].label;
									if (Array.isArray(label)) {
										return label.join(' ');
									}
									return label;
								}
							}
						}
					}
				},
				plugins: [{
					id: 'rotatedYAxisTitle',
					afterDraw: (chart) => {
						const ctx = chart.ctx;
						const yScale = chart.scales.y;
						
						if (!yScale) return;
						
						ctx.save();
						
						const x = yScale.left - 10 ;
						const y = yScale.top + (yScale.height / 2) - 12 ;
						
						ctx.translate(x, y);
						
						ctx.rotate(0);
						
						ctx.font = 'bold 12px sans-serif';
						ctx.fillStyle = '#666';
						ctx.textAlign = 'center';
						ctx.textBaseline = 'middle';
						
						ctx.fillText('åˆ†', 0, 0);
						ctx.fillText('æ•¸', 0, 20);
						
						ctx.restore();
					}
				}]
			});
		}

        function processScoreHistory(scoreHistory) {
			if (!scoreHistory || scoreHistory.length === 0) {
				return { labels: [], data: [], errors: [] };
			}
			
			const groupedByDate = {};
			scoreHistory.forEach(record => {
				const date = new Date(record.timestamp);
				const year = date.getFullYear();
				const month = date.getMonth() + 1;
				const day = date.getDate();
				const dateKey = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
				
				if (!groupedByDate[dateKey]) {
					groupedByDate[dateKey] = [];
				}
				groupedByDate[dateKey].push(record);
			});
			
			const dates = Object.keys(groupedByDate).sort((a, b) => {
				return new Date(a) - new Date(b);
			});
			
			const labels = [];
			const data = [];
			const errors = [];
			
			dates.forEach((date, index) => {
				const records = groupedByDate[date];
				
				if (index < dates.length - 1) {
					const lastRecord = records[records.length - 1];
					labels.push(date);
					data.push(lastRecord.score);
					errors.push(lastRecord.error || Infinity); // æ–°å¢ï¼šè®°å½•è¯¯å·®
				} else {
					records.forEach(record => {
						const time = new Date(record.timestamp);
						const hours = String(time.getHours()).padStart(2, '0');
						const minutes = String(time.getMinutes()).padStart(2, '0');
						const seconds = String(time.getSeconds()).padStart(2, '0');
						const timeString = `${hours}:${minutes}:${seconds}`;
						labels.push([date, timeString]);
						data.push(record.score);
						errors.push(record.error || Infinity); // æ–°å¢ï¼šè®°å½•è¯¯å·®
					});
				}
			});
			
			return { labels, data, errors };
		}

        function collapseAllCharts() {
            expandedItemIds = [];
            localStorage.setItem('expandedItemIds', JSON.stringify(expandedItemIds));
            loadStats();
        }
		
		function statsHelp() {
			let txt = `å‹ç‡ ç‚º åŠ æ¬Šå‹ç‡ï¼Œæ ¹æ“šæŠ•ç¥¨æ™‚çš„å‹åˆ©ç¨‹åº¦åˆ†é…ã€‚` ;
			txt += `\n\næ³¢å‹• ç‚º æœ€è¿‘ 30æ—¥ çš„ æœ€é«˜åˆ†æ•¸ - æœ€ä½åˆ†æ•¸ ã€‚` ;
			txt += `\nâ†‘â†“ä»£è¡¨æœŸé–“ä¸Šå‡æˆ–ä¸‹é™é”åˆ°æ³¢å‹•çš„ 95%ã€‚` ;
			txt += `\n\nèª¤å·®ç¯„åœä»¥ 95% ç½®ä¿¡å€é–“è¨ˆç®—ï¼Œå…¬å¼ç‚ºï¼š\n1.96 * 400 / [ âˆš(npq) ln(10) ]\nn = ç¥¨æ¬¡    p = å‹ç‡    q = æ•—ç‡ = 1-p` ;
			alert(txt);
		}

        function renderScoreDistributionChart(game) {
			const ctx = document.getElementById('scoreDistributionChart').getContext('2d');
			
			// éŠ·æ¯€ç¾æœ‰çš„åœ–è¡¨å¯¦ä¾‹
			if (scoreDistributionChart) {
				scoreDistributionChart.destroy();
			}
			
			// æ£€æŸ¥æ˜¯å¦æœ‰é¡¹ç›®
			if (!game.items || game.items.length === 0) {
				// æ¸…ç©ºç”»å¸ƒï¼Œä¸æ˜¾ç¤ºä»»ä½•å†…å®¹
				ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
				return;
			}
			
			// æŒ‰åˆ†æ•¸æ’åºé …ç›®
			const sortedItems = sortItemsByRank(game.items);
			
			// æº–å‚™æ•¸æ“š
			const labels = sortedItems.map((item, index) => index + 1); // åæ¬¡
			const scores = sortedItems.map(item => item.score);
			const errors = sortedItems.map(item => {
				const error = calculateError(item);
				return error;
			});
			
			// è¨ˆç®—yè»¸ç¯„åœ
			const firstItem = sortedItems[0];
			const lastItem = sortedItems[sortedItems.length - 1];
			const firstError = Math.min(500,calculateError(firstItem));
			const lastError = Math.min(500,calculateError(lastItem));
			const yMin = lastItem.score - lastError;
			const yMax = firstItem.score + firstError;
			
			// æ ¹æ“šå‡çµç‹€æ…‹è¨­ç½®é¡è‰²
			const pointColors = sortedItems.map(item => 
				item.frozen ? 'rgba(100, 200, 255, 1)' : 'rgba(255, 152, 61, 1)'
			);
			
			// å‰µå»ºåœ–è¡¨
			scoreDistributionChart = new Chart(ctx, {
				type: 'scatter',
				data: {
					datasets: [{
						label: 'åˆ†æ•¸',
						data: scores.map((score, index) => ({
							x: labels[index],
							y: score
						})),
						backgroundColor: pointColors,
						pointBackgroundColor: pointColors,
						pointBorderColor: pointColors,
						pointRadius: 1,
						pointHoverRadius: 1,
						pointHoverBackgroundColor: pointColors
					}]
				},
				options: {
					responsive: true,
					maintainAspectRatio: false,
					scales: {
						x: {
							display: false, // éš±è—xè»¸
							title: {
								display: false
							},
							min: 1,
							max: sortedItems.length,
							reverse: false
						},
						y: {
							display: false, // éš±è—yè»¸
							title: {
								display: false
							},
							min: yMin,
							max: yMax
						}
					},
					plugins: {
						legend: {
							display: false // éš±è—åœ–ä¾‹
						},
						title: {
							display: false // éš±è—æ¨™é¡Œ
						},
						tooltip: {
							enabled: false // é¼ æ ‡æ‚¬åœæ—¶ä¸æ˜¾ç¤ºä»»ä½•ä¿¡æ¯
						}
					},
					elements: {
						line: {
							tension: 0 // ç¦ç”¨å¹³æ»‘æ›²ç·š
						}
					},
					interaction: {
						mode: 'nearest',
						intersect: false
					}
				},
				plugins: [{
					id: 'errorBars',
					beforeDatasetsDraw(chart, args, options) {
						const { ctx } = chart;
						const meta = chart.getDatasetMeta(0);
						const xScale = chart.scales.x;
						const yScale = chart.scales.y;
						
						ctx.save();
						ctx.lineWidth = 1;
						
						meta.data.forEach((point, index) => {
							const x = xScale.getPixelForValue(labels[index]);
							const y = yScale.getPixelForValue(scores[index]);
							const error = errors[index];
							const item = sortedItems[index];
							
							// æ ¹æ“šå‡çµç‹€æ…‹è¨­ç½®èª¤å·®ç·šé¡è‰²
							ctx.strokeStyle = item.frozen ? 'rgba(100, 200, 255, 0.3)' : '#3efa8d';
							
							if (error > 0) {
								const errorTop = yScale.getPixelForValue(scores[index] + error);
								const errorBottom = yScale.getPixelForValue(scores[index] - error);
								
								ctx.beginPath();
								ctx.moveTo(x, errorTop);
								ctx.lineTo(x, errorBottom);
								ctx.stroke();
								
								ctx.beginPath();
								ctx.moveTo(x - 3, errorTop);
								ctx.lineTo(x + 3, errorTop);
								ctx.stroke();
								
								ctx.beginPath();
								ctx.moveTo(x - 3, errorBottom);
								ctx.lineTo(x + 3, errorBottom);
								ctx.stroke();
							}
						});
						
						ctx.restore();
					}
				}]
			});
		}

        // æ”¾å¤§åˆ†æ•¸åˆ†å¸ƒåœ–è¡¨
        function toggleScoreDistributionChart(show) {
            const modal = document.getElementById('scoreDistributionModal');
            
            if (show) {
                modal.classList.remove('hidden');
                renderLargeScoreDistributionChart();
            } else {
                modal.classList.add('hidden');
                if (scoreDistributionChartLarge) {
                    scoreDistributionChartLarge.destroy();
                    scoreDistributionChartLarge = null;
                }
            }
        }

        function renderLargeScoreDistributionChart() {
			const ctx = document.getElementById('scoreDistributionChartLarge').getContext('2d');
			const gameId = document.getElementById('statsGameSelect').value;
			if (!gameId) return;
			
			const game = games[gameId];
			if (!game.items.length) return;
			
			const sortedItems = sortItemsByRank(game.items);
			
			// æº–å‚™æ•¸æ“š
			const labels = sortedItems.map((item, index) => index + 1); // åæ¬¡
			const scores = sortedItems.map(item => item.score);
			const errors = sortedItems.map(item => {
				const error = calculateError(item);
				return error;
			});
			
			// è¨ˆç®—yè»¸ç¯„åœ
			const firstItem = sortedItems[0];
			const lastItem = sortedItems[sortedItems.length - 1];
			const firstError = Math.min(500,calculateError(firstItem));
			const lastError = Math.min(500,calculateError(lastItem));
			const yMin = Math.floor(lastItem.score - lastError);
			const yMax = Math.ceil(firstItem.score + firstError);
			
			// è¨ˆç®—å¹³å‡å€¼å’Œæ¨™æº–å·®
			const avgScore = game.items.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : 1500;
			const scoreStdDev = calculateStandardDeviation(scores);
			const avgPlusStdDev = avgScore + scoreStdDev;
			const avgMinusStdDev = avgScore - scoreStdDev;
			const avgPlus2StdDev = avgScore + 2 * scoreStdDev;
			const avgMinus2StdDev = avgScore - 2 * scoreStdDev;
			
			// æ ¹æ“šå‡çµç‹€æ…‹è¨­ç½®é¡è‰²
			const pointColors = sortedItems.map(item => 
				item.frozen ? 'rgba(100, 200, 255, 1)' : 'rgba(255, 152, 61, 1)'
			);
			
			// å‰µå»ºå¤§åœ–è¡¨
			scoreDistributionChartLarge = new Chart(ctx, {
				type: 'scatter',
				data: {
					datasets: [{
						label: 'åˆ†æ•¸',
						data: scores.map((score, index) => ({
							x: labels[index],
							y: score
						})),
						backgroundColor: pointColors,
						pointBackgroundColor: pointColors,
						pointBorderColor: pointColors,
						pointRadius: 3,
						pointHoverRadius: 5,
						pointHoverBackgroundColor: pointColors
					}]
				},
				options: {
					responsive: true,
					maintainAspectRatio: false,
					layout: {
						padding: {
							left: 18,
						}
					},
					scales: {
						x: {
							title: {
								display: true,
								text: 'æ’å'
							},
							reverse: false,
							min: 0,
							max: sortedItems.length + 1
						},
						y: {
							title: {
								display: false
							},
							min: yMin,
							max: yMax
						}
					},
					plugins: {
						legend: {
							display: true
						},
						title: {
							display: true,
							text: 'åˆ†æ•¸åˆ†å¸ƒåœ–'
						},
						tooltip: {
							enabled: true,
							callbacks: {
								label: function(context) {
									const index = context.dataIndex;
									const item = sortedItems[index];
									const error = errors[index];
									const winRate = (calculateWinRate(item) * 100).toFixed(1);
									const recentVolatility = calculateRecentVolatility(item);
									const volatilitySymbol = getRecentVolatilitySymbol(item);
									// const frozenStatus = item.frozen ? ' (å‡çµ)' : '';
									return [
										`é …ç›®: ${item.name}`,
										`æ’å: ${index + 1}`,
										`åˆ†æ•¸: ${item.score}Â±${error === Infinity ? 'âˆ' : Math.round(error)}`,
										`åŠ æ¬Šå‹ç‡: ${winRate}%`,
										`æœˆåº¦æ³¢å‹•: ${recentVolatility}${volatilitySymbol}`,
										`ç¥¨æ¬¡: ${item.votes}`
									];
								}
							}
						}
					},
					elements: {
						line: {
							tension: 0
						}
					}
				},
				plugins: [{
					id: 'rotatedYAxisTitle',
					afterDraw: (chart) => {
						const ctx = chart.ctx;
						const yScale = chart.scales.y;
						
						if (!yScale) return;
						
						ctx.save();

						const x = yScale.left - 10;
						const y = yScale.top + (yScale.height / 2) - 12;
						
						ctx.translate(x, y);
						
						ctx.rotate(0);
						
						ctx.font = '12px Microsoft JhengHei';  // å¢å¤§å­—é«”
						ctx.fillStyle = '#666';
						ctx.textAlign = 'center';
						ctx.textBaseline = 'middle';
						
						ctx.fillText('åˆ†', 0, 0);
						ctx.fillText('æ•¸', 0, 20);
						
						ctx.restore();
					}
				}, {
					id: 'errorBarsLarge',
					beforeDatasetsDraw(chart, args, options) {
						const { ctx } = chart;
						const meta = chart.getDatasetMeta(0);
						const xScale = chart.scales.x;
						const yScale = chart.scales.y;
						
						ctx.save();
						ctx.lineWidth = 2;
						
						meta.data.forEach((point, index) => {
							const x = xScale.getPixelForValue(labels[index]);
							const y = yScale.getPixelForValue(scores[index]);
							const error = errors[index];
							const item = sortedItems[index];
							
							// æ ¹æ“šå‡çµç‹€æ…‹è¨­ç½®èª¤å·®ç·šé¡è‰²
							ctx.strokeStyle = item.frozen ? 'rgba(100, 200, 255, 0.5)' : '#3efa8d';
							
							if (error > 0) {
								const errorTop = yScale.getPixelForValue(scores[index] + error);
								const errorBottom = yScale.getPixelForValue(scores[index] - error);
								
								ctx.beginPath();
								ctx.moveTo(x, errorTop);
								ctx.lineTo(x, errorBottom);
								ctx.stroke();
								
								ctx.beginPath();
								ctx.moveTo(x - 5, errorTop);
								ctx.lineTo(x + 5, errorTop);
								ctx.stroke();
								
								ctx.beginPath();
								ctx.moveTo(x - 5, errorBottom);
								ctx.lineTo(x + 5, errorBottom);
								ctx.stroke();
							}
						});
						
						ctx.restore();
					}
				}, {
					id: 'stdDevLines',
					afterDatasetsDraw(chart, args, options) {
						const { ctx } = chart;
						const yScale = chart.scales.y;
						const xScale = chart.scales.x;
						
						// ç¹ªè£½å¹³å‡å€¼ Â± 1å€‹æ¨™æº–å·®å’Œ Â± 2å€‹æ¨™æº–å·®çš„æ°´å¹³ç·š
						ctx.save();
						
						// å¹³å‡å€¼ç·š - è—è‰²è™›ç·š
						const avgPixel = yScale.getPixelForValue(avgScore);
						ctx.strokeStyle = 'rgba(0, 0, 255, 0.3)';
						ctx.setLineDash([5, 5]);
						ctx.lineWidth = 2;
						ctx.beginPath();
						ctx.moveTo(xScale.left, avgPixel);
						ctx.lineTo(xScale.right, avgPixel);
						ctx.stroke();
						
						// å¹³å‡å€¼ + 2å€æ¨™æº–å·®ç·š - ç´…è‰²è™›ç·š
						const avgPlus2StdDevPixel = yScale.getPixelForValue(avgPlus2StdDev);
						ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
						ctx.setLineDash([5, 5]);
						ctx.lineWidth = 1.5;
						ctx.beginPath();
						ctx.moveTo(xScale.left, avgPlus2StdDevPixel);
						ctx.lineTo(xScale.right, avgPlus2StdDevPixel);
						ctx.stroke();
						
						// å¹³å‡å€¼ + æ¨™æº–å·®ç·š - ç´…è‰²è™›ç·š
						const avgPlusStdDevPixel = yScale.getPixelForValue(avgPlusStdDev);
						ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
						ctx.setLineDash([5, 5]);
						ctx.lineWidth = 1.5;
						ctx.beginPath();
						ctx.moveTo(xScale.left, avgPlusStdDevPixel);
						ctx.lineTo(xScale.right, avgPlusStdDevPixel);
						ctx.stroke();
						
						// å¹³å‡å€¼ - æ¨™æº–å·®ç·š - ç´…è‰²è™›ç·š
						const avgMinusStdDevPixel = yScale.getPixelForValue(avgMinusStdDev);
						ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
						ctx.setLineDash([5, 5]);
						ctx.lineWidth = 1.5;
						ctx.beginPath();
						ctx.moveTo(xScale.left, avgMinusStdDevPixel);
						ctx.lineTo(xScale.right, avgMinusStdDevPixel);
						ctx.stroke();
						
						// å¹³å‡å€¼ - 2å€æ¨™æº–å·®ç·š - ç´…è‰²è™›ç·š
						const avgMinus2StdDevPixel = yScale.getPixelForValue(avgMinus2StdDev);
						ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
						ctx.setLineDash([5, 5]);
						ctx.lineWidth = 1.5;
						ctx.beginPath();
						ctx.moveTo(xScale.left, avgMinus2StdDevPixel);
						ctx.lineTo(xScale.right, avgMinus2StdDevPixel);
						ctx.stroke();
						
						// æ·»åŠ æ¨™ç±¤
						ctx.fillStyle = 'rgba(0, 0, 255, 0.7)';
						ctx.font = 'bold 12px Microsoft JhengHei';
						ctx.textAlign = 'right';
						ctx.fillText(`Î¼`, xScale.left + 15, avgPixel + 10);
						
						ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
						ctx.fillText(`Î¼ + 2Ïƒ`, xScale.right - 10, avgPlus2StdDevPixel - 10);
						
						ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
						ctx.fillText(`Î¼ + Ïƒ`, xScale.right - 10, avgPlusStdDevPixel - 10);
						
						ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
						ctx.fillText(`Î¼ - Ïƒ`, xScale.left + 35, avgMinusStdDevPixel + 10);
						
						ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
						ctx.fillText(`Î¼ - 2Ïƒ`, xScale.left + 40, avgMinus2StdDevPixel + 10);
						
						ctx.restore();
					}
				}]
			});
		}

        // æ’­æ”¾æ­·å²æ’ä½å‹•ç•«
        function playRankingAnimation() {
			const gameId = document.getElementById('statsGameSelect').value;
			if (!gameId) {
				alert('è«‹å…ˆé¸æ“‡éŠæˆ²');
				return;
			}
			
			// æ¸…ç©ºä¹‹å‰çš„åŠ¨ç”»çŠ¶æ€
			animationManager.clearQueue();
			itemPositions = {};
			itemScores = {};
			itemErrors = {};
			itemBarLengths = {};
			itemErrorLengths = {};
			
			// åˆå§‹åŒ–æ’åå‹•ç•«æ•¸æ“š
			initRankingAnimationData(gameId);
			
			// é¡¯ç¤ºå‹•ç•«æ¨¡æ…‹æ¡†
			const modal = document.getElementById('rankingAnimationModal');
			modal.classList.remove('hidden');
			
			// åˆå§‹åŒ–Canvas
			rankingAnimationCanvas = document.getElementById('rankingAnimationCanvas');
			rankingAnimationCtx = rankingAnimationCanvas.getContext('2d');
			
			// è¨­ç½®Canvaså¤§å°
			updateCanvasSize();
			
			// åˆå§‹åŒ–æ‰€æœ‰æ»‘å¡Š
			const frameSlider = document.getElementById('frameSlider');
			const speedSlider = document.getElementById('speedSlider');
			const itemCountSlider = document.getElementById('itemCountSlider');
			
			frameSlider.max = rankingAnimationData.length - 1;
			frameSlider.value = 0;
			updateFrameSliderValue();
			
			speedSlider.value = 1;
			updateSpeedSliderValue();
			
			itemCountSlider.value = rankingItemCount;
			updateItemCountSliderValue();
			
			// è¨­ç½®äº‹ä»¶ç›£è½å™¨ - ä½¿ç”¨é˜²æŠ–å’ŒåŠ¨ç”»é˜Ÿåˆ—
			let sliderTimeout;
			frameSlider.addEventListener('input', function() {
				if (rankingAnimationInterval) {
					clearInterval(rankingAnimationInterval);
					rankingAnimationInterval = null;
					document.getElementById('playPauseBtn').textContent = 'æ’­æ”¾';
				}
				
				clearTimeout(sliderTimeout);
				sliderTimeout = setTimeout(() => {
					const targetFrame = parseInt(this.value);
					animationManager.addToQueue((complete) => {
						currentRankingFrame = targetFrame;
						triggerAnimationUpdate();
						updateFrameSliderValue();
						
						// ç­‰å¾…åŠ¨ç”»å®Œæˆ
						waitForAnimationCompletion(() => {
							complete();
						});
					});
				}, 100); // å¢åŠ å»¶è¿Ÿå‡å°‘é¢‘ç¹è§¦å‘
			});
			
			speedSlider.addEventListener('input', function() {
				rankingAnimationSpeed = Math.round(1000 / parseInt(this.value));
				updateSpeedSliderValue();
				
				if (rankingAnimationInterval) {
					clearInterval(rankingAnimationInterval);
					rankingAnimationInterval = setInterval(() => {
						animationManager.addToQueue((complete) => {
							advanceRankingFrame();
							waitForAnimationCompletion(() => {
								complete();
							});
						});
					}, rankingAnimationSpeed);
				}
			});
			
			// æ·»åŠ é …ç›®æ•¸æ»‘å¡Šäº‹ä»¶ç›£è½å™¨
			itemCountSlider.addEventListener('input', function() {
				rankingItemCount = parseInt(this.value);
				updateItemCountSliderValue();
				
				animationManager.addToQueue((complete) => {
					// æ ¹æ“šé …ç›®æ•¸æ”¹è®Šæ¯è¡Œé«˜åº¦
					RANKING_ITEM_HEIGHT = Math.max(15, 60 - rankingItemCount);
					
					// é‡æ–°åˆå§‹åŒ–å‹•ç•«æ•¸æ“š
					initRankingAnimationData(gameId);
					
					// æ›´æ–°Canvaså¤§å°
					updateCanvasSize();
					
					// é‡ç¹ªç•¶å‰å¹€
					triggerAnimationUpdate();
					drawRankingFrame(currentRankingFrame);
					
					complete();
				});
			});
			
			// æ·»åŠ çª—å£å¤§å°æ”¹è®Šäº‹ä»¶ç›£è½
			window.addEventListener('resize', handleResize);
			
			// èµ·å§‹å‹•ç•« - ä½¿ç”¨åŠ¨ç”»é˜Ÿåˆ—ç¡®ä¿é¡ºåºæ‰§è¡Œ
			animationManager.addToQueue((complete) => {
				triggerAnimationUpdate();
				firstRankingFrame();
				complete();
			});
		}
		
		// ç­‰å¾…åŠ¨ç”»å®Œæˆçš„å‡½æ•°
		function waitForAnimationCompletion(callback, maxWaitTime = 5000) {
			const startTime = Date.now();
			
			function checkCompletion() {
				const allAnimationsComplete = checkAllAnimationsComplete();
				
				if (allAnimationsComplete || (Date.now() - startTime) > maxWaitTime) {
					callback();
				} else {
					requestAnimationFrame(checkCompletion);
				}
			}
			
			checkCompletion();
		}
		
		// æ£€æŸ¥æ‰€æœ‰åŠ¨ç”»æ˜¯å¦å®Œæˆçš„å‡½æ•°
		function checkAllAnimationsComplete() {
			// æ£€æŸ¥ä½ç½®åŠ¨ç”»
			const positionsComplete = Object.keys(itemPositions).every(itemId => {
				const pos = itemPositions[itemId];
				return Math.abs(pos.targetY - pos.currentY) <= 1;
			});
			
			// æ£€æŸ¥åˆ†æ•°åŠ¨ç”»
			const scoresComplete = Object.keys(itemScores).every(itemId => {
				const score = itemScores[itemId];
				return Math.abs(score.targetScore - score.currentScore) <= 1;
			});
			
			// æ£€æŸ¥æŸ±å½¢é•¿åº¦åŠ¨ç”»
			const barsComplete = Object.keys(itemBarLengths).every(itemId => {
				const bar = itemBarLengths[itemId];
				return Math.abs(bar.targetLength - bar.currentLength) <= 1;
			});
			
			return positionsComplete && scoresComplete && barsComplete;
		}
		
		
		function updateItemCountSliderValue() {
			const itemCountSlider = document.getElementById('itemCountSlider');
			const itemCountValue = document.getElementById('itemCountValue');
			itemCountValue.textContent = itemCountSlider.value;
		}
		
		// è§¦å‘åŠ¨ç”»æ›´æ–°çš„å‡½æ•°
		function triggerAnimationUpdate() {
			// å¼·åˆ¶æ›´æ–°æ‰€æœ‰å‹•ç•«å±¬æ€§çš„ç›®æ¨™å€¼
			const frame = rankingAnimationData[currentRankingFrame];
			
			// è¨ˆç®—æœ€å¤§åˆ†æ•¸ç”¨æ–¼æŸ±å½¢é•·åº¦
			const globalMaxScore = frame.items.length > 0 ? frame.items[0].score + 500 : 2000;
			const barWidth = rankingAnimationCanvas.width - 80;
			
			frame.items.forEach((item, index) => {
				const targetY = RANKING_START_Y + index * RANKING_ITEM_HEIGHT;
				
				// å°æ–¼èµ·å§‹å‹•ç•«ï¼Œè®“æ‰€æœ‰é …ç›®å¾åº•éƒ¨é€²å…¥
				if (currentRankingFrame === 0) {
					// é‡ç½®ä½ç½®ï¼Œè®“é …ç›®å¾ç•«å¸ƒåº•éƒ¨é–‹å§‹å‹•ç•«
					if (itemPositions[item.id]) {
						itemPositions[item.id].currentY = rankingAnimationCanvas.height + 100;
					}
				}
				
				// æ›´æ–°ä½ç½®ç›®æ¨™
				getAnimatedPosition(item.id, targetY, currentRankingFrame);
				
				// æ›´æ–°åˆ†æ•¸ç›®æ¨™ï¼ˆå¾0é–‹å§‹å‹•ç•«åˆ°å¯¦éš›åˆ†æ•¸ï¼‰
				if (!itemScores[item.id]) {
					itemScores[item.id] = {
						currentScore: 0,
						targetScore: item.score,
						frameIndex: currentRankingFrame
					};
				} else {
					itemScores[item.id].targetScore = item.score;
					itemScores[item.id].frameIndex = currentRankingFrame;
				}
				
				// æ›´æ–°èª¤å·®ç›®æ¨™
				if (!itemErrors[item.id]) {
					itemErrors[item.id] = {
						currentError: 0,
						targetError: item.error,
						frameIndex: currentRankingFrame
					};
				} else {
					itemErrors[item.id].targetError = item.error;
					itemErrors[item.id].frameIndex = currentRankingFrame;
				}
				
				// æ›´æ–°æŸ±å½¢é•·åº¦ç›®æ¨™ï¼ˆå¾0é–‹å§‹å‹•ç•«ï¼‰
				const targetBarLength = (item.score / globalMaxScore) * barWidth;
				if (!itemBarLengths[item.id]) {
					itemBarLengths[item.id] = {
						currentLength: 0,
						targetLength: targetBarLength,
						frameIndex: currentRankingFrame
					};
				} else {
					itemBarLengths[item.id].targetLength = targetBarLength;
					itemBarLengths[item.id].frameIndex = currentRankingFrame;
				}
				
				// æ›´æ–°èª¤å·®é•·åº¦ç›®æ¨™ï¼ˆå¾0é–‹å§‹å‹•ç•«ï¼‰
				const targetErrorLength = ((item.error || 0) / globalMaxScore) * barWidth;
				if (!itemErrorLengths[item.id]) {
					itemErrorLengths[item.id] = {
						currentLength: 0,
						targetLength: targetErrorLength,
						frameIndex: currentRankingFrame
					};
				} else {
					itemErrorLengths[item.id].targetLength = targetErrorLength;
					itemErrorLengths[item.id].frameIndex = currentRankingFrame;
				}
			});
			
			// å•Ÿå‹•å‹•ç•«
			if (!animationFrameId) {
				startPositionAnimation();
			}
		}
		
		// æ›´æ–°å…¶ä»–åŠ¨ç”»å±æ€§çš„è¾…åŠ©å‡½æ•°
		function updateOtherAnimations() {
			let needsUpdate = false;
			
			// æ›´æ–°åˆ†æ•°
			Object.keys(itemScores).forEach(itemId => {
				const score = itemScores[itemId];
				const diff = score.targetScore - score.currentScore;
				
				if (Math.abs(diff) > 0.1) { // é™ä½é˜ˆå€¼æé«˜ç²¾åº¦
					score.currentScore += diff * 0.08; // è°ƒæ•´é€Ÿåº¦
					needsUpdate = true;
				} else {
					score.currentScore = score.targetScore;
				}
			});
			
			// æ›´æ–°è¯¯å·®
			Object.keys(itemErrors).forEach(itemId => {
				const error = itemErrors[itemId];
				const diff = error.targetError - error.currentError;
				
				if (Math.abs(diff) > 0.1) {
					error.currentError += diff * 0.08;
					needsUpdate = true;
				} else {
					error.currentError = error.targetError;
				}
			});
			
			// æ›´æ–°æŸ±å½¢é•¿åº¦
			Object.keys(itemBarLengths).forEach(itemId => {
				const bar = itemBarLengths[itemId];
				const diff = bar.targetLength - bar.currentLength;
				
				if (Math.abs(diff) > 0.1) {
					bar.currentLength += diff * 0.08;
					needsUpdate = true;
				} else {
					bar.currentLength = bar.targetLength;
				}
			});
			
			// æ›´æ–°è¯¯å·®é•¿åº¦
			Object.keys(itemErrorLengths).forEach(itemId => {
				const errorLength = itemErrorLengths[itemId];
				const diff = errorLength.targetLength - errorLength.currentLength;
				
				if (Math.abs(diff) > 0.1) {
					errorLength.currentLength += diff * 0.08;
					needsUpdate = true;
				} else {
					errorLength.currentLength = errorLength.targetLength;
				}
			});
			
			return needsUpdate;
		}
		
		function firstRankingFrame() {
			if (animationManager.isBusy()) return;
			
			animationManager.addToQueue((complete) => {
				if (rankingAnimationInterval) {
					clearInterval(rankingAnimationInterval);
					rankingAnimationInterval = null;
					document.getElementById('playPauseBtn').textContent = 'æ’­æ”¾';
				}
				
				currentRankingFrame = 0;
				document.getElementById('frameSlider').value = 0;
				updateFrameSliderValue();
				
				triggerAnimationUpdate();
				drawRankingFrame(currentRankingFrame);
				
				waitForAnimationCompletion(() => {
					complete();
				});
			});
		}

		function lastRankingFrame() {
			if (animationManager.isBusy()) return;
			
			animationManager.addToQueue((complete) => {
				if (rankingAnimationInterval) {
					clearInterval(rankingAnimationInterval);
					rankingAnimationInterval = null;
					document.getElementById('playPauseBtn').textContent = 'æ’­æ”¾';
				}
				
				currentRankingFrame = rankingAnimationData.length - 1;
				document.getElementById('frameSlider').value = currentRankingFrame;
				updateFrameSliderValue();
				
				triggerAnimationUpdate();
				drawRankingFrame(currentRankingFrame);
				
				waitForAnimationCompletion(() => {
					complete();
				});
			});
		}

		function updateCanvasSize() {
			if (!rankingAnimationCanvas) return;
			
			const container = document.querySelector('.ranking-animation-content');
			
			// æ ¹æ®é¡¹ç›®æ•°é‡å’Œçª—å£å¤§å°è‡ªåŠ¨è°ƒæ•´å°ºå¯¸
			const itemCount = rankingAnimationData[0] ? rankingAnimationData[0].items.length : 10;
			const baseHeight = 80 + (itemCount * 30); // æ ‡é¢˜ + é¡¹ç›® + æ§åˆ¶åŒºåŸŸ
			
			const maxWidth = window.innerWidth * 0.9;
			const maxHeight = window.innerHeight * 0.9;
			
			const calculatedWidth = Math.min(container.clientWidth, maxWidth);
			const calculatedHeight = Math.min(baseHeight, maxHeight);
			
			rankingAnimationCanvas.width = calculatedWidth;
			rankingAnimationCanvas.height = calculatedHeight;
		}
		
		const style = document.createElement('style');
		style.textContent = `
			.ranking-animation-modal {
				background-color: rgba(0,0,0,0.8) !important;
			}
			.ranking-animation-content {
				background: white !important;
				border-radius: 15px !important;
				padding: 0px !important;
				max-width: 95vw !important;
				max-height: 95vh !important;
				overflow: hidden !important;
				display: flex !important;
				flex-direction: column !important;
				align-items: center !important;
			}
			.ranking-animation-canvas {
				max-width: 100% !important;
				max-height: 70vh !important;
				background: white !important;
				border: 1px solid #e2e8f0 !important;
				border-radius: 10px !important;
			}
			.ranking-animation-sliders {
				width: 100% !important;
				max-width: 600px !important;
				margin: 0px 0 !important;
				padding: 0px !important;
			}
			.ranking-animation-controls {
				width: 100% !important;
				max-width: 600px !important;
				display: flex !important;
				justify-content: center !important;
				gap: 15px !important;
				flex-wrap: wrap !important;
			}
		`;
		document.head.appendChild(style);
		
		function handleResize() {
			updateCanvasSize();
			// è§¸ç™¼å‹•ç•«ä»¥é©æ‡‰æ–°çš„è¦–çª—å¤§å°
			triggerAnimationUpdate();
			drawRankingFrame(currentRankingFrame);
		}

        function updateFrameSliderValue() {
            const frameSlider = document.getElementById('frameSlider');
            const frameValue = document.getElementById('frameValue');
            frameValue.textContent = `${currentRankingFrame + 1}/${rankingAnimationData.length}`;
        }

        function updateSpeedSliderValue() {
            const speedSlider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            speedValue.textContent = `${speedSlider.value} ç•«æ ¼/ç§’`;
        }

        function initRankingAnimationData(gameId) {
			const game = games[gameId];
			rankingAnimationData = [];
			
			// ç²å–æ‰€æœ‰é …ç›®çš„æ‰€æœ‰æ™‚é–“é»ï¼ˆè½‰æ›ç‚ºç•¶åœ°æ™‚å€çš„æ—¥æœŸï¼‰
			const allDates = new Set();
			const itemDateMap = new Map(); // æ¯å€‹é …ç›®å°æ‡‰çš„æ—¥æœŸå’Œæ•¸æ“š
			
			// åˆå§‹åŒ–æ¯å€‹é …ç›®çš„æ•¸æ“šçµæ§‹
			game.items.forEach(item => {
				if (!item.scoreHistory || item.scoreHistory.length === 0) {
					// å¦‚æœæ²’æœ‰æ­·å²æ•¸æ“šï¼Œæ·»åŠ åˆå§‹ç‹€æ…‹
					if (!itemDateMap.has(item.id)) {
						itemDateMap.set(item.id, []);
					}
					const initialDate = new Date(item.addedTime || Date.now());
					const dateKey = initialDate.toLocaleDateString('zh-TW');
					allDates.add(dateKey);
					itemDateMap.get(item.id).push({
						date: dateKey,
						score: 1500,
						error: undefined,
						timestamp: initialDate.getTime()
					});
					return;
				}
				
				// è™•ç†æœ‰æ­·å²æ•¸æ“šçš„é …ç›®
				const dateScoreMap = new Map();
				
				// æŒ‰ç•¶åœ°æ™‚å€çš„æ—¥æœŸåˆ†çµ„ï¼Œä¸¦åªä¿ç•™æ¯å€‹æ—¥æœŸæœ€å¾Œçš„è¨˜éŒ„
				item.scoreHistory.forEach(record => {
					const recordDate = new Date(record.timestamp);
					const dateKey = recordDate.toLocaleDateString('zh-TW');
					
					// å¦‚æœåŒä¸€å¤©æœ‰å¤šå€‹è¨˜éŒ„ï¼Œåªä¿ç•™æ™‚é–“æˆ³æœ€å¤§çš„ï¼ˆæœ€å¾Œçš„è¨˜éŒ„ï¼‰
					if (!dateScoreMap.has(dateKey) || record.timestamp > dateScoreMap.get(dateKey).timestamp) {
						dateScoreMap.set(dateKey, {
							date: dateKey,
							score: record.score,
							error: record.error,
							timestamp: record.timestamp
						});
					}
					
					allDates.add(dateKey);
				});
				
				// æŒ‰æ™‚é–“æ’åº
				const sortedRecords = Array.from(dateScoreMap.values()).sort((a, b) => a.timestamp - b.timestamp);
				itemDateMap.set(item.id, sortedRecords);
			});
			
			// ç”Ÿæˆé€£çºŒçš„æ—¥æœŸåºåˆ—ï¼ˆç•¶åœ°æ™‚å€ï¼‰
			const sortedDates = Array.from(allDates).sort((a, b) => {
				return new Date(a) - new Date(b);
			});
			
			if (sortedDates.length === 0) {
				// å¦‚æœæ²’æœ‰æ—¥æœŸæ•¸æ“šï¼Œå‰µå»ºåˆå§‹ç•«æ ¼
				const initialItems = game.items.map(item => ({
					id: item.id,
					name: item.name,
					score: 1500,
					error: undefined,
					votes: 0,
					wins: 0,
					losses: 0,
					addedTime: item.addedTime || Date.now()
				}));
				
				// ä½¿ç”¨å‹•æ…‹é …ç›®æ•¸ï¼Œä¸¦æŒ‰åˆ†æ•¸å’Œèª¤å·®æ’åº
				const rankedItems = sortItemsByRank(initialItems).slice(0, rankingItemCount);
				
				rankingAnimationData.push({
					timestamp: Date.now(),
					date: new Date(),
					items: rankedItems,
					frameIndex: 0
				});
				return;
			}
			
			// ç‚ºæ¯å€‹æ—¥æœŸå‰µå»ºå¿«ç…§
			const dateSnapshots = [];
			const itemLastScores = new Map(); // è¨˜éŒ„æ¯å€‹é …ç›®çš„æœ€å¾Œå·²çŸ¥åˆ†æ•¸å’Œèª¤å·®
			
			// åˆå§‹åŒ–æ‰€æœ‰é …ç›®çš„åˆå§‹ç‹€æ…‹
			game.items.forEach(item => {
				itemLastScores.set(item.id, { score: 1500, error: undefined });
			});
			
			sortedDates.forEach((dateKey, dateIndex) => {
				const currentDate = new Date(dateKey);
				const snapshotItems = [];
				
				// ç‚ºæ¯å€‹é …ç›®ç²å–ç•¶å‰æ—¥æœŸçš„æ•¸æ“š
				game.items.forEach(item => {
					const itemRecords = itemDateMap.get(item.id);
					let currentScore = itemLastScores.get(item.id).score;
					let currentError = itemLastScores.get(item.id).error;
					
					if (itemRecords) {
						// æŸ¥æ‰¾ç•¶å‰æ—¥æœŸçš„è¨˜éŒ„ï¼ˆä½¿ç”¨ç•¶å¤©æœ€å¾Œçš„æ•¸æ“šï¼‰
						const currentRecord = itemRecords.find(record => record.date === dateKey);
						if (currentRecord) {
							currentScore = currentRecord.score;
							currentError = currentRecord.error;
							// æ›´æ–°æœ€å¾Œå·²çŸ¥ç‹€æ…‹
							itemLastScores.set(item.id, { score: currentScore, error: currentError });
						}
						// å¦‚æœæ²’æœ‰ç•¶å‰æ—¥æœŸçš„è¨˜éŒ„ï¼Œä¿æŒä¸Šæ¬¡çš„ç‹€æ…‹ï¼ˆè‡ªå‹•è¤‡è£½å‰ä¸€æ—¥ï¼‰
					}
					
					snapshotItems.push({
						id: item.id,
						name: item.name,
						score: currentScore,
						error: currentError,
						votes: 0, // é€™äº›å­—æ®µåœ¨å‹•ç•«ä¸­ä¸éœ€è¦
						wins: 0,
						losses: 0,
						addedTime: item.addedTime || Date.now()
					});
				});
				
				// æŒ‰åˆ†æ•¸å’Œèª¤å·®æ’åºä¸¦å–å‰ rankingItemCount å
				// ä½¿ç”¨ sortItemsByRank å‡½æ•¸ç¢ºä¿æ’åºè¦å‰‡ä¸€è‡´ï¼šåˆ†æ•¸å„ªå…ˆï¼ˆé™åºï¼‰ï¼Œèª¤å·®å…¶æ¬¡ï¼ˆå‡åºï¼‰
				const rankedItems = sortItemsByRank(snapshotItems).slice(0, rankingItemCount);
				
				dateSnapshots.push({
					timestamp: currentDate.getTime(),
					date: currentDate,
					items: rankedItems,
					frameIndex: dateIndex
				});
			});
			
			rankingAnimationData = dateSnapshots;
			currentRankingFrame = 0;
		}
		
        function drawRankingFrame(frameIndex) {
			if (!rankingAnimationCtx || frameIndex >= rankingAnimationData.length) return;
			
			const frame = rankingAnimationData[frameIndex];
			const canvas = rankingAnimationCanvas;
			const ctx = rankingAnimationCtx;
			
			// æ¸…é™¤Canvas
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			
			// ç¹ªè£½ç™½è‰²èƒŒæ™¯
			ctx.fillStyle = '#ffffff';
			ctx.fillRect(0, 0, canvas.width, canvas.height);

			// ç¹ªè£½æ¨™é¡Œ
			ctx.fillStyle = '#333';
			ctx.font = 'bold 16px Microsoft JhengHei';
			ctx.textAlign = 'center';
			ctx.fillText('æ­·å²æ’ä½å‹•ç•«', canvas.width / 2, 30);
			
			// ç¹ªè£½æ—¥æœŸ
			const date = frame.date;
			const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
			ctx.fillStyle = '#666';
			ctx.font = '18px Microsoft JhengHei';
			ctx.textAlign = 'center';
			ctx.fillText(dateString, canvas.width / 2, 60);

			// ç¹ªè£½æ’åé …ç›®
			// è¨ˆç®—æŸ±å½¢æœ€å¤§å€¼ï¼šç¬¬ä¸€åçš„åˆ†æ•¸ + 500ï¼Œæœ€å°å€¼ç‚º0
			const globalMaxScore = frame.items.length > 0 ? frame.items[0].score + 500 : 2000;
			const startX = 70;
			const barWidth = canvas.width - 80;
			
			// ç¹ªè£½æ‰€æœ‰é …ç›®
			frame.items.forEach((item, index) => {
				let terms = document.getElementById('itemCountSlider').value ;
				let targetY ;
				let currentY ;
				let barHeight ;
				let rankHeight ; 
				let titleHeight ; 
				let scoreHeight ; 
				if( terms > 30 ) // å¤šæ–¼30é …
				{
					RANKING_ITEM_HEIGHT = 15 ;
					targetY = RANKING_START_Y + index * RANKING_ITEM_HEIGHT;
					currentY = getAnimatedPosition(item.id, targetY, frameIndex);
					barHeight = RANKING_ITEM_HEIGHT - 2 ;
					rankHeight =  12 ; 
					titleHeight = 12 ; 
					scoreHeight = 12 ; 
				}
				else
				{
					RANKING_ITEM_HEIGHT = 20 ;
					targetY = RANKING_START_Y + index * RANKING_ITEM_HEIGHT;
					currentY = getAnimatedPosition(item.id, targetY, frameIndex);
					barHeight = RANKING_ITEM_HEIGHT - 2 ;
					rankHeight =  16 ; 
					titleHeight = 16 ; 
					scoreHeight = 16 ; 
				}
				
				// ç²å–å‹•ç•«åˆ†æ•¸å’Œèª¤å·®
				const animatedScore = getAnimatedScore(item.id, item.score, frameIndex);
				const animatedError = getAnimatedError(item.id, item.error, frameIndex);
				
				// æ±ºå®šé¡è‰²ï¼ˆä½¿ç”¨é€æ˜é¡è‰²ï¼‰
				const barColor = index < 3 ? (
					index == 0 ? 'rgba(255, 133, 133, 0.7)' : 
					index == 1 ? 'rgba(250, 160, 85, 0.7)' : 
					'rgba(245, 213, 98, 0.7)'
				) : index % 2 ? 'rgba(102, 234, 148, 0.7)' : 'rgba(102, 233, 237, 0.7)' ;
				
				// è¨ˆç®—æŸ±å½¢é•·åº¦ - ä½¿ç”¨å‹•æ…‹çš„æœ€å¤§å€¼ï¼Œæœ€å°å€¼ç‚º0
				const targetBarLength = (item.score / globalMaxScore) * barWidth;
				const currentBarLength = getAnimatedBarLength(item.id, targetBarLength, frameIndex);
				
				// ç¹ªè£½åˆ†æ•¸æ¢
				ctx.fillStyle = barColor;
				ctx.fillRect(startX, currentY + 5 , currentBarLength, barHeight);
				
				// ç¹ªè£½èª¤å·®ç¯„åœ
				if (animatedError !== undefined &&
					animatedError !== null &&
					animatedError !== Infinity ) {
					const targetErrorLength = (animatedError / globalMaxScore) * barWidth;
					const currentErrorLength = getAnimatedErrorLength(item.id, targetErrorLength, frameIndex);
					
					ctx.strokeStyle = '#48bb78';
					ctx.lineWidth = 2;
					
					const errorCenterX = startX + currentBarLength;
					
					ctx.beginPath();
					ctx.moveTo(errorCenterX - currentErrorLength / 2, currentY + 5);
					ctx.lineTo(errorCenterX + currentErrorLength / 2, currentY + 5);
					ctx.stroke();
					
					// èª¤å·®æ¨™è¨˜
					ctx.beginPath();
					ctx.moveTo(errorCenterX - currentErrorLength / 2, currentY + 2);
					ctx.lineTo(errorCenterX - currentErrorLength / 2, currentY + 8);
					ctx.stroke();
					
					ctx.beginPath();
					ctx.moveTo(errorCenterX + currentErrorLength / 2, currentY + 2);
					ctx.lineTo(errorCenterX + currentErrorLength / 2, currentY + 8);
					ctx.stroke();
				}
				
				// ç¹ªè£½æ’å (ä½¿ç”¨èˆ‡æŸ±å½¢ç›¸åŒçš„é¡è‰²)
				ctx.fillStyle = barColor.replace('0.7', '1'); // ä¸é€æ˜
				ctx.font = `bold ${rankHeight}px Microsoft JhengHei`;
				ctx.textAlign = 'left';
				ctx.fillText(`#${index + 1}`, 20, currentY + RANKING_ITEM_HEIGHT / 2 + (terms>30 ? 8 : 10) );
				
				// ç¹ªè£½é …ç›®åç¨±
				ctx.fillStyle = '#333';
				ctx.font = `${titleHeight}px Microsoft JhengHei`;
				ctx.fillText(item.name, 80, currentY + RANKING_ITEM_HEIGHT / 2 + (terms>30 ? 8 : 10) );
				
				// åˆ†æ•¸æ–‡æœ¬å’Œèª¤å·®
				const scoreText = `${Math.round(animatedScore)}Â±${
				animatedError == undefined || animatedError == null ? '(?)' :
				animatedError == Infinity ? 'âˆ' : Math.round(animatedError)}`;
				
				ctx.fillStyle = '#333';
				ctx.font = `bold ${scoreHeight}px Microsoft JhengHei`;
				ctx.textAlign = 'left';
				
				const textX = startX + currentBarLength + 10;
				ctx.fillText(scoreText, textX, currentY + RANKING_ITEM_HEIGHT / 2 + (terms>30 ? 8 : 10) );
			});
		}
		
		// æ–°å¢åŠ¨ç”»å±æ€§ç®¡ç†å‡½æ•°
		let itemScores = {};
		let itemErrors = {};
		let itemBarLengths = {};
		let itemErrorLengths = {};
		
		function getAnimatedScore(itemId, targetScore, frameIndex) {
			if (!itemScores[itemId]) {
				itemScores[itemId] = {
					currentScore: 1500,
					targetScore: targetScore,
					frameIndex: frameIndex
				};
				return 1500;
			}
			
			const itemScore = itemScores[itemId];
			
			// åªæ›´æ–°ç›®æ¨™å€¼ï¼Œä¿æŒç•¶å‰å€¼ä½œç‚ºå‹•ç•«èµ·é»
			if (itemScore.frameIndex !== frameIndex) {
				itemScore.targetScore = targetScore;
				itemScore.frameIndex = frameIndex;
				
				if (!animationFrameId) {
					startPositionAnimation();
				}
			}
			
			return itemScore.currentScore;
		}
		
		function getAnimatedError(itemId, targetError, frameIndex) {
			if (!itemErrors[itemId]) {
				itemErrors[itemId] = {
					currentError: targetError,
					targetError: targetError,
					frameIndex: frameIndex
				};
				return targetError;
			}
			
			const itemError = itemErrors[itemId];
			
			if (itemError.frameIndex !== frameIndex) {
				itemError.targetError = targetError;
				itemError.frameIndex = frameIndex;
				
				if (!animationFrameId) {
					startPositionAnimation();
				}
			}
			
			return itemError.currentError;
		}
		
		function getAnimatedBarLength(itemId, targetLength, frameIndex) {
			if (!itemBarLengths[itemId]) {
				itemBarLengths[itemId] = {
					currentLength: 0,
					targetLength: targetLength,
					frameIndex: frameIndex
				};
				return 0;
			}
			
			const itemBar = itemBarLengths[itemId];
			
			// åªæ›´æ–°ç›®æ¨™å€¼ï¼Œä¿æŒç•¶å‰å€¼ä½œç‚ºå‹•ç•«èµ·é»
			if (itemBar.frameIndex !== frameIndex) {
				itemBar.targetLength = targetLength;
				itemBar.frameIndex = frameIndex;
				
				if (!animationFrameId) {
					startPositionAnimation();
				}
			}
			
			return itemBar.currentLength;
		}
		
		function getAnimatedErrorLength(itemId, targetLength, frameIndex) {
			if (!itemErrorLengths[itemId]) {
				itemErrorLengths[itemId] = {
					currentLength: 0,
					targetLength: targetLength,
					frameIndex: frameIndex
				};
				return 0;
			}
			
			const itemErrorLength = itemErrorLengths[itemId];
			
			if (itemErrorLength.frameIndex !== frameIndex) {
				itemErrorLength.targetLength = targetLength;
				itemErrorLength.frameIndex = frameIndex;
				
				if (!animationFrameId) {
					startPositionAnimation();
				}
			}
			
			return itemErrorLength.currentLength;
		}
		
		// æ–°å¢ï¼šåŠ¨ç”»ä½ç½®ç®¡ç†
		let itemPositions = {};
		let animationFrameId = null;

		function getAnimatedPosition(itemId, targetY, frameIndex) {
			if (!itemPositions[itemId]) {
				// æ–°é …ç›®ï¼šæª¢æŸ¥æ˜¯å¦æ˜¯ç¬¬ä¸€æ¬¡å‡ºç¾
				const isNewItem = isItemNewInFrame(itemId, frameIndex);
				
				itemPositions[itemId] = {
					currentY: isNewItem ? rankingAnimationCanvas.height + 100 : targetY,
					targetY: targetY,
					frameIndex: frameIndex,
					isNew: isNewItem,
					isRemoved: false
				};
				return itemPositions[itemId].currentY;
			}
			
			const itemPos = itemPositions[itemId];
			
			// å¦‚æœå¹€ç´¢å¼•æ”¹è®Šï¼Œåªæ›´æ–°ç›®æ¨™ä½ç½®ï¼Œä¿æŒç•¶å‰ä½ç½®ä½œç‚ºå‹•ç•«èµ·é»
			if (itemPos.frameIndex !== frameIndex) {
				const isItemInCurrentFrame = isItemInFrame(itemId, frameIndex);
				const wasItemInPreviousFrame = isItemInFrame(itemId, frameIndex - 1);
				
				if (!isItemInCurrentFrame && wasItemInPreviousFrame) {
					// é …ç›®æ¶ˆå¤±ï¼šç§»å‹•åˆ°åº•éƒ¨ä¹‹å¤–
					itemPos.targetY = rankingAnimationCanvas.height + 100;
					itemPos.frameIndex = frameIndex;
					itemPos.isRemoved = true;
					itemPos.isNew = false;
				} else if (isItemInCurrentFrame && !wasItemInPreviousFrame) {
					// é …ç›®æ–°å‡ºç¾ï¼šå¾åº•éƒ¨ä¹‹å¤–é–‹å§‹
					itemPos.currentY = rankingAnimationCanvas.height + 100;
					itemPos.targetY = targetY;
					itemPos.frameIndex = frameIndex;
					itemPos.isNew = true;
					itemPos.isRemoved = false;
				} else if (isItemInCurrentFrame) {
					// é …ç›®æ­£å¸¸ç§»å‹•ï¼šåªæ›´æ–°ç›®æ¨™ä½ç½®ï¼Œä¿æŒç•¶å‰ä½ç½®
					itemPos.targetY = targetY;
					itemPos.frameIndex = frameIndex;
					itemPos.isNew = false;
					itemPos.isRemoved = false;
				}
				
				// å•Ÿå‹•å‹•ç•«
				if (!animationFrameId) {
					startPositionAnimation();
				}
			}
			
			return itemPos.currentY;
		}
		
		// æ£€æŸ¥é¡¹ç›®æ˜¯å¦åœ¨æŒ‡å®šå¸§ä¸­
		function isItemInFrame(itemId, frameIndex) {
			if (frameIndex < 0 || frameIndex >= rankingAnimationData.length) return false;
			const frame = rankingAnimationData[frameIndex];
			return frame.items.some(item => item.id === itemId);
		}
		
		// æ£€æŸ¥é¡¹ç›®æ˜¯å¦åœ¨æŒ‡å®šå¸§ä¸­é¦–æ¬¡å‡ºç°
		function isItemNewInFrame(itemId, frameIndex) {
			if (frameIndex <= 0) return false; // ç¬¬ä¸€å¸§ä¸ç®—æ–°å‡ºç°
			return isItemInFrame(itemId, frameIndex) && !isItemInFrame(itemId, frameIndex - 1);
		}
		
		function startPositionAnimation() {
			if (animationFrameId) return;
			
			function animate() {
				let needsUpdate = false;
				
				// æ›´æ–°ä½ç½®
				Object.keys(itemPositions).forEach(itemId => {
					const pos = itemPositions[itemId];
					const diff = pos.targetY - pos.currentY;
					
					if (Math.abs(diff) > 0.5) {
						pos.currentY += diff * 0.08; // ç»Ÿä¸€è°ƒæ•´åŠ¨ç”»é€Ÿåº¦
						needsUpdate = true;
					} else {
						pos.currentY = pos.targetY;
					}
				});
				
				// æ›´æ–°å…¶ä»–åŠ¨ç”»å±æ€§
				const otherAnimationsNeedUpdate = updateOtherAnimations();
				needsUpdate = needsUpdate || otherAnimationsNeedUpdate;
				
				if (needsUpdate) {
					drawRankingFrame(currentRankingFrame);
					animationFrameId = requestAnimationFrame(animate);
				} else {
					animationFrameId = null;
					cleanupRemovedItems();
				}
			}
			
			animationFrameId = requestAnimationFrame(animate);
		}

		// æ¸…ç†å·²ç§»é™¤çš„é¡¹ç›®æ•°æ®
		function cleanupRemovedItems() {
			Object.keys(itemPositions).forEach(itemId => {
				const pos = itemPositions[itemId];
				if (pos.isRemoved && pos.currentY > rankingAnimationCanvas.height) {
					delete itemPositions[itemId];
					delete itemScores[itemId];
					delete itemErrors[itemId];
					delete itemBarLengths[itemId];
					delete itemErrorLengths[itemId];
				}
			});
		}

        function advanceRankingFrame() {
			if (animationManager.isBusy()) return;
			
			animationManager.addToQueue((complete) => {
				currentRankingFrame++;
				
				if (currentRankingFrame >= rankingAnimationData.length) {
					clearInterval(rankingAnimationInterval);
					rankingAnimationInterval = null;
					document.getElementById('playPauseBtn').textContent = 'æ’­æ”¾';
					currentRankingFrame = rankingAnimationData.length - 1;
					complete();
					return;
				}
				
				document.getElementById('frameSlider').value = currentRankingFrame;
				updateFrameSliderValue();
				
				triggerAnimationUpdate();
				drawRankingFrame(currentRankingFrame);
				
				waitForAnimationCompletion(() => {
					complete();
				});
			});
		}

        function toggleRankingAnimation() {
			const playPauseBtn = document.getElementById('playPauseBtn');
			
			if (rankingAnimationInterval) {
				clearInterval(rankingAnimationInterval);
				rankingAnimationInterval = null;
				playPauseBtn.textContent = 'æ’­æ”¾';
			} else {
				if (currentRankingFrame >= rankingAnimationData.length - 1) {
					currentRankingFrame = 0;
					document.getElementById('frameSlider').value = 0;
					updateFrameSliderValue();
				}
				
				playPauseBtn.textContent = 'æš«åœ';
				rankingAnimationInterval = setInterval(() => {
					if (!animationManager.isBusy()) {
						advanceRankingFrame();
					}
				}, rankingAnimationSpeed);
			}
		}

        function prevRankingFrame() {
			if (animationManager.isBusy()) return;
			
			animationManager.addToQueue((complete) => {
				if (rankingAnimationInterval) {
					clearInterval(rankingAnimationInterval);
					rankingAnimationInterval = null;
					document.getElementById('playPauseBtn').textContent = 'æ’­æ”¾';
				}
				
				currentRankingFrame--;
				if (currentRankingFrame < 0) {
					currentRankingFrame = 0;
				}
				
				document.getElementById('frameSlider').value = currentRankingFrame;
				updateFrameSliderValue();
				
				triggerAnimationUpdate();
				drawRankingFrame(currentRankingFrame);
				
				waitForAnimationCompletion(() => {
					complete();
				});
			});
		}

		function nextRankingFrame() {
			if (animationManager.isBusy()) return;
			
			animationManager.addToQueue((complete) => {
				if (rankingAnimationInterval) {
					clearInterval(rankingAnimationInterval);
					rankingAnimationInterval = null;
					document.getElementById('playPauseBtn').textContent = 'æ’­æ”¾';
				}
				
				currentRankingFrame++;
				if (currentRankingFrame >= rankingAnimationData.length) {
					currentRankingFrame = rankingAnimationData.length - 1;
				}
				
				document.getElementById('frameSlider').value = currentRankingFrame;
				updateFrameSliderValue();
				
				triggerAnimationUpdate();
				drawRankingFrame(currentRankingFrame);
				
				waitForAnimationCompletion(() => {
					complete();
				});
			});
		}

        function closeRankingAnimation() {
			const modal = document.getElementById('rankingAnimationModal');
			modal.classList.add('hidden');
			
			window.removeEventListener('resize', handleResize);
			
			if (rankingAnimationInterval) {
				clearInterval(rankingAnimationInterval);
				rankingAnimationInterval = null;
			}
			
			if (animationFrameId) {
				cancelAnimationFrame(animationFrameId);
				animationFrameId = null;
			}
			
			// æ¸…ç†åŠ¨ç”»ç®¡ç†å™¨çŠ¶æ€
			animationManager.clearQueue();
			
			// æ¸…ç†ä½ç½®æ•°æ®
			itemPositions = {};
		}

        function loadStats() {
			// const startTime = Date.now();
			const gameId = document.getElementById('statsGameSelect').value;
			selectedGameId = gameId; 
			localStorage.setItem('selectedGameId', selectedGameId);
			
			if (!gameId) { 
				document.getElementById('statsContent').classList.add('hidden'); 
				return; 
			}
			
			const game = games[gameId];
			document.getElementById('statsContent').classList.remove('hidden');
			
			// ç¢ºä¿éŠæˆ²å°è±¡å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨å‰‡å‰µå»ºç©ºçµæ§‹
			if (!game) {
				// å¦‚æœéŠæˆ²ä¸å­˜åœ¨ï¼Œé¡¯ç¤ºç©ºç‹€æ…‹
				showEmptyStats();
				return;
			}
			
			// æª¢æŸ¥éŠæˆ²æ˜¯å¦æœ‰é …ç›®ï¼Œå¦‚æœæ²’æœ‰å‰‡é‡ç½®å¡ç‰‡æ•¸å€¼
			if (!game.items || game.items.length == 0) {
				showEmptyStats();
				return;
			}

			// è¨ˆç®—åŸºç¤çµ±è¨ˆæ•¸æ“šä¸¦ä¿å­˜çµæœ
			const stats = calculateBasicStats(game);
			
			// æ›´æ–°æœ€å¾ŒæŠ•ç¥¨æ—¥æœŸ
			updateLastVoteDate(game);
			
			// æ¸²æŸ“åœ–è¡¨ï¼ˆéœ€è¦è™•ç†ç©ºé …ç›®æƒ…æ³ï¼‰
			renderScoreDistributionChart(game);
			
			// æ¸²æŸ“æ’è¡Œæ¦œï¼Œå‚³å…¥çµ±è¨ˆæ•¸æ“š
			renderRankingList(game, stats);
			
			// æ›´æ–°æµ®å‹•æŒ‰éˆ•
			updateFloatButtons();
			
			// æ¢å¾©æœç´¢ç‹€æ…‹
			restoreSearchState();
			
			// console.log(`è¼‰å…¥è€—æ™‚: ${Date.now()-startTime}`) ;
		}
		
		// æ˜¾ç¤ºç©ºç»Ÿè®¡çŠ¶æ€çš„å‡½æ•°
		function showEmptyStats() {
			// æ›´æ–°åŸºç¤çµ±è¨ˆæ•¸æ“šé¡¯ç¤ºç‚ºé»˜èªå€¼
			document.getElementById('totalItems').textContent = '0';
			document.getElementById('totalVotes').textContent = '0';
			document.getElementById('expectedVotes').textContent = '0';
			document.getElementById('avgError').textContent = '?';
			document.getElementById('avgScore').textContent = '?';
			document.getElementById('medianScore').textContent = '?';
			document.getElementById('maxScore').textContent = '?';
			document.getElementById('minScore').textContent = '?';
			document.getElementById('stdDevScore').textContent = '?';
			document.getElementById('lastVoteDate').textContent = '?';
			document.getElementById('lastVoteDate2').textContent = '?';
			document.getElementById('lastVoteDateCard').onclick = null;

			// æ¸…ç©ºæ’è¡Œæ¦œ
			document.getElementById('rankingList').innerHTML = '<div class="no-history-data">æ­¤éŠæˆ²ç›®å‰æ²’æœ‰é …ç›®</div>';
			
			// æ›´æ–°æ’è¡Œæ¦œæ¨™é¡Œ
			document.getElementById('rankingTitle').textContent = 'æ’è¡Œæ¦œ (0/0)';
			
			// éŠ·æ¯€ç¾æœ‰çš„åˆ†å¸ƒåœ–è¡¨ï¼ˆå¦‚æœæœ‰ï¼‰
			if (scoreDistributionChart) {
				scoreDistributionChart.destroy();
				scoreDistributionChart = null;
			}
			
			// åˆ†æ•¸åˆ†å¸ƒå°åœ–ä¿æŒç©ºç™½ï¼Œä¸é¡¯ç¤ºä»»ä½•å…§å®¹
			const ctx = document.getElementById('scoreDistributionChart').getContext('2d');
			ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
			
			// éš±è—æµ®å‹•æŒ‰éˆ•
			document.getElementById('floatButtons').style.display = 'none';
		}
		
		// 2. è®¡ç®—åŸºç¡€ç»Ÿè®¡æ•°æ®
		function calculateBasicStats(game) {
			// æ£€æŸ¥æ¸¸æˆé¡¹ç›®æ˜¯å¦å­˜åœ¨ä¸”ä¸ä¸ºç©º
			if (!game.items || game.items.length === 0) {
				return {
					maxScore: 1500, 
					minScore: 1500, 
					avgScore: 1500, 
					medianScore: 1500,
					scoreStdDev: 0, 
					upperThreshold2: 1500, 
					upperThreshold: 1500, 
					lowerThreshold: 1500, 
					lowerThreshold2: 1500
				};
			}
			
			document.getElementById('totalItems').textContent = game.items.length;
			document.getElementById('totalVotes').textContent = game.votes.length;
			
			let expectedValue = 25 * game.items.length;
			document.getElementById('expectedVotes').textContent = expectedValue;
			
			let minScore = Infinity, maxScore = -Infinity, totalScore = 0;
			let scores = [];
			
			game.items.forEach(item => {
				if (item.score < minScore) minScore = item.score;
				if (item.score > maxScore) maxScore = item.score;
				totalScore += item.score;
				scores.push(item.score);
			});
			
			scores.sort((a, b) => a - b);
			const medianScore = calculateMedian(scores);
			const avgScore = game.items.length > 0 ? (totalScore / game.items.length).toFixed(2) : 1500;
			const scoreStdDev = calculateStandardDeviation(scores);
			
			// è®¡ç®—åˆ†éš”çº¿é˜ˆå€¼
			const upperThreshold2 = parseFloat(avgScore) + 2 * parseFloat(scoreStdDev);
			const upperThreshold = parseFloat(avgScore) + parseFloat(scoreStdDev);
			const lowerThreshold = parseFloat(avgScore) - parseFloat(scoreStdDev);
			const lowerThreshold2 = parseFloat(avgScore) - 2 * parseFloat(scoreStdDev);
			
			// æ›´æ–°DOMå…ƒç´ 
			updateStatsElements({
				maxScore, minScore, avgScore, medianScore, 
				scoreStdDev, upperThreshold2, upperThreshold, 
				lowerThreshold, lowerThreshold2
			});
			
			// è®¡ç®—å¹³å‡è¯¯å·®
			calculateAverageError(game);
			
			// è¿”å›çµ±è¨ˆæ•¸æ“šä¾›å…¶ä»–å‡½æ•¸ä½¿ç”¨
			return {
				maxScore, minScore, avgScore: parseFloat(avgScore), medianScore, 
				scoreStdDev, upperThreshold2, upperThreshold, 
				lowerThreshold, lowerThreshold2
			};
		}
		
		// 3. è®¡ç®—ä¸­ä½æ•°
		function calculateMedian(scores) {
			const mid = Math.floor(scores.length / 2);
			if (scores.length % 2 === 0) {
				return (scores[mid - 1] + scores[mid]) / 2;
			} else {
				return scores[mid];
			}
		}
		
		// 4. æ›´æ–°ç»Ÿè®¡å…ƒç´ 
		function updateStatsElements(stats) {
			document.getElementById('maxScore').textContent = stats.maxScore;
			document.getElementById('minScore').textContent = stats.minScore;
			document.getElementById('avgScore').textContent = stats.avgScore;
			document.getElementById('stdDevScore').textContent = stats.scoreStdDev.toFixed(2);
			document.getElementById('medianScore').textContent = stats.medianScore.toFixed(1);
		}
		
		// 5. è®¡ç®—å¹³å‡è¯¯å·®
		function calculateAverageError(game) {
			let totalError = 0, validErrorCount = 0;
			
			game.items.forEach(item => {
				const error = calculateError(item);
				if (error !== Infinity) {
					totalError += error;
					validErrorCount++;
				}
			});
			
			const avgError = validErrorCount > 0 ? (totalError / validErrorCount).toFixed(2) : 0;
			document.getElementById('avgError').textContent = avgError;
		}
		
		// æ›´æ–°æœ€å¾ŒæŠ•ç¥¨æ—¥æœŸé¡¯ç¤º
		function updateLastVoteDate(game) {
			const lastVoteDateElement = document.getElementById('lastVoteDate');
			const lastVoteDateElement2 = document.getElementById('lastVoteDate2');
			const lastVoteDate = getLastVoteDate(game);
			
			if (lastVoteDate) {
				lastVoteDateElement.textContent = lastVoteDate[0] ;
				lastVoteDateElement2.textContent = lastVoteDate[1] ;

				// é»æ“Šæ™‚é¡¯ç¤ºæ›´å¤šä¿¡æ¯
				const lastVoteDateCard = document.getElementById('lastVoteDateCard');
				lastVoteDateCard.onclick = function() {
					showLastVoteDetails(game);
				};
			} else {
				lastVoteDateElement.textContent = '?';
				lastVoteDateElement.textContent2 = '?';
				const lastVoteDateCard = document.getElementById('lastVoteDateCard');
				lastVoteDateCard.onclick = null;
			}
		}
		
		// é¡¯ç¤ºæœ€å¾ŒæŠ•ç¥¨è©³æƒ…
		function showLastVoteDetails(game) {
			if (!game.votes || game.votes.length === 0) {
				alert('æ­¤éŠæˆ²ç›®å‰æ²’æœ‰æŠ•ç¥¨è¨˜éŒ„');
				return;
			}
			
			// æ‰¾å‡ºæœ€æ–°çš„æŠ•ç¥¨
			let latestVote = null;
			let latestTimestamp = 0;
			
			game.votes.forEach(vote => {
				if (vote.timestamp > latestTimestamp) {
					latestTimestamp = vote.timestamp;
					latestVote = vote;
				}
			});
			
			if (!latestVote) {
				alert('ç„¡æ³•æ‰¾åˆ°æŠ•ç¥¨è¨˜éŒ„');
				return;
			}
			
			// ç²å–é …ç›®åç¨±
			const item1 = game.items.find(item => item.id === latestVote.item1);
			const item2 = game.items.find(item => item.id === latestVote.item2);
			
			const item1Name = item1 ? item1.name : 'æœªçŸ¥é …ç›®';
			const item2Name = item2 ? item2.name : 'æœªçŸ¥é …ç›®';
			
			// æ ¼å¼åŒ–æ™‚é–“
			const date = new Date(latestVote.timestamp);
			const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
			const timeString = `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}:${String(date.getSeconds()).padStart(2, '0')}`;
			
			// å‹åˆ©ä½”æ¯”
			const voteR = latestVote.value ;
			const voteL = 100 - voteR ;
			
			
			alert(`æœ€å¾ŒæŠ•ç¥¨æ–¼ ${dateString} ${timeString}

å°æ±ºé …ç›®ï¼š
    ${item1Name}
    ${item2Name}
å‹åˆ©ä½”æ¯”ï¼š${voteL} : ${voteR}`);
		}
		
		// 6. æ¸²æŸ“æ’è¡Œæ¦œåˆ—è¡¨
		function renderRankingList(game, stats) {
			const sortBy = document.getElementById('sortBy').value;
			
			// æ£€æŸ¥é¡¹ç›®æ˜¯å¦å­˜åœ¨
			if (!game.items || game.items.length === 0) {
				const rankingList = document.getElementById('rankingList');
				rankingList.innerHTML = '<div class="no-history-data">æ­¤éŠæˆ²ç›®å‰æ²’æœ‰é …ç›®</div>';
				document.getElementById('rankingTitle').textContent = 'æ’è¡Œæ¦œ (0/0)';
				return;
			}
			
			let sortedItems = [...game.items];
			const currentStatsMoodLogic = document.getElementById('statsMoodLogic').value;
			
			// åº”ç”¨å¿ƒæƒ…ç­›é€‰
			if (statsMoodFilters.length > 0) {
				sortedItems = applyMoodFilter(sortedItems, statsMoodFilters, currentStatsMoodLogic);
			}
			
			// æ’åº
			sortedItems = sortRankingItems(sortedItems, sortBy, game);
			
			// åªåœ¨"ä¾åæ¬¡"æˆ–"ä¾åˆ†æ•¸"æ’åºæ™‚é¡¯ç¤ºåˆ†éš”ç·š
			const showSeparators = sortBy === 'rank' || sortBy === 'score';
			
			// æ¸²æŸ“åˆ—è¡¨ï¼Œå‚³å…¥çµ±è¨ˆæ•¸æ“šå’Œé¡¯ç¤ºåˆ†éš”ç·šçš„æ¨™èªŒ
			renderRankingItems(sortedItems, game, stats, showSeparators);
			
			// æ›´æ–°æ ‡é¢˜
			updateRankingTitle(sortedItems, game);
		}
		
		// 7. æ’åºæ’è¡Œæ¦œé¡¹ç›®
		function sortRankingItems(items, sortBy, game) {
			switch(sortBy) {
				case 'rank':
					return sortItemsByRank(items);
				case 'score':
					return items.sort((a, b) => b.score - a.score);
				case 'winRate':
					return items.sort((a, b) => {
						const winRateA = calculateWinRate(a);
						const winRateB = calculateWinRate(b);
						return winRateB - winRateA;
					});
				case 'votes': 
					return items.sort((a, b) => b.votes - a.votes);
				case 'time': 
					return items.sort((a, b) => (b.addedTime || 0) - (a.addedTime || 0));
				case 'error':
					return items.sort((a, b) => {
						const errorA = calculateError(a);
						const errorB = calculateError(b);
						if (errorA === Infinity && errorB !== Infinity) return -1;
						if (errorA !== Infinity && errorB === Infinity) return 1;
						return errorB - errorA;
					});
				case 'volatility':
					return items.sort((a, b) => {
						const volatilityA = calculateRecentVolatility(a);
						const volatilityB = calculateRecentVolatility(b);
						return volatilityB - volatilityA;
					});
				case 'trend':  // è¶‹åŠ¿æ’åº
					return items.sort((a, b) => {
						const trendA = calculateTrendValue(a);
						const trendB = calculateTrendValue(b);
						return trendB - trendA; // ä»å¤§åˆ°å°æ’åº
					});
				default:
					return items;
			}
		}
		
		// è®¡ç®—è¶‹åŠ¿å€¼çš„å‡½æ•°
		function calculateTrendValue(item) {
			if (!item.scoreHistory || item.scoreHistory.length < 3) {
				return 0;
			}
			
			const now = Date.now();
			const thirtyDaysAgo = now - (30 * 24 * 60 * 60 * 1000);
			
			// è¿‡æ»¤æœ€è¿‘30å¤©çš„åˆ†æ•°è®°å½•
			const recentScores = item.scoreHistory
				.filter(record => record.timestamp >= thirtyDaysAgo)
				.map(record => record.score);
			
			if (recentScores.length < 3) {
				return 0;
			}
			
			const volatility = Math.max(...recentScores) - Math.min(...recentScores);
			const firstScore = recentScores[0];
			const lastScore = recentScores[recentScores.length - 1];
			const scoreDiff = lastScore - firstScore;
			
			if (volatility === 0) {
				return 0;
			}
			
			// è¿”å›è¶‹åŠ¿å¼ºåº¦ï¼šåˆ†æ•°å˜åŒ–/æ³¢åŠ¨å€¼
			return scoreDiff / volatility;
		}
		
		// 8. æ¸²æŸ“æ’è¡Œæ¦œé¡¹ç›®
		function renderRankingItems(sortedItems, game, stats, showSeparators) {
			const rankingList = document.getElementById('rankingList');
			rankingList.innerHTML = '';
			
			const allItemsRanked = sortItemsByRank(game.items);
			const rankMap = new Map();
			allItemsRanked.forEach((item, index) => {
				rankMap.set(item.id, index + 1);
			});
			
			// åªåœ¨éœ€è¦æ—¶è®¡ç®—åˆ†éš”çº¿ä½ç½®
			const separatorPositions = showSeparators ? calculateSeparatorPositions(sortedItems, stats) : null;
			
			// æ¸²æŸ“é¡¹ç›®å’Œåˆ†éš”çº¿ï¼Œä¼ å…¥ showSeparators å‚æ•°
			renderItemsWithSeparators(sortedItems, rankMap, separatorPositions, rankingList, game, showSeparators);
			
			// æ¢å¤å±•å¼€çš„å›¾è¡¨
			restoreExpandedCharts();
		}
		
		// 9. è®¡ç®—åˆ†éš”çº¿ä½ç½®
		function calculateSeparatorPositions(sortedItems, stats) {
			const { upperThreshold2, upperThreshold, lowerThreshold, lowerThreshold2 } = stats;
			const avgScore = stats.avgScore; // å¹³å‡å€¼
			
			// æ‰¾å‡ºåˆ†éš”ç·šæ‡‰è©²æ’å…¥çš„ä½ç½®
			let upperSeparator2Index = -1;
			let upperSeparatorIndex = -1;
			let avgSeparatorIndex = -1;
			let lowerSeparatorIndex = -1;
			let lowerSeparator2Index = -1;
			
			// æ‰¾å‡ºä¸Šåˆ†éš”ç·šæ‡‰è©²æ’å…¥çš„ä½ç½®ï¼ˆç¬¬ä¸€å€‹åˆ†æ•¸ <= upperThreshold2 çš„é …ç›®ä¹‹å‰ï¼‰
			for (let i = 0; i < sortedItems.length; i++) {
				if (sortedItems[i].score <= upperThreshold2) {
					upperSeparator2Index = i;
					break;
				}
			}
			if (upperSeparator2Index === -1) {
				upperSeparator2Index = sortedItems.length;
			}
			
			// æ‰¾å‡ºä¸Šåˆ†éš”ç·šæ‡‰è©²æ’å…¥çš„ä½ç½®ï¼ˆç¬¬ä¸€å€‹åˆ†æ•¸ <= upperThreshold çš„é …ç›®ä¹‹å‰ï¼‰
			for (let i = 0; i < sortedItems.length; i++) {
				if (sortedItems[i].score <= upperThreshold) {
					upperSeparatorIndex = i;
					break;
				}
			}
			if (upperSeparatorIndex === -1) {
				upperSeparatorIndex = sortedItems.length;
			}
			
			// æ–°å¢ï¼šæ‰¾å‡º Î¼ åˆ†éš”ç·šæ‡‰è©²æ’å…¥çš„ä½ç½®ï¼ˆç¬¬ä¸€å€‹åˆ†æ•¸ < avgScore çš„é …ç›®ä¹‹å‰ï¼‰
			for (let i = 0; i < sortedItems.length; i++) {
				if (sortedItems[i].score < avgScore) {
					avgSeparatorIndex = i;
					break;
				}
			}
			if (avgSeparatorIndex === -1) {
				avgSeparatorIndex = sortedItems.length;
			}
			
			// æ‰¾å‡ºä¸‹åˆ†éš”ç·šæ‡‰è©²æ’å…¥çš„ä½ç½®ï¼ˆç¬¬ä¸€å€‹åˆ†æ•¸ < lowerThreshold çš„é …ç›®ä¹‹å‰ï¼‰
			for (let i = 0; i < sortedItems.length; i++) {
				if (sortedItems[i].score < lowerThreshold) {
					lowerSeparatorIndex = i;
					break;
				}
			}
			if (lowerSeparatorIndex === -1) {
				lowerSeparatorIndex = sortedItems.length;
			}
			
			// æ‰¾å‡ºä¸‹åˆ†éš”ç·šæ‡‰è©²æ’å…¥çš„ä½ç½®ï¼ˆç¬¬ä¸€å€‹åˆ†æ•¸ < lowerThreshold2 çš„é …ç›®ä¹‹å‰ï¼‰
			for (let i = 0; i < sortedItems.length; i++) {
				if (sortedItems[i].score < lowerThreshold2) {
					lowerSeparator2Index = i;
					break;
				}
			}
			if (lowerSeparator2Index === -1) {
				lowerSeparator2Index = sortedItems.length;
			}
			
			return {
				upperSeparator2Index,
				upperSeparatorIndex,
				avgSeparatorIndex,
				lowerSeparatorIndex,
				lowerSeparator2Index,
				upperThreshold2,
				upperThreshold,
				avgScore,
				lowerThreshold,
				lowerThreshold2
			};
		}
		
		// 10. æ¸²æŸ“å¸¦åˆ†éš”çº¿çš„é¡¹ç›®
		function renderItemsWithSeparators(sortedItems, rankMap, separatorPositions, container, game, showSeparators) {
			let upperSeparator2Added = false;
			let upperSeparatorAdded = false;
			let avgSeparatorAdded = false;  // æ–°å¢ï¼šÎ¼ åˆ†éš”çº¿æ ‡è®°
			let lowerSeparatorAdded = false;
			let lowerSeparator2Added = false;
			
			sortedItems.forEach((item, index) => {
				// åªåœ¨æ˜¾ç¤ºåˆ†éš”çº¿æ—¶æ’å…¥åˆ†éš”ç·š
				if (showSeparators && separatorPositions) {
					// åœ¨æ’å…¥é …ç›®å‰æª¢æŸ¥æ˜¯å¦éœ€è¦æ’å…¥åˆ†éš”ç·šï¼ˆæŒ‰å¾ä¸Šåˆ°ä¸‹çš„é †åºï¼‰
					if (!upperSeparator2Added && index === separatorPositions.upperSeparator2Index) {
						const separator = createSeparator(`Î¼ + 2Ïƒ = ${separatorPositions.upperThreshold2.toFixed(2)}`, 'separator-upper-2');
						container.appendChild(separator);
						upperSeparator2Added = true;
					}
					
					if (!upperSeparatorAdded && index === separatorPositions.upperSeparatorIndex) {
						const separator = createSeparator(`Î¼ + Ïƒ = ${separatorPositions.upperThreshold.toFixed(2)}`, 'separator-upper');
						container.appendChild(separator);
						upperSeparatorAdded = true;
					}
					
					if (!avgSeparatorAdded && index === separatorPositions.avgSeparatorIndex) {
						const separator = createSeparator(`Î¼ = ${separatorPositions.avgScore.toFixed(2)}`, 'separator-avg');
						container.appendChild(separator);
						avgSeparatorAdded = true;
					}
					
					if (!lowerSeparatorAdded && index === separatorPositions.lowerSeparatorIndex) {
						const separator = createSeparator(`Î¼ - Ïƒ = ${separatorPositions.lowerThreshold.toFixed(2)}`, 'separator-lower');
						container.appendChild(separator);
						lowerSeparatorAdded = true;
					}
					
					if (!lowerSeparator2Added && index === separatorPositions.lowerSeparator2Index) {
						const separator = createSeparator(`Î¼ - 2Ïƒ = ${separatorPositions.lowerThreshold2.toFixed(2)}`, 'separator-lower-2');
						container.appendChild(separator);
						lowerSeparator2Added = true;
					}
				}
				
				// æ¸²æŸ“å•ä¸ªé¡¹ç›®ï¼Œå‚³å…¥ game åƒæ•¸
				renderRankingItem(item, rankMap.get(item.id), container, game);
			});
			
			// åªåœ¨æ˜¾ç¤ºåˆ†éš”çº¿æ—¶ç¡®ä¿æ‰€æœ‰åˆ†éš”ç·šéƒ½è¢«æ’å…¥
			if (showSeparators && separatorPositions) {
				ensureAllSeparators(container, {
					upperSeparator2Added,
					upperSeparatorAdded,
					avgSeparatorAdded,
					lowerSeparatorAdded,
					lowerSeparator2Added,
					upperThreshold2: separatorPositions.upperThreshold2,
					upperThreshold: separatorPositions.upperThreshold,
					avgScore: separatorPositions.avgScore,
					lowerThreshold: separatorPositions.lowerThreshold,
					lowerThreshold2: separatorPositions.lowerThreshold2
				});
			}
		}
		
		// 11. æ¸²æŸ“å•ä¸ªæ’è¡Œæ¦œé¡¹ç›®
		function renderRankingItem(item, displayRank, container, game) {
			const winRate = (calculateWinRate(item) * 100).toFixed(1);
			const recentVolatility = calculateRecentVolatility(item);
			const volatilitySymbol = getRecentVolatilitySymbol(item);
			let error = calculateError(item);
			error = error === Infinity ? 'âˆ' : Math.round(error);
			
			const rankingItem = document.createElement('div');
			rankingItem.className = 'list-item ranking-item';
			rankingItem.id = `ranking-item-${item.id}`;
			
			if (item.frozen) {
				rankingItem.classList.add('frozen');
			}
			
			let moodDisplay = '';
			if (item.moods && item.moods.length > 0) {
				moodDisplay = `<div class="mood-display">${item.moods.join('')}</div>`;
			}
			
			rankingItem.innerHTML = `
				<div style="display: flex; flex-direction: column; width: 100%;">
					<div style="display: flex; align-items: center; width: 100%; height: 0px;">
						<span style="font-size: 1.2em; font-weight: bold; color: var(--primary); width: 3em; margin-right: 20px;">
							#${displayRank}
						</span>
						<span class="item-name" style="flex: 1; font-size: 1.0em; font-weight: bold;">${item.name}</span>
						<div style="display: flex; align-items: center;">
							${moodDisplay}
							<span style="font-size: 1.0em; color: var(--success);">åˆ†æ•¸: ${item.score}Â±${error} | åŠ æ¬Šå‹ç‡: ${winRate}% | æœˆåº¦æ³¢å‹•: ${recentVolatility}${volatilitySymbol} | ç¥¨æ¬¡: ${item.votes}</span>
						</div>
					</div>
					<div class="score-chart-container" style="display: none;"></div>
				</div>`;
			
			rankingItem.onclick = function() {
				toggleScoreChart(item.id);
			};
			
			rankingItem.addEventListener('contextmenu', function(e) {
				e.preventDefault();
				showItemContextMenu(e, item.id, game.id);
			});
			
			container.appendChild(rankingItem);
		}
		
		// 12. æ¢å¤æœç´¢çŠ¶æ€
		function restoreSearchState() {
			const searchText = document.getElementById('rankingSearch').value;
			if (searchText) {
				searchRanking();
			}
		}
		
		// 13. æ¢å¤å±•å¼€çš„å›¾è¡¨
		function restoreExpandedCharts() {
			expandedItemIds.forEach(itemId => {
				const rankingItem = document.getElementById(`ranking-item-${itemId}`);
				if (rankingItem) {
					const chartContainer = rankingItem.querySelector('.score-chart-container');
					if (chartContainer) {
						rankingItem.classList.add('expanded');
						chartContainer.style.display = 'block';
						renderScoreChart(itemId, chartContainer);
					}
				}
			});
		}
		
		// 14. æ›´æ–°æ’è¡Œæ¦œæ ‡é¢˜
		function updateRankingTitle(sortedItems, game) {
			const titleText = `æ’è¡Œæ¦œ (${sortedItems.length}/${game.items.length})`;
			document.getElementById('rankingTitle').textContent = titleText;
		}
		
		// æ»¾å‹•åˆ°é é ‚
		function scrollToTop() {
			window.scrollTo({
				top: 0 ,
				behavior: 'smooth'
			});
		}
		
		// æ»¾å‹•åˆ°é åº•
		function scrollToBottom() {
			window.scrollTo({
				top: document.documentElement.scrollHeight ,
				behavior: 'smooth'
			});
		}
		
		// æ»¾å‹•åˆ°åˆ†éš”ç·š
		function scrollToSeparator(separatorId) {
			const separator = document.getElementById(separatorId);
			if (separator) {
				separator.scrollIntoView({
					behavior: 'smooth',
					block: 'center'
				});
				
				// æ·»åŠ é«˜äº®æ•ˆæœ
				separator.style.backgroundColor = 'rgba(245, 101, 101, 0.3)';
				setTimeout(() => {
					separator.style.backgroundColor = '';
				}, 2000);
			}
		}
		
		// æ›´æ–°æµ®å‹•æŒ‰éˆ•
		function updateFloatButtons() {
			const floatButtons = document.getElementById('floatButtons');
			floatButtons.innerHTML = ''; // æ¸…ç©ºç¾æœ‰æŒ‰éˆ•
			
			// æ»¾å‹•åˆ°é ‚éƒ¨æŒ‰éˆ•
			const topBtn = document.createElement('button');
			topBtn.className = 'float-btn';
			topBtn.innerHTML = 'â†‘';
			topBtn.title = 'æ»¾å‹•åˆ°é é ‚';
			topBtn.onclick = scrollToTop;
			floatButtons.appendChild(topBtn);
			
			// æª¢æŸ¥æ˜¯å¦å­˜åœ¨åˆ†éš”ç·šï¼Œå¦‚æœå­˜åœ¨å‰‡æ·»åŠ å°æ‡‰æŒ‰éˆ•
			const separatorIds = ['separator-upper-2', 'separator-upper', 'separator-avg', 'separator-lower', 'separator-lower-2'];
			const separatorLabels = ['2Ïƒ', 'Ïƒ', 'Î¼', '-Ïƒ', '-2Ïƒ'];
			
			// æª¢æŸ¥æ’åºæ–¹å¼ï¼Œåªåœ¨ä¾åæ¬¡æˆ–åˆ†æ•¸æ’åºæ™‚é¡¯ç¤ºåˆ†éš”ç·šæŒ‰éˆ•
			const sortBy = document.getElementById('sortBy').value;
			const showSeparators = sortBy === 'rank' || sortBy === 'score';
			
			if (showSeparators) {
				separatorIds.forEach((id, index) => {
					const separator = document.getElementById(id);
					if (separator && separator.style.display !== 'none') {
						const separatorBtn = document.createElement('button');
						separatorBtn.className = 'float-btn scroll-to-separator';
						separatorBtn.innerHTML = separatorLabels[index];
						separatorBtn.title = `æ»¾å‹•åˆ°è©²åˆ†éš”ç·š`;
						separatorBtn.onclick = function() {
							scrollToSeparator(id);
						};
						floatButtons.appendChild(separatorBtn);
					}
				});
			}
			
			// æ»¾å‹•åˆ°åº•éƒ¨æŒ‰éˆ•
			const bottomBtn = document.createElement('button');
			bottomBtn.className = 'float-btn';
			bottomBtn.innerHTML = 'â†“';
			bottomBtn.title = 'æ»¾å‹•åˆ°é åº•';
			bottomBtn.onclick = scrollToBottom;
			floatButtons.appendChild(bottomBtn);
			
			// å¦‚æœè‡³å°‘æœ‰1å€‹æŒ‰éˆ•ï¼ˆæ»¾å‹•åˆ°é ‚éƒ¨æŒ‰éˆ•ç¸½æ˜¯å­˜åœ¨ï¼‰ï¼Œå‰‡é¡¯ç¤ºæµ®å‹•æŒ‰éˆ•å®¹å™¨
			floatButtons.style.display = floatButtons.children.length > 0 ? 'flex' : 'none';
		}
		
		
		
		function ensureAllSeparators(container, separatorPositions) {
			const { 
				upperSeparator2Added, 
				upperSeparatorAdded, 
				avgSeparatorAdded,  // æ–°å¢
				lowerSeparatorAdded, 
				lowerSeparator2Added 
			} = separatorPositions;
			
			// å¦‚æœåˆ†éš”ç·šé‚„æ²’æœ‰æ’å…¥ï¼Œåœ¨æœ€å¾Œæ’å…¥
			if (!upperSeparator2Added) {
				const separator = createSeparator(`Î¼ + 2Ïƒ = ${separatorPositions.upperThreshold2.toFixed(2)}`, 'separator-upper-2');
				container.appendChild(separator);
			}
			
			if (!upperSeparatorAdded) {
				const separator = createSeparator(`Î¼ + Ïƒ = ${separatorPositions.upperThreshold.toFixed(2)}`, 'separator-upper');
				container.appendChild(separator);
			}
			
			if (!avgSeparatorAdded) {
				const separator = createSeparator(`Î¼ = ${separatorPositions.avgScore.toFixed(2)}`, 'separator-avg');
				container.appendChild(separator);
			}
			
			if (!lowerSeparatorAdded) {
				const separator = createSeparator(`Î¼ - Ïƒ = ${separatorPositions.lowerThreshold.toFixed(2)}`, 'separator-lower');
				container.appendChild(separator);
			}
			
			if (!lowerSeparator2Added) {
				const separator = createSeparator(`Î¼ - 2Ïƒ = ${separatorPositions.lowerThreshold2.toFixed(2)}`, 'separator-lower-2');
				container.appendChild(separator);
			}
		}
		
		// å‰µå»ºåˆ†éš”ç·šå…ƒç´ çš„è¼”åŠ©å‡½æ•¸
		function createSeparator(text, id, color = 'var(--danger)') {
			const separator = document.createElement('div');
			separator.className = 'list-item ranking-separator';
			separator.id = id;
			separator.innerHTML = `
				<div style="text-align: center; width: 100%; color: ${color}; font-weight: bold;">
					${text}
				</div>`;
			separator.addEventListener('contextmenu', function(e) {
				e.preventDefault();
				showSeparatorContextMenu(e, text);
			});
			return separator;
		}

        function refreshStats() {
            games = JSON.parse(localStorage.getItem('games')) || {};
            updateStatsGameSelect();
            const gameId = document.getElementById('statsGameSelect').value;
            if (gameId) loadStats();
        }

        function clearStats() {
            const gameId = document.getElementById('statsGameSelect').value;
            if (!gameId) { alert('è«‹å…ˆé¸æ“‡éŠæˆ²'); return; }
            if (confirm('ç¢ºå®šè¦æ¸…é™¤é€™å€‹éŠæˆ²çš„æ‰€æœ‰æŠ•ç¥¨æ•¸æ“šå—ï¼Ÿæ­¤æ“ä½œç„¡æ³•å¾©åŸï¼')) {
                const game = games[gameId];
                game.items.forEach(item => {
                    item.score = 1500; item.votes = 0; item.wins = 0; item.losses = 0;
                    item.moods = [];
                    item.scoreHistory = [{timestamp: Date.now(), score: 1500}];
                });
                game.votes = [];
                localStorage.setItem('games', JSON.stringify(games));
                syncData();
                loadStats(); alert('çµ±è¨ˆæ•¸æ“šå·²æ¸…é™¤');
            }
        }
		
		// ä¸€èˆ¬é¡¹ç›®å³é”®èœå•å‡½æ•°
		function showItemContextMenu(event, itemId, gameId) {
			const contextMenu = document.getElementById('contextMenu');
			const contextMenuList = document.getElementById('contextMenuList');
			contextMenuList.innerHTML = '';
			
			const game = games[gameId];
			const item = game.items.find(i => i.id === itemId);
			if (!item) return;
			
			// å¤åˆ¶æ ‡é¢˜æ–‡å­—æŒ‰é’®
			const copyTitleBtn = document.createElement('li');
			copyTitleBtn.innerHTML = `<button class="btn btn-info" style="width: 100%; text-align: left;">è¤‡è£½æ¨™é¡Œæ–‡å­—</button>`;
			copyTitleBtn.onclick = function() {
				navigator.clipboard.writeText(item.name);
				hideContextMenu();
			};
			
			// å¤åˆ¶å…¨è¡Œæ–‡å­—æŒ‰é’®
			const copyFullLineBtn = document.createElement('li');
			copyFullLineBtn.innerHTML = `<button class="btn btn-info" style="width: 100%; text-align: left;">è¤‡è£½å…¨è¡Œæ–‡å­—</button>`;
			copyFullLineBtn.onclick = function() {
				const rankingItem = document.getElementById(`ranking-item-${item.id}`);
				let fullText = rankingItem ? rankingItem.innerText.replaceAll('\n','  ') : '[missing item]' ;
				navigator.clipboard.writeText(fullText);
				hideContextMenu();
			};
			
			// å¤åˆ¶æ•´ä¸ªæ’è¡Œæ¦œæŒ‰é’®
			const copyFullRankingBtn = document.createElement('li');
			copyFullRankingBtn.innerHTML = `<button class="btn btn-info" style="width: 100%; text-align: left;">è¤‡è£½å…¨éƒ¨å¯è¦‹é …ç›®</button>`;
			copyFullRankingBtn.onclick = function() {
				copyFullRanking(gameId);
				hideContextMenu();
			};
			
			// é»ç®—ä»¥ä¸Šé …ç›®(åŒ…æ‹¬æœ¬è¡Œ)æŒ‰é’®
			const countAboveBtn = document.createElement('li');
			countAboveBtn.innerHTML = `<button class="btn btn-info" style="width: 100%; text-align: left;">é»ç®—æœ¬è¡ŒåŠä»¥ä¸Šé …ç›®</button>`;
			countAboveBtn.onclick = function() {
				countItemsAboveItem(itemId, gameId);
				hideContextMenu();
			};
			
			// é»ç®—ä»¥ä¸‹é …ç›®(åŒ…æ‹¬æœ¬è¡Œ)æŒ‰é’®
			const countBelowBtn = document.createElement('li');
			countBelowBtn.innerHTML = `<button class="btn btn-info" style="width: 100%; text-align: left;">é»ç®—æœ¬è¡ŒåŠä»¥ä¸‹é …ç›®</button>`;
			countBelowBtn.onclick = function() {
				countItemsBelowItem(itemId, gameId);
				hideContextMenu();
			};
			
			// å†»ç»“æŒ‰é’®
			const toggleFreezeBtn = document.createElement('li');
			toggleFreezeBtn.innerHTML = `<button class="btn btn-frozen" style="width: 100%; text-align: left;">${item.frozen ? 'è§£é™¤å‡çµ' : 'å‡çµ'}</button>`;
			toggleFreezeBtn.onclick = function() {
				item.frozen = !item.frozen;
				localStorage.setItem('games', JSON.stringify(games));
				syncData();
				const rankingItem = document.getElementById(`ranking-item-${itemId}`);
				if (rankingItem) {
					if (item.frozen) {
						rankingItem.classList.add('frozen');
					} else {
						rankingItem.classList.remove('frozen');
					}
				}
				hideContextMenu();
			};
			
			// å†»ç»“ä»¥ä¸Šå…¨éƒ¨é¡¹ç›®æŒ‰é’®
			const freezeAboveBtn = document.createElement('li');
			freezeAboveBtn.innerHTML = `<button class="btn btn-frozen" style="width: 100%; text-align: left;">å‡çµä»¥ä¸Šå…¨éƒ¨é …ç›®</button>`;
			freezeAboveBtn.onclick = function() {
				freezeItemsAboveItem(itemId, gameId, true);
				hideContextMenu();
			};
			
			// è§£é™¤å†»ç»“ä»¥ä¸Šå…¨éƒ¨é¡¹ç›®æŒ‰é’®
			const unfreezeAboveBtn = document.createElement('li');
			unfreezeAboveBtn.innerHTML = `<button class="btn btn-frozen" style="width: 100%; text-align: left;">è§£é™¤å‡çµä»¥ä¸Šå…¨éƒ¨é …ç›®</button>`;
			unfreezeAboveBtn.onclick = function() {
				freezeItemsAboveItem(itemId, gameId, false);
				hideContextMenu();
			};
			
			// å†»ç»“ä»¥ä¸‹å…¨éƒ¨é¡¹ç›®æŒ‰é’®
			const freezeBelowBtn = document.createElement('li');
			freezeBelowBtn.innerHTML = `<button class="btn btn-frozen" style="width: 100%; text-align: left;">å‡çµä»¥ä¸‹å…¨éƒ¨é …ç›®</button>`;
			freezeBelowBtn.onclick = function() {
				freezeItemsBelowItem(itemId, gameId, true);
				hideContextMenu();
			};
			
			// è§£é™¤å†»ç»“ä»¥ä¸‹å…¨éƒ¨é¡¹ç›®æŒ‰é’®
			const unfreezeBelowBtn = document.createElement('li');
			unfreezeBelowBtn.innerHTML = `<button class="btn btn-frozen" style="width: 100%; text-align: left;">è§£é™¤å‡çµä»¥ä¸‹å…¨éƒ¨é …ç›®</button>`;
			unfreezeBelowBtn.onclick = function() {
				freezeItemsBelowItem(itemId, gameId, false);
				hideContextMenu();
			};
			
			contextMenuList.appendChild(copyTitleBtn);
			contextMenuList.appendChild(copyFullLineBtn);
			contextMenuList.appendChild(copyFullRankingBtn);
			contextMenuList.appendChild(countAboveBtn);
			contextMenuList.appendChild(countBelowBtn);
			contextMenuList.appendChild(toggleFreezeBtn);
			contextMenuList.appendChild(freezeBelowBtn);
			contextMenuList.appendChild(unfreezeBelowBtn);
			contextMenuList.appendChild(freezeAboveBtn);
			contextMenuList.appendChild(unfreezeAboveBtn);
			
			contextMenu.style.display = 'block';
			contextMenu.style.left = `${event.pageX}px`;
			contextMenu.style.top = `${event.pageY}px`;
			document.addEventListener('click', hideContextMenuOnClick);
		}
		
		// åˆ†éš”ç·šå³é”®èœå–®å‡½æ•¸
		function showSeparatorContextMenu(event, separatorText) {
			const contextMenu = document.getElementById('contextMenu');
			const contextMenuList = document.getElementById('contextMenuList');
			contextMenuList.innerHTML = '';
			
			const gameId = document.getElementById('statsGameSelect').value;
			if (!gameId) return;
			
			// å¤åˆ¶æ–‡å­—æŒ‰é’®
			const copyTextBtn = document.createElement('li');
			copyTextBtn.innerHTML = `<button class="btn btn-info" style="width: 100%; text-align: left;">è¤‡è£½æ–‡å­—</button>`;
			copyTextBtn.onclick = function() {
				navigator.clipboard.writeText(separatorText);
				hideContextMenu();
			};
			
			// å¤åˆ¶æ•´ä¸ªæ’è¡Œæ¦œæŒ‰é’®
			const copyFullRankingBtn = document.createElement('li');
			copyFullRankingBtn.innerHTML = `<button class="btn btn-info" style="width: 100%; text-align: left;">è¤‡è£½å…¨éƒ¨å¯è¦‹é …ç›®</button>`;
			copyFullRankingBtn.onclick = function() {
				copyFullRanking(gameId);
				hideContextMenu();
			};
			
			// é»ç®—ä»¥ä¸Šé …ç›®(åŒ…æ‹¬æœ¬è¡Œ)æŒ‰é’®
			const countAboveBtn = document.createElement('li');
			countAboveBtn.innerHTML = `<button class="btn btn-info" style="width: 100%; text-align: left;">é»ç®—ä»¥ä¸Šé …ç›®</button>`;
			countAboveBtn.onclick = function() {
				countItemsAboveSeparator(separatorText);
				hideContextMenu();
			};
			
			// é»ç®—ä»¥ä¸‹é …ç›®(åŒ…æ‹¬æœ¬è¡Œ)æŒ‰é’®
			const countBelowBtn = document.createElement('li');
			countBelowBtn.innerHTML = `<button class="btn btn-info" style="width: 100%; text-align: left;">é»ç®—ä»¥ä¸‹é …ç›®</button>`;
			countBelowBtn.onclick = function() {
				countItemsBelowSeparator(separatorText);
				hideContextMenu();
			};
			
			// å†»ç»“ä»¥ä¸Šå…¨éƒ¨é¡¹ç›®æŒ‰é’®
			const freezeAboveBtn = document.createElement('li');
			freezeAboveBtn.innerHTML = `<button class="btn btn-frozen" style="width: 100%; text-align: left;">å‡çµä»¥ä¸Šå…¨éƒ¨é …ç›®</button>`;
			freezeAboveBtn.onclick = function() {
				freezeItemsAboveSeparator(separatorText, true);
				hideContextMenu();
			};
			
			// è§£é™¤å†»ç»“ä»¥ä¸Šå…¨éƒ¨é¡¹ç›®æŒ‰é’®
			const unfreezeAboveBtn = document.createElement('li');
			unfreezeAboveBtn.innerHTML = `<button class="btn btn-frozen" style="width: 100%; text-align: left;">è§£é™¤å‡çµä»¥ä¸Šå…¨éƒ¨é …ç›®</button>`;
			unfreezeAboveBtn.onclick = function() {
				freezeItemsAboveSeparator(separatorText, false);
				hideContextMenu();
			};
			
			// å†»ç»“ä»¥ä¸‹å…¨éƒ¨é¡¹ç›®æŒ‰é’®
			const freezeBelowBtn = document.createElement('li');
			freezeBelowBtn.innerHTML = `<button class="btn btn-frozen" style="width: 100%; text-align: left;">å‡çµä»¥ä¸‹å…¨éƒ¨é …ç›®</button>`;
			freezeBelowBtn.onclick = function() {
				freezeItemsBelowSeparator(separatorText, true);
				hideContextMenu();
			};
			
			// è§£é™¤å†»ç»“ä»¥ä¸‹å…¨éƒ¨é¡¹ç›®æŒ‰é’®
			const unfreezeBelowBtn = document.createElement('li');
			unfreezeBelowBtn.innerHTML = `<button class="btn btn-frozen" style="width: 100%; text-align: left;">è§£é™¤å‡çµä»¥ä¸‹å…¨éƒ¨é …ç›®</button>`;
			unfreezeBelowBtn.onclick = function() {
				freezeItemsBelowSeparator(separatorText, false);
				hideContextMenu();
			};
			
			contextMenuList.appendChild(copyTextBtn);
			contextMenuList.appendChild(copyFullRankingBtn);
			contextMenuList.appendChild(countAboveBtn);
			contextMenuList.appendChild(countBelowBtn);
			contextMenuList.appendChild(freezeBelowBtn);
			contextMenuList.appendChild(unfreezeBelowBtn);
			contextMenuList.appendChild(freezeAboveBtn);
			contextMenuList.appendChild(unfreezeAboveBtn);
			
			contextMenu.style.display = 'block';
			contextMenu.style.left = `${event.pageX}px`;
			contextMenu.style.top = `${event.pageY}px`;
			document.addEventListener('click', hideContextMenuOnClick);
		}
		
		// é»ç®—é …ç›®ä»¥ä¸Šé …ç›®çš„å‡½æ•¸
		function countItemsAboveItem(itemId, gameId) {
			const rankingList = document.getElementById('rankingList');
			const children = Array.from(rankingList.children);
			
			let itemFound = false;
			let count = 0;
			
			for (let i = 0; i < children.length; i++) {
				const child = children[i];
				
				// è·³è¿‡éšè—çš„é¡¹ç›®
				if (child.style.display === 'none') {
					continue;
				}
				
				// æ£€æŸ¥æ˜¯å¦ä¸ºä¸€èˆ¬é¡¹ç›®ï¼ˆä¸æ˜¯åˆ†éš”çº¿ï¼‰
				if (child.classList.contains('ranking-item') && !child.classList.contains('ranking-separator')) {
					// æ£€æŸ¥æ˜¯å¦æ‰¾åˆ°ç›®æ ‡é¡¹ç›®
					if (child.id === `ranking-item-${itemId}`) {
						itemFound = true;
						count++; // åŒ…æ‹¬è‡ªå·±
					} else if (!itemFound) {
						count++;
					}
				}
			}
			
			if (itemFound) {
				alert(`æœ¬è¡ŒåŠä»¥ä¸Šé …ç›®å…±æœ‰ ${count} å€‹ã€‚`);
			} else {
				alert('é …ç›®æœªåœ¨ç•¶å‰é¡¯ç¤ºçš„æ’è¡Œæ¦œä¸­ã€‚');
			}
		}

		// é»ç®—é …ç›®ä»¥ä¸‹é …ç›®çš„å‡½æ•¸
		function countItemsBelowItem(itemId, gameId) {
			const rankingList = document.getElementById('rankingList');
			const children = Array.from(rankingList.children);
			
			let itemFound = false;
			let count = 0;
			
			for (let i = 0; i < children.length; i++) {
				const child = children[i];
				
				// è·³è¿‡éšè—çš„é¡¹ç›®
				if (child.style.display === 'none') {
					continue;
				}
				
				// æ£€æŸ¥æ˜¯å¦ä¸ºä¸€èˆ¬é¡¹ç›®ï¼ˆä¸æ˜¯åˆ†éš”çº¿ï¼‰
				if (child.classList.contains('ranking-item') && !child.classList.contains('ranking-separator')) {
					// æ£€æŸ¥æ˜¯å¦æ‰¾åˆ°ç›®æ ‡é¡¹ç›®
					if (child.id === `ranking-item-${itemId}`) {
						itemFound = true;
					}
					
					if (itemFound) {
						count++;
					}
				}
			}
			
			if (itemFound) {
				alert(`æœ¬è¡ŒåŠä»¥ä¸‹é …ç›®å…±æœ‰ ${count} å€‹ã€‚`);
			} else {
				alert('é …ç›®æœªåœ¨ç•¶å‰é¡¯ç¤ºçš„æ’è¡Œæ¦œä¸­ã€‚');
			}
		}

		// é»ç®—åˆ†éš”ç·šä»¥ä¸Šé …ç›®çš„å‡½æ•¸
		function countItemsAboveSeparator(separatorText) {
			const rankingList = document.getElementById('rankingList');
			const children = Array.from(rankingList.children);
			
			let separatorFound = false;
			let count = 0;
			
			for (let i = 0; i < children.length; i++) {
				const child = children[i];
				
				// è·³è¿‡éšè—çš„é¡¹ç›®
				if (child.style.display === 'none') {
					continue;
				}
				
				// æ£€æŸ¥æ˜¯å¦ä¸ºåˆ†éš”çº¿
				if (child.classList.contains('ranking-separator')) {
					const separatorContent = child.querySelector('div').textContent;
					if (separatorContent.trim() === separatorText.trim()) {
						separatorFound = true;
						// æ‰¾åˆ°ç›®æ ‡åˆ†éš”çº¿åç»§ç»­å¾ªç¯ï¼Œä½†ä¸åœæ­¢ï¼Œè·³è¿‡è¿™æ¡åˆ†éš”çº¿
						continue;
					}
				}
				
				// å¦‚æœæ˜¯é¡¹ç›®ï¼ˆä¸æ˜¯åˆ†éš”çº¿ï¼‰ï¼Œä¸”åˆ†éš”çº¿è¿˜æœªæ‰¾åˆ°
				if (!separatorFound && child.classList.contains('ranking-item')) {
					count++;
				}
			}
			
			if (separatorFound) {
				alert(`ä»¥ä¸Šé …ç›®å…±æœ‰ ${count} å€‹ã€‚`);
			} else {
				alert('åˆ†éš”ç·šæœªåœ¨ç•¶å‰é¡¯ç¤ºçš„æ’è¡Œæ¦œä¸­ã€‚');
			}
		}

		// é»ç®—åˆ†éš”ç·šä»¥ä¸‹é …ç›®çš„å‡½æ•¸
		function countItemsBelowSeparator(separatorText) {
			const rankingList = document.getElementById('rankingList');
			const children = Array.from(rankingList.children);
			
			let separatorFound = false;
			let count = 0;
			
			for (let i = 0; i < children.length; i++) {
				const child = children[i];
				
				// è·³è¿‡éšè—çš„é¡¹ç›®
				if (child.style.display === 'none') {
					continue;
				}
				
				// æ£€æŸ¥æ˜¯å¦ä¸ºåˆ†éš”çº¿
				if (child.classList.contains('ranking-separator')) {
					const separatorContent = child.querySelector('div').textContent;
					if (separatorContent.trim() === separatorText.trim()) {
						separatorFound = true;
						// æ‰¾åˆ°ç›®æ ‡åˆ†éš”çº¿åç»§ç»­å¾ªç¯
						continue;
					}
				}
				
				// å¦‚æœæ˜¯é¡¹ç›®ï¼ˆä¸æ˜¯åˆ†éš”çº¿ï¼‰ï¼Œä¸”åˆ†éš”çº¿å·²æ‰¾åˆ°
				if (separatorFound && child.classList.contains('ranking-item')) {
					count++;
				}
			}
			
			if (separatorFound) {
				alert(`ä»¥ä¸‹é …ç›®å…±æœ‰ ${count} å€‹ã€‚`);
			} else {
				alert('åˆ†éš”ç·šæœªåœ¨ç•¶å‰é¡¯ç¤ºçš„æ’è¡Œæ¦œä¸­ã€‚');
			}
		}
		
		// å†»ç»“/è§£å†» é¡¹ç›®ä»¥ä¸Šæ‰€æœ‰é¡¹ç›®çš„å‡½æ•°
		function freezeItemsAboveItem(itemId, gameId, freeze) {
			const game = games[gameId];
			const sortBy = document.getElementById('sortBy').value;
			let sortedItems = [...game.items];
			
			// åº”ç”¨å½“å‰æ’åº
			sortedItems = sortRankingItems(sortedItems, sortBy, game);
			
			// åº”ç”¨å½“å‰çš„å¿ƒæƒ…ç­›é€‰
			const currentStatsMoodLogic = document.getElementById('statsMoodLogic').value;
			if (statsMoodFilters.length > 0) {
				sortedItems = applyMoodFilter(sortedItems, statsMoodFilters, currentStatsMoodLogic);
			}
			
			// åº”ç”¨å½“å‰çš„æœç´¢ç­›é€‰
			const searchText = document.getElementById('rankingSearch').value.toLowerCase();
			if (searchText) {
				sortedItems = sortedItems.filter(item => item.name.toLowerCase().includes(searchText));
			}
			
			// æ‰¾åˆ°å½“å‰é¡¹ç›®åœ¨ç­›é€‰åçš„æ’åºåˆ—è¡¨ä¸­çš„ä½ç½®
			let itemIndex = -1;
			for (let i = 0; i < sortedItems.length; i++) {
				if (sortedItems[i].id === itemId) {
					itemIndex = i;
					break;
				}
			}
			
			if (itemIndex === -1) return;
			
			// å†»ç»“/è§£å†»å½“å‰é¡¹ç›®ä»¥ä¸Šçš„æ‰€æœ‰é¡¹ç›®(åŒ…æ‹¬è‡ªå·±)ï¼Œä½†åªé’ˆå¯¹ç­›é€‰åæ˜¾ç¤ºçš„é¡¹ç›®
			for (let i = 0; i <= itemIndex; i++) {
				const item = game.items.find(it => it.id === sortedItems[i].id);
				if (item) {
					item.frozen = freeze;
				}
			}
			
			localStorage.setItem('games', JSON.stringify(games));
			syncData();
			loadStats(); // åˆ·æ–°ç»Ÿè®¡é¡µé¢ä»¥æ˜¾ç¤ºæ›´æ–°åçš„çŠ¶æ€
		}
		
		// å†»ç»“/è§£å†» é¡¹ç›®ä»¥ä¸‹æ‰€æœ‰é¡¹ç›®(åŒ…æ‹¬è‡ªå·±)
		function freezeItemsBelowItem(itemId, gameId, freeze) {
			const game = games[gameId];
			const sortBy = document.getElementById('sortBy').value;
			let sortedItems = [...game.items];
			
			// åº”ç”¨å½“å‰æ’åº
			sortedItems = sortRankingItems(sortedItems, sortBy, game);
			
			// åº”ç”¨å½“å‰çš„å¿ƒæƒ…ç­›é€‰
			const currentStatsMoodLogic = document.getElementById('statsMoodLogic').value;
			if (statsMoodFilters.length > 0) {
				sortedItems = applyMoodFilter(sortedItems, statsMoodFilters, currentStatsMoodLogic);
			}
			
			// åº”ç”¨å½“å‰çš„æœç´¢ç­›é€‰
			const searchText = document.getElementById('rankingSearch').value.toLowerCase();
			if (searchText) {
				sortedItems = sortedItems.filter(item => item.name.toLowerCase().includes(searchText));
			}
			
			// æ‰¾åˆ°å½“å‰é¡¹ç›®åœ¨ç­›é€‰åçš„æ’åºåˆ—è¡¨ä¸­çš„ä½ç½®
			let itemIndex = -1;
			for (let i = 0; i < sortedItems.length; i++) {
				if (sortedItems[i].id === itemId) {
					itemIndex = i;
					break;
				}
			}
			
			if (itemIndex === -1) return;
			
			// å†»ç»“/è§£å†»å½“å‰é¡¹ç›®ä»¥ä¸‹çš„æ‰€æœ‰é¡¹ç›®(åŒ…æ‹¬è‡ªå·±)ï¼Œä½†åªé’ˆå¯¹ç­›é€‰åæ˜¾ç¤ºçš„é¡¹ç›®
			for (let i = itemIndex; i < sortedItems.length; i++) {
				const item = game.items.find(it => it.id === sortedItems[i].id);
				if (item) {
					item.frozen = freeze;
				}
			}
			
			localStorage.setItem('games', JSON.stringify(games));
			syncData();
			loadStats(); // åˆ·æ–°ç»Ÿè®¡é¡µé¢ä»¥æ˜¾ç¤ºæ›´æ–°åçš„çŠ¶æ€
		}
		
		// å†»ç»“/è§£å†» åˆ†éš”çº¿ä»¥ä¸Šé¡¹ç›®çš„å‡½æ•°
		function freezeItemsAboveSeparator(separatorText, freeze) {
			const gameId = document.getElementById('statsGameSelect').value;
			if (!gameId) return;
			
			const game = games[gameId];
			const sortBy = document.getElementById('sortBy').value;
			let sortedItems = [...game.items];
			
			// åº”ç”¨å½“å‰çš„å¿ƒæƒ…ç­›é€‰
			const currentStatsMoodLogic = document.getElementById('statsMoodLogic').value;
			if (statsMoodFilters.length > 0) {
				sortedItems = applyMoodFilter(sortedItems, statsMoodFilters, currentStatsMoodLogic);
			}
			
			// åº”ç”¨å½“å‰çš„æœç´¢ç­›é€‰
			const searchText = document.getElementById('rankingSearch').value.toLowerCase();
			if (searchText) {
				sortedItems = sortedItems.filter(item => item.name.toLowerCase().includes(searchText));
			}
			
			// åº”ç”¨å½“å‰æ’åº
			sortedItems = sortRankingItems(sortedItems, sortBy, game);
			
			// æ‰¾åˆ°åˆ†éš”çº¿åœ¨å½“å‰æ˜¾ç¤ºåˆ—è¡¨ä¸­çš„ä½ç½®
			let separatorIndex = -1;
			
			// è®¡ç®—ç»Ÿè®¡ä¿¡æ¯ç”¨äºç¡®å®šåˆ†éš”çº¿ä½ç½®
			const stats = calculateBasicStats(game);
			
			if (separatorText.includes('Î¼ + 2Ïƒ')) {
				for (let j = 0; j < sortedItems.length; j++) {
					if (sortedItems[j].score <= stats.upperThreshold2) {
						separatorIndex = j;
						break;
					}
				}
			} else if (separatorText.includes('Î¼ + Ïƒ')) {
				for (let j = 0; j < sortedItems.length; j++) {
					if (sortedItems[j].score <= stats.upperThreshold) {
						separatorIndex = j;
						break;
					}
				}
			} else if (separatorText.includes('Î¼ - Ïƒ')) {
				for (let j = 0; j < sortedItems.length; j++) {
					if (sortedItems[j].score < stats.lowerThreshold) {
						separatorIndex = j;
						break;
					}
				}
			} else if (separatorText.includes('Î¼ - 2Ïƒ')) {
				for (let j = 0; j < sortedItems.length; j++) {
					if (sortedItems[j].score < stats.lowerThreshold2) {
						separatorIndex = j;
						break;
					}
				}
			}
			
			if (separatorIndex === -1) {
				separatorIndex = sortedItems.length;
			}
			
			// å†»ç»“/è§£å†»å½“å‰æ˜¾ç¤ºåˆ—è¡¨ä¸­åˆ†éš”çº¿ä»¥ä¸Šçš„æ‰€æœ‰é¡¹ç›®(ä¸åŒ…æ‹¬åˆ†éš”çº¿æœ¬èº«)
			for (let i = 0; i < separatorIndex; i++) {
				const item = game.items.find(it => it.id === sortedItems[i].id);
				if (item) {
					item.frozen = freeze;
				}
			}
			
			localStorage.setItem('games', JSON.stringify(games));
			syncData();
			loadStats(); // åˆ·æ–°ç»Ÿè®¡é¡µé¢ä»¥æ˜¾ç¤ºæ›´æ–°åçš„çŠ¶æ€
		}

		// å†»ç»“/è§£å†» åˆ†éš”çº¿ä»¥ä¸‹é¡¹ç›®çš„å‡½æ•°
		function freezeItemsBelowSeparator(separatorText, freeze) {
			const gameId = document.getElementById('statsGameSelect').value;
			if (!gameId) return;
			
			const game = games[gameId];
			const sortBy = document.getElementById('sortBy').value;
			let sortedItems = [...game.items];
			
			// åº”ç”¨å½“å‰çš„å¿ƒæƒ…ç­›é€‰
			const currentStatsMoodLogic = document.getElementById('statsMoodLogic').value;
			if (statsMoodFilters.length > 0) {
				sortedItems = applyMoodFilter(sortedItems, statsMoodFilters, currentStatsMoodLogic);
			}
			
			// åº”ç”¨å½“å‰çš„æœç´¢ç­›é€‰
			const searchText = document.getElementById('rankingSearch').value.toLowerCase();
			if (searchText) {
				sortedItems = sortedItems.filter(item => item.name.toLowerCase().includes(searchText));
			}
			
			// åº”ç”¨å½“å‰æ’åº
			sortedItems = sortRankingItems(sortedItems, sortBy, game);
			
			// æ‰¾åˆ°åˆ†éš”çº¿åœ¨å½“å‰æ˜¾ç¤ºåˆ—è¡¨ä¸­çš„ä½ç½®
			let separatorIndex = -1;
			
			// è®¡ç®—ç»Ÿè®¡ä¿¡æ¯ç”¨äºç¡®å®šåˆ†éš”çº¿ä½ç½®
			const stats = calculateBasicStats(game);
			
			if (separatorText.includes('Î¼ + 2Ïƒ')) {
				for (let j = 0; j < sortedItems.length; j++) {
					if (sortedItems[j].score <= stats.upperThreshold2) {
						separatorIndex = j;
						break;
					}
				}
			} else if (separatorText.includes('Î¼ + Ïƒ')) {
				for (let j = 0; j < sortedItems.length; j++) {
					if (sortedItems[j].score <= stats.upperThreshold) {
						separatorIndex = j;
						break;
					}
				}
			} else if (separatorText.includes('Î¼ - Ïƒ')) {
				for (let j = 0; j < sortedItems.length; j++) {
					if (sortedItems[j].score < stats.lowerThreshold) {
						separatorIndex = j;
						break;
					}
				}
			} else if (separatorText.includes('Î¼ - 2Ïƒ')) {
				for (let j = 0; j < sortedItems.length; j++) {
					if (sortedItems[j].score < stats.lowerThreshold2) {
						separatorIndex = j;
						break;
					}
				}
			}
			
			if (separatorIndex === -1) {
				separatorIndex = sortedItems.length;
			}
			
			// å†»ç»“/è§£å†»å½“å‰æ˜¾ç¤ºåˆ—è¡¨ä¸­åˆ†éš”çº¿ä»¥ä¸‹çš„æ‰€æœ‰é¡¹ç›®
			for (let i = separatorIndex; i < sortedItems.length; i++) {
				const item = game.items.find(it => it.id === sortedItems[i].id);
				if (item) {
					item.frozen = freeze;
				}
			}
			
			localStorage.setItem('games', JSON.stringify(games));
			syncData();
			loadStats(); // åˆ·æ–°ç»Ÿè®¡é¡µé¢ä»¥æ˜¾ç¤ºæ›´æ–°åçš„çŠ¶æ€
		}
		
		// ç²å–æ’åºæ–¹å¼çš„åç¨±
		function getSortByName(sortBy) {
			const sortNames = {
				'rank': 'ä¾åæ¬¡',
				'score': 'ä¾åˆ†æ•¸',
				'error': 'ä¾èª¤å·®',
				'winRate': 'ä¾å‹ç‡',
				'volatility': 'ä¾æ³¢å‹•',
				'votes': 'ä¾ç¥¨æ¬¡',
				'time': 'ä¾æ–°åŠ '
			};
			return sortNames[sortBy] || sortBy;
		}
		
		// å¤åˆ¶æ•´ä¸ªæ’è¡Œæ¦œçš„å‡½æ•°
		function copyFullRanking(gameId) {
			const game = games[gameId];
			const rankingList = document.getElementById('rankingList');
			const rankingTitle = document.getElementById('rankingTitle') ;
			
			let rankingText = `${game.name} ${rankingTitle.innerText} | ${getSortByName(document.getElementById('sortBy').value)} æ’åº\n`;
			
			// ç›´æ¥ä»é¡µé¢æå–å½“å‰æ˜¾ç¤ºçš„æ’è¡Œæ¦œæ–‡å­—ï¼Œç¡®ä¿æ¢è¡Œæ­£ç¡®
			// rankingText += [...rankingList.childNodes].map(x=>x.innerText.replaceAll('\n','  ')).join('\n') ;
			rankingText += [...rankingList.childNodes].map(x=>x.innerText).filter(x=>!x.includes('\n\t')).map(x=>x.replaceAll('\n','  ')).join('\n') ;
			navigator.clipboard.writeText(rankingText);
		}

		function hideContextMenu() {
			const contextMenu = document.getElementById('contextMenu');
			contextMenu.style.display = 'none';
			document.removeEventListener('click', hideContextMenuOnClick);
		}

		function hideContextMenuOnClick(event) {
			const contextMenu = document.getElementById('contextMenu');
			if (!contextMenu.contains(event.target)) {
				hideContextMenu();
			}
		}
		
		// å¹´åº¦çƒ­é—¨ç›¸å…³å‡½æ•°
		function showAnnualHot(amount=-1) {
			// æ”¶é›†æ‰€æœ‰æ¸¸æˆä¸­æœ€è¿‘366å¤©çš„æŠ•ç¥¨æ•°æ®
			const annualHotData = collectAnnualHotData();
			
			if (annualHotData.length === 0) {
				alert('æœ€è¿‘366æ—¥å…§æ²’æœ‰æŠ•ç¥¨æ•¸æ“š');
				return;
			}
			
			
			// annualHotData.sort((a, b) => b.voteCount - a.voteCount); // æŒ‰ç…§æŠ•ç¥¨æ¬¡æ•°æ’åºï¼Œå–å‰å¹¾å
			
			annualHotData.sort((a, b) => {
			
				// å…ˆæŒ‰ åˆ†æ•°å˜åŠ¨ å¤§è‡³å°‘ æ’
				const A_scoreChange = a.scoreChange ;
				const B_scoreChange = b.scoreChange ;
				if ( A_scoreChange != B_scoreChange ) return B_scoreChange - A_scoreChange ;

				// å†æŒ‰ æŠ•ç¥¨ å¤šè‡³å°‘ æ’
				return b.voteCount - a.voteCount ;
			});


			// const top = annualHotData.slice(0, amount);
			const top = amount > 0 ?
				annualHotData.slice(0, amount) : // æŒ‡å®šé¡¯ç¤ºå¤šå°‘é …
				
				// å¦‚ç„¡æŒ‡å®šå¤šå°‘é …, å‰‡åªé¡¯ç¤º æ­£åˆ†æ•°å˜åŠ¨ âˆ§ ç¥¨æ¬¡è‡³å°‘æœ‰10 çš„é …ç›®
				annualHotData.filter( x => x.scoreChange > 0 && x.voteCount >= 10 ) ;
			
			// æ˜¾ç¤ºå¼¹çª—
			displayAnnualHotTable(top);
		}

		function collectAnnualHotData() {
			const annualData = [];
			const now = Date.now();
			const oneYearAgo = now - (366 * 24 * 60 * 60 * 1000);
			
			// éå†æ‰€æœ‰æ¸¸æˆ
			Object.values(games).forEach(game => {
				// è¿‡æ»¤å‡ºæœ€è¿‘366å¤©çš„æŠ•ç¥¨è®°å½•
				const recentVotes = game.votes.filter(vote => vote.timestamp >= oneYearAgo);
				
				if (recentVotes.length === 0) return;
				
				// ç»Ÿè®¡æ¯ä¸ªé¡¹ç›®çš„æŠ•ç¥¨æ¬¡æ•°
				const itemVoteCount = {};
				
				recentVotes.forEach(vote => {
					// ç»Ÿè®¡é¡¹ç›®1çš„æŠ•ç¥¨
					itemVoteCount[vote.item1] = (itemVoteCount[vote.item1] || 0) + 1;
					// ç»Ÿè®¡é¡¹ç›®2çš„æŠ•ç¥¨
					itemVoteCount[vote.item2] = (itemVoteCount[vote.item2] || 0) + 1;
				});
				
				// è®¡ç®—æ¯ä¸ªé¡¹ç›®çš„åˆ†æ•°å˜åŠ¨
				game.items.forEach(item => {
					const voteCount = itemVoteCount[item.id] || 0;
					
					if (voteCount > 0 && item.scoreHistory && item.scoreHistory.length >= 2) {
						// æ‰¾åˆ°æœ€è¿‘366å¤©å†…çš„ç¬¬ä¸€æ¬¡åˆ†æ•°è®°å½•
						const recentHistory = item.scoreHistory.filter(record => 
							record.timestamp >= oneYearAgo
						);
						
						if (recentHistory.length >= 2) {
							const oldestScore = recentHistory[0].score;
							const latestScore = recentHistory[recentHistory.length - 1].score;
							const scoreChange = latestScore - oldestScore;
							
							annualData.push({
								itemId: item.id,
								itemName: item.name,
								gameId: game.id,
								gameName: game.name,
								voteCount: voteCount,
								scoreChange: scoreChange,
								currentScore: item.score,
								oldestScore: oldestScore,
								latestScore: latestScore
							});
						} else if (item.scoreHistory.length >= 2) {
							// å¦‚æœæœ€è¿‘366å¤©å†…æ²¡æœ‰è¶³å¤Ÿçš„è®°å½•ï¼Œä½¿ç”¨æœ€æ—©å’Œæœ€è¿‘çš„è®°å½•
							const oldestRecord = item.scoreHistory[0];
							const latestRecord = item.scoreHistory[item.scoreHistory.length - 1];
							
							// æ£€æŸ¥æœ€æ—©çš„è®°å½•æ˜¯å¦åœ¨366å¤©å†…
							if (oldestRecord.timestamp >= oneYearAgo) {
								const scoreChange = latestRecord.score - oldestRecord.score;
								
								annualData.push({
									itemId: item.id,
									itemName: item.name,
									gameId: game.id,
									gameName: game.name,
									voteCount: voteCount,
									scoreChange: scoreChange,
									currentScore: item.score,
									oldestScore: oldestRecord.score,
									latestScore: latestRecord.score
								});
							}
						}
					}
				});
			});
			
			return annualData;
		}

		function displayAnnualHotTable(data) {
			const tbody = document.getElementById('annualHotBody');
			tbody.innerHTML = '';
			
			data.forEach((item, index) => {
				const row = document.createElement('tr');
				
				// ç¡®å®šåˆ†æ•°å˜åŒ–çš„æ ·å¼
				let scoreChangeClass = 'score-no-change';
				let scoreChangeText = 'Â±0';
				
				if (item.scoreChange > 0) {
					scoreChangeClass = 'score-increase';
					scoreChangeText = `+${item.scoreChange}`;
				} else if (item.scoreChange < 0) {
					scoreChangeClass = 'score-decrease';
					scoreChangeText = `${item.scoreChange}`;
				}
				
				row.innerHTML = `
					<td style="font-weight: bold; color: var(--primary);">${index + 1}</td>
					<td>${item.itemName}</td>
					<td>${item.gameName}</td>
					<td class="${scoreChangeClass}">${scoreChangeText}</td>
					<td style="font-weight: bold; color: var(--info);">${item.voteCount}</td>
					<td>${item.currentScore}</td>
				`;
				
				// æ·»åŠ ç‚¹å‡»è¡Œè·³è½¬åˆ°å¯¹åº”æ¸¸æˆç»Ÿè®¡çš„åŠŸèƒ½
				row.style.cursor = 'pointer';
				row.onclick = function() {
					closeAnnualHotModal();
					
					// åˆ‡æ¢åˆ°ç»Ÿè®¡é¡µé¢å¹¶é€‰æ‹©å¯¹åº”çš„æ¸¸æˆ
					showPage('stats');
					document.getElementById('statsGameSelect').value = item.gameId;
					loadStats(); // åŠ è½½ç»Ÿè®¡æ•¸æ“š
					collapseAllCharts() ; // æ”¶èµ·åœ–
					
					// æ‰“å¼€&æ»šåŠ¨ å›¾è¡¨
					const rankingItem = document.getElementById(`ranking-item-${item.itemId}`);
					if (rankingItem) {
						// å…ˆå±•å¼€å›¾è¡¨
						const chartContainer = rankingItem.querySelector('.score-chart-container');
						if (chartContainer) {
							// å±•å¼€å›¾è¡¨
							rankingItem.classList.add('expanded');
							expandedItemIds.push(item.itemId);
							localStorage.setItem('expandedItemIds', JSON.stringify(expandedItemIds));
							
							chartContainer.style.display = 'block';
							renderScoreChart(item.itemId, chartContainer);
							
							// æ»šåŠ¨åˆ°å›¾è¡¨åŒºåŸŸ
							chartContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
							
						} else {
							// å¦‚æœæ²¡æœ‰å›¾è¡¨å®¹å™¨ï¼Œç›´æ¥æ»šåŠ¨åˆ°é¡¹ç›®å¹¶æ˜¾ç¤ºé«˜äº®
							rankingItem.scrollIntoView({ behavior: 'smooth', block: 'center' });

							setTimeout(() => {
								// æ¸…é™¤ç°æœ‰åŠ¨ç”»
								rankingItem.style.animation = 'none';
								// å¼ºåˆ¶é‡ç»˜
								void rankingItem.offsetWidth;
								// åº”ç”¨é«˜äº®åŠ¨ç”»
								rankingItem.style.animation = 'highlightPulse 3s ease-in-out';
							}, 300);
						}
					}
				};
				
				tbody.appendChild(row);
			});
			
			// æ˜¾ç¤ºå¼¹çª—
			document.getElementById('annualHotModal').classList.remove('hidden');
		}

		function closeAnnualHotModal() {
			document.getElementById('annualHotModal').classList.add('hidden');
		}

		// ç‚¹å‡»å¼¹çª—å¤–éƒ¨å…³é—­çš„åŠŸèƒ½
		document.getElementById('annualHotModal').addEventListener('click', function(e) {
			if (e.target === this) {
				closeAnnualHotModal();
			}
		});

        function getFormattedDate() {
            const now = new Date();
            return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
        }
		
		// ç²å–æœ€å¾ŒæŠ•ç¥¨æ—¥æœŸ
		function getLastVoteDate(game) {
			if (!game.votes || game.votes.length == 0) {
				return null;
			}
			
			// æ‰¾å‡ºæœ€æ–°çš„æŠ•ç¥¨æ™‚é–“æˆ³
			let latestTimestamp = 0;
			game.votes.forEach(vote => {
				if (vote.timestamp > latestTimestamp) {
					latestTimestamp = vote.timestamp;
				}
			});
			
			if (latestTimestamp === 0) {
				return null;
			}
			
			// è½‰æ›ç‚ºYYYY-MM-DDæ ¼å¼
			const date = new Date(latestTimestamp);
			const year = date.getFullYear();
			const month = String(date.getMonth() + 1).padStart(2, '0');
			const day = String(date.getDate()).padStart(2, '0');
			
			const diffDays = ~~( ( Date.now() - date ) / (1000*60*60*24) ) ;
			
			return [`${year}-${month}-${day}`,`${diffDays}æ—¥å‰`] ;
		}

		function exportSettings() {
            const settingsData = {};
            Object.values(games).forEach(game => {
                settingsData[game.id] = {
                    id: game.id, name: game.name,
                    items: game.items.map(item => ({
                        id: item.id, name: item.name, links: item.links || [],
                        invalidLinks: item.invalidLinks || [], addedTime: item.addedTime,
                        moods: item.moods || [],
                        frozen: item.frozen || false,
                        scoreHistory: item.scoreHistory || []
                    }))
                };
            });
            downloadFile(settingsData, `è¨­å®š${getFormattedDate()}.json`);
        }

        function exportStats() {
            const statsData = {};
            Object.values(games).forEach(game => {
                statsData[game.id] = {
                    id: game.id, name: game.name, votes: game.votes,
                    items: game.items.map(item => ({
                        id: item.id, name: item.name, score: item.score, votes: item.votes,
                        wins: item.wins || 0, losses: item.losses || 0,
                        moods: item.moods || [],
                        frozen: item.frozen || false,
                        scoreHistory: item.scoreHistory || []
                    }))
                };
            });
            downloadFile(statsData, `çµ±è¨ˆ${getFormattedDate()}.json`);
        }

        function downloadFile(data, filename) {
            const dataStr = JSON.stringify(data, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url; link.download = filename; link.click();
            URL.revokeObjectURL(url);
        }

        function importSettings(event) { importFile(event, 'settings'); }
        function importStats(event) { importFile(event, 'stats'); }

        function importFile(event, type) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    const isSettings = type === 'settings';
                    const message = isSettings ? 'åŒ¯å…¥è¨­å®šå°‡æœƒè¦†è“‹ç¾æœ‰éŠæˆ²è¨­å®šï¼ˆä½†ä¿ç•™çµ±è¨ˆè³‡æ–™ï¼‰ï¼Œç¢ºå®šè¦ç¹¼çºŒå—ï¼Ÿ' : 'åŒ¯å…¥çµ±è¨ˆå°‡æœƒè¦†è“‹ç¾æœ‰æŠ•ç¥¨è³‡æ–™ï¼Œç¢ºå®šè¦ç¹¼çºŒå—ï¼Ÿ';
                    
                    if (confirm(message)) {
                        Object.values(importedData).forEach(importedGame => {
                            if (isSettings) {
                                if (games[importedGame.id]) {
                                    const existingGame = games[importedGame.id];
                                    importedGame.votes = existingGame.votes || [];
                                    importedGame.items.forEach(item => {
                                        const existingItem = existingGame.items.find(ei => ei.id === item.id);
                                        if (existingItem) {
                                            ['score', 'votes', 'wins', 'losses', 'frozen'].forEach(prop => 
                                                item[prop] = existingItem[prop] || (prop === 'score' ? 1500 : (prop === 'frozen' ? false : 0)));
                                            item.scoreHistory = existingItem.scoreHistory || [{timestamp: Date.now(), score: 1500}];
                                        } else {
                                            item.score = 1500; item.votes = 0; item.wins = 0; item.losses = 0;
                                            item.frozen = false;
                                            item.scoreHistory = [{timestamp: Date.now(), score: 1500}];
                                        }
                                        if (!item.links) item.links = item.link ? [item.link] : [];
                                        if (!item.invalidLinks) item.invalidLinks = [];
                                        if (!item.moods) item.moods = [];
                                        if (!item.frozen) item.frozen = false;
                                        if (!item.scoreHistory) item.scoreHistory = [{timestamp: Date.now(), score: 1500}];
                                    });
                                } else {
                                    importedGame.votes = [];
                                    importedGame.items.forEach(item => {
                                        item.score = 1500; item.votes = 0; item.wins = 0; item.losses = 0;
                                        item.frozen = false;
                                        if (!item.links) item.links = item.link ? [item.link] : [];
                                        if (!item.invalidLinks) item.invalidLinks = [];
                                        if (!item.moods) item.moods = [];
                                        if (!item.scoreHistory) item.scoreHistory = [{timestamp: Date.now(), score: 1500}];
                                    });
                                }
                                games[importedGame.id] = importedGame;
                            } else {
                                if (games[importedGame.id]) {
                                    games[importedGame.id].votes = importedGame.votes || [];
                                    importedGame.items.forEach(importedItem => {
                                        const item = games[importedGame.id].items.find(i => i.id === importedItem.id);
                                        if (item) {
                                            ['score', 'votes', 'wins', 'losses', 'moods', 'frozen', 'scoreHistory'].forEach(prop => 
                                                item[prop] = importedItem[prop] || (prop === 'score' ? 1500 : (prop === 'moods' ? [] : (prop === 'frozen' ? false : (prop === 'scoreHistory' ? [{timestamp: Date.now(), score: 1500}] : 0)))));
                                        }
                                    });
                                }
                            }
                        });
                        localStorage.setItem('games', JSON.stringify(games));
                        syncData();
                        if (isSettings) updateGamesList();
                        else loadStats();
                        alert(`${isSettings ? 'è¨­å®š' : 'çµ±è¨ˆ'}åŒ¯å…¥æˆåŠŸï¼`);
                    }
                } catch (error) { alert('åŒ¯å…¥å¤±æ•—ï¼šæª”æ¡ˆæ ¼å¼éŒ¯èª¤'); }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function clearAllInvalidLinks() {
            if (!selectedGameForEdit) { alert('è«‹å…ˆé¸æ“‡è¦ç·¨è¼¯çš„éŠæˆ²'); return; }
            
            if (confirm('ç¢ºå®šè¦åˆªé™¤æ‰€æœ‰é …ç›®çš„ç„¡æ•ˆé€£çµå—ï¼Ÿæ­¤æ“ä½œç„¡æ³•å¾©åŸï¼')) {
                const game = games[selectedGameForEdit];
                let deletedCount = 0;
                
                game.items.forEach(item => {
                    if (item.invalidLinks && item.invalidLinks.length > 0) {
                        const originalLinkCount = item.links.length;
                        item.links = item.links.filter(link => !item.invalidLinks.includes(link));
                        deletedCount += (originalLinkCount - item.links.length);
                        item.invalidLinks = [];
                    }
                });
                
                localStorage.setItem('games', JSON.stringify(games));
                syncData();
                updateItemsListWithPagination();
                alert(`å·²åˆªé™¤ ${deletedCount} å€‹ç„¡æ•ˆé€£çµï¼`);
            }
        }

        function syncData() {
            localStorage.setItem('games_sync', Date.now().toString());
        }

        window.addEventListener('beforeunload', function (e) {
			if (isEditing || (document.getElementById('itemsInput') && document.getElementById('itemsInput').value.trim() !== '')) {
				e.preventDefault();
				e.returnValue = 'æ‚¨æ­£åœ¨ç·¨è¼¯é …ç›®ï¼Œç¢ºå®šè¦é›¢é–‹å—ï¼Ÿ';
				return e.returnValue;
			}
		});

        function toggleItemsManagement() {
			if (isEditing && editingItemId) {
                saveEditingItemData();
            }
            document.getElementById('itemsManagement').classList.add('hidden');
        }
		
		function updateItemCountState() {
			const extractMode = document.getElementById('extractMode').value;
			if (extractMode === 'quickConverge') {
				document.getElementById('itemCount').disabled = true;
				document.querySelector('button[onclick="setMaxItems()"]').disabled = true;
			} else {
				document.getElementById('itemCount').disabled = false;
				document.querySelector('button[onclick="setMaxItems()"]').disabled = false;
			}
		}

        document.addEventListener('DOMContentLoaded', function() {
			migrateOldData(); updateGamesList(); updateGameSelect();
			createVotingMoodFilter();
			
			expandedItemIds = [];
			localStorage.removeItem('expandedItemIds');
			
			votingMoodLogic = localStorage.getItem('votingMoodLogic') || 'and';
			settingsMoodLogic = localStorage.getItem('settingsMoodLogic') || 'and';
			statsMoodLogic = localStorage.getItem('statsMoodLogic') || 'and';
			
			// åˆå§‹åŒ–å¹³å°ç­›é€‰çŠ¶æ€
			const savedPlatformFilters = localStorage.getItem('platformFilters');
			if (savedPlatformFilters) {
				platformFilters = JSON.parse(savedPlatformFilters);
			} else {
				// é»˜è®¤ä¸¤ä¸ªå¹³å°éƒ½å¼€å¯
				platformFilters = { youtube: true, bilibili: true };
				localStorage.setItem('platformFilters', JSON.stringify(platformFilters));
			}
			
			// æ›´æ–°å¹³å°ç­›é€‰æŒ‰é’®çŠ¶æ€
			updatePlatformFilterButtons();
			
			// ç¡®ä¿ç»Ÿè®¡æ˜¾ç¤ºæŒ‰é’®çŠ¶æ€æ­£ç¡®
			const toggleStatsBtn = document.getElementById('toggleStatsButton');
			if (statsVisible) {
				toggleStatsBtn.classList.add('active');
			} else {
				toggleStatsBtn.classList.remove('active');
			}

			const votingMoodLogicSelect = document.getElementById('votingMoodLogic');
			if (votingMoodLogicSelect) {
				votingMoodLogicSelect.value = votingMoodLogic;
			}
			const settingsMoodLogicSelect = document.getElementById('settingsMoodLogic');
			if (settingsMoodLogicSelect) {
				settingsMoodLogicSelect.value = settingsMoodLogic;
			}
			const statsMoodLogicSelect = document.getElementById('statsMoodLogic');
			if (statsMoodLogicSelect) {
				statsMoodLogicSelect.value = statsMoodLogic;
			}
			
			document.getElementById('extractMode').addEventListener('change', function() {
				selectedExtractMode = this.value;
				localStorage.setItem('selectedExtractMode', selectedExtractMode);
				updateItemCountState();
			});
			
			document.getElementById('itemCount').addEventListener('input', function() {
				selectedItemCount = parseInt(this.value) || 0;
				localStorage.setItem('selectedItemCount', selectedItemCount);
			});
			
			document.getElementById('itemFilter').addEventListener('keyup', filterItems);
			document.getElementById('pageSize').addEventListener('change', changePageSize);
			document.getElementById('statsGameSelect').addEventListener('change', loadStats);
			document.getElementById('sortBy').addEventListener('change', loadStats);
			document.getElementById('rankingSearch').addEventListener('keyup', searchRanking);
			document.getElementById('importStatsFile').addEventListener('change', importStats);
			
			// æ·»åŠ ä¸‹æ‹‰èœå•å˜åŒ–äº‹ä»¶ç›‘å¬
			document.getElementById('votingMoodLogic').addEventListener('change', function() {
				votingMoodLogic = this.value;
				localStorage.setItem('votingMoodLogic', votingMoodLogic);
				updateItemCountMax();
			});
			
			document.getElementById('settingsMoodLogic').addEventListener('change', function() {
				settingsMoodLogic = this.value;
				localStorage.setItem('settingsMoodLogic', settingsMoodLogic);
				filterItems();
			});
			
			document.getElementById('statsMoodLogic').addEventListener('change', function() {
				statsMoodLogic = this.value;
				localStorage.setItem('statsMoodLogic', statsMoodLogic);
				loadStats();
			});
			
			if (selectedGameId) {
				document.getElementById('gameSelect').value = selectedGameId;
				updateGameSettings();
			}
			if (selectedExtractMode) {
				document.getElementById('extractMode').value = selectedExtractMode;
				updateItemCountState();
			}
			if (selectedItemCount) document.getElementById('itemCount').value = selectedItemCount;
			
			document.getElementById('itemCount').addEventListener('keydown', function(e) {
				if (e.key === 'Enter') {
					startGame();
				}
			});
			
			document.getElementById('keywordFilter').addEventListener('keydown', function(e) {
				if (e.key === 'Enter') {
					startGame();
				}
			});
			
			document.getElementById('keywordFilter').addEventListener('input', function(e) {
				localStorage.setItem('keywordFilter', e.target.value);
			});
			
			// é»æ“Šæ”¾å¤§åœ–è¡¨çš„æ¨¡æ…‹æ¡†æ™‚é—œé–‰
			document.getElementById('scoreDistributionModal').addEventListener('click', function(e) {
				if (e.target === this) {
					toggleScoreDistributionChart(false);
				}
			});
			
			// æ·»åŠ ç‚¹å‡»èƒŒæ™¯å…³é—­æ’ååŠ¨ç”»çš„åŠŸèƒ½
			document.getElementById('rankingAnimationModal').addEventListener('click', function(e) {
				if (e.target === this) {
					closeRankingAnimation();
				}
			});
			
			window.addEventListener('storage', function(e) {
				if (e.key === 'games_sync') {
					games = JSON.parse(localStorage.getItem('games')) || {};
					
					updateGamesList();
					updateGameSelect();
					updateStatsGameSelect();
					
					// å¦‚æœå½“å‰åœ¨æŠ•ç¥¨é¡µé¢ï¼Œç¡®ä¿æŒ‰é’®çŠ¶æ€æ­£ç¡®
					if (document.getElementById('voting').classList.contains('active')) {
						const toggleStatsBtn = document.getElementById('toggleStatsButton');
						if (statsVisible) {
							toggleStatsBtn.classList.add('active');
						} else {
							toggleStatsBtn.classList.remove('active');
						}
					}
					
					if (currentGame && currentPair) {
						currentGame = games[currentGame.id];
						if (currentGame) {
							currentPair = currentPair.map(p => 
								currentGame.items.find(i => i.id === p.id) || p
							);
							loadBothVideos();
							createMoodButtons();
							if (statsVisible) updateItemStats();
						}
					}
					
					if (document.getElementById('stats').classList.contains('active')) {
						loadStats();
					}
				} else if (e.key === 'platformFilters') {
					// å¦‚æœå…¶ä»–æ ‡ç­¾é¡µä¿®æ”¹äº†å¹³å°ç­›é€‰çŠ¶æ€ï¼ŒåŒæ­¥æ›´æ–°å½“å‰é¡µé¢çš„çŠ¶æ€
					const savedPlatformFilters = localStorage.getItem('platformFilters');
					if (savedPlatformFilters) {
						platformFilters = JSON.parse(savedPlatformFilters);
						updatePlatformFilterButtons();
						
						// å¦‚æœå½“å‰åœ¨æŠ•ç¥¨é¡µé¢ä¸”æœ‰æ­£åœ¨è¿›è¡Œçš„æŠ•ç¥¨ï¼Œé‡æ–°åŠ è½½å½±ç‰‡
						if (document.getElementById('voting').classList.contains('active') && currentPair) {
							reloadBothVideos();
						}
					}
				}
			});
		});
    </script>
</body>
</html>
