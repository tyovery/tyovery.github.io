<html lang="zh-Hant-HK" >
<head>
<meta charset="utf-8" />
<title>夾擊棋</title>
<style>
body
{
        color: #000 ;
}
td
{
        user-select: none ;
        text-align: center ;
        font-size: 20px ;
}
.ai-settings {
    margin: 10px 0;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 5px;
    background-color: #f5f5f5;
}
.review-controls {
    margin: 10px 0;
    padding: 10px;
    text-align: center;
}
.review-controls button {
    margin: 0 5px;
    padding: 5px 10px;
}
#aiScore {
    font-weight: bold;
    padding: 3px 5px;
    border-radius: 3px;
}
#aiMoveNow, #changeMove, #humanTakeOver {
    background-color: #ff7700;
    color: white;
    font-weight: bold;
    padding: 5px 10px;
    border-radius: 5px;
    cursor: pointer;
    margin: 5px;
}
#humanTakeOver {
    background-color: #008800;
    display: block;
    margin: 10px auto;
    width: 80%;
}
#aiMoveNow:disabled, #changeMove:disabled, #humanTakeOver:disabled {
    background-color: #ccc;
    cursor: not-allowed;
}
#reviewModeIndicator {
    font-weight: bold;
    color: red;
    padding: 3px 8px;
    margin-left: 10px;
    border: 1px solid red;
    border-radius: 3px;
}
.button-row {
    margin: 10px 0;
    display: flex;
    justify-content: space-between;
}
</style>
</head>
<body>
<input type="button" value="?" onclick="help();" />
<center>
<h1>夾擊棋</h1>

<table border="0" cellspacing="10" cellpadding="3">
        <tr>
        <td>
        棋子：<output id="playerScore">-</output>
        <br />
        輪到：<output id="whoTurn">-</output>
        <br />
        第 <output id="rounds">-</output> 回合
        <br />
        無吃子步數：<output id="notEat">-</output> / <output id="notEatLimit">-</output>
        <br /><br />
        <output id="cellInfo">-</output>
        </td>
        <td>
			<table border="1" cellspacing="0" cellpadding="3" id="map"></table>
			<div class="review-controls">
				<button id="prevMove" onclick="goToHistoryState(currentHistoryIndex-1)" disabled>上一步</button>
				<button id="nextMove" onclick="goToHistoryState(currentHistoryIndex+1)" disabled>下一步</button>
				<button id="returnToGame" onclick="returnToCurrentGame()" disabled>返回當前局面</button>
			</div>
			<div id="reviewModeIndicator" style="display:none;">【回顧模式】</div>
		</td>
        <td>
                <input type="button" value="開始新的遊戲" onclick="newGame();" />
                <br />
                地圖大小：
                <input name="setMapSize" type="number" value="6" step="1" min="3" max="16" />
                ×
                <input name="setMapSize" type="number" value="6" step="1" min="3" max="16" />
                <br /><br />
                棋子佈置：
                <select id="setStartPos" size="9">
                        <optgroup label="單行" >
                                <option value="0.5">前排</option>
                                <option value="0.25">中排</option>
                                <option value="0" selected>後排</option>
                        </optgroup>
                        <optgroup label="陣營" >
                                <option value="check_white">白格</option>
                                <option value="half_rect">半場</option>
                        </optgroup>
                        <optgroup label="混雜" >
                                <option value="barabara">分散各地</option>
                        </optgroup>
                </select>
                <br /><br />
                無吃子限步：
                <input id="setNotEatToDraw" type="number" value="60" step="2" min="0" max="256" />
                <br />
                ( 0 = 不限步 )
                <br /><br />
        </td>
        <td>
        <div class="ai-settings">
            <b>AI設置：</b><br/>
            <input id="setBlueIsAi" type="checkbox" checked />
            電腦執藍子
            <select id="setBlueAiLevel">
				<option value="1" >思考1層</option>
                <option value="2" selected>思考2層</option>
                <option value="3">思考3層</option>
                <option value="4">思考4層</option>
            </select>
            <br/><br/>
            <input id="setRedIsAi" type="checkbox" />
            電腦執紅子
            <select id="setRedAiLevel">
				<option value="1">思考1層</option>
                <option value="2" selected>思考2層</option>
                <option value="3">思考3層</option>
                <option value="4">思考4層</option>
            </select>
            <br/><br/>
            思考時間限制(秒)：<br/>
            <input id="aiThinkingTimeLimit" type="number" value="30" min="0" max="1800" />
            (0 = 不限時)
            <br/><br/>
            <div class="button-row">
                <button id="aiMoveNow" disabled onclick="forceAiMove()">立即出招</button>
                <button id="changeMove" disabled onclick="changeAiMove()">變招</button>
            </div>
            <button id="humanTakeOver" onclick="humanTakeOver()">人類接玩</button>
            <br/>
            AI評分：<output id="aiScore">-</output>
            <br/>
            <small>(正分紅優，負分藍優)</small>
        </div>
        </td>
        </tr>
</table>

<br />

</center>

<script>
let timerBegin = Date.now() , timerEnd ;
// timer

// code begin here

let mapSize = [6,6] ; // 地圖大小 (y,x)
let startPos = 0 ; // 兵線 ( 0: 後 , 0.25: 中 , 0.5: 前 )
let startRange = [1,5] ; // 開始數字範圍
let ownerName = [ '-' , '紅子' , '藍子' ] ; // 棋格擁有者 名稱
let ownerColor = [ '#000' , '#c00' , '#07f' ] ; // 棋格擁有者 顏色
let ownerCurrentPoint = [] ; // 各玩家當前分數
let piece = '●' ; // 棋子字樣
let turn = -1 ; // 輪到誰下 ( -1 = 沒有進行中的遊戲 )
let notEatToDraw = 60 ; // 多少步無進展判和
let takedCell = null ; // 當前抓住的棋子 的 格子
let takedCellPos = [-1,-1] ; // 當前抓住的棋子 的 座標
let takedCellColor = '#cc0' ; // 當前抓住的棋子 的 標記顏色
let cellBgColor = [ '#fff' , '#ccc' ] ; // 棋格 背景顏色
let aiSleepTime = 40 ; // AI走子的延遲(ms)
let lastMoveHighlight = '#ffd700'; // 上一步高亮顏色
let lastMoveInfo = null; // 上一步的信息 [fromY, fromX, toY, toX]

// AI
let positionScore = [ 0.14 , 0.03 ] ; // 位置分 [ 角 , 邊 ]
let flexibilityScore = 0.05 ; // 靈活度分數 ( 每個合法棋步的分數 )
let mobilityBonus = 0.08; // 行動力獎勵
let threatPenalty = 0.12; // 受威脅棋子的懲罰
let centerBonus = 0.04; // 中心控制獎勵
let aiNodesEvaluated = 0; // AI評估節點數量（用於統計）

// AI思考控制
let aiIsThinking = false; // AI是否正在思考
let aiShouldStopThinking = false; // AI是否應該停止思考
let aiBestMoveSoFar = null; // AI目前最佳走法
let aiCurrentScore = 0; // AI當前評分
let lastAiMove = null; // AI上一步走法，用於變招功能

// 游戲历史
let gameHistory = []; // 存储每一步的棋盘状态
let currentHistoryIndex = -1; // 当前查看的历史索引，-1表示当前局面
let isReviewMode = false; // 是否处于回顾模式

const table = document.getElementById('map') ; // table
const showPlayerScore = document.getElementById('playerScore') ; // 顯示 玩家分數 的輸出框
const showWhoTurn = document.getElementById('whoTurn') ; // 顯示 輪到誰下 的輸出框
const showRounds = document.getElementById('rounds') ; // 顯示 回合數 的輸出框
const showNotEat = document.getElementById('notEat') ; // 顯示 無吃子步數 的輸出框
const showNotEatLimit = document.getElementById('notEatLimit') ; // 顯示 無吃子步數 的輸出框
const showCellInfo = document.getElementById('cellInfo') ; // 顯示 棋格資訊 的輸出框
const setRedIsAiCheckbox = document.getElementById('setRedIsAi') ; // AI執紅子 的勾選格
const setBlueIsAiCheckbox = document.getElementById('setBlueIsAi') ; // AI執藍子 的勾選格
const setRedAiLevel = document.getElementById('setRedAiLevel'); // 紅子AI難度
const setBlueAiLevel = document.getElementById('setBlueAiLevel'); // 藍子AI難度
const aiScoreOutput = document.getElementById('aiScore'); // AI評分輸出
const aiMoveNowButton = document.getElementById('aiMoveNow'); // 立即出招按鈕
const changeMoveButton = document.getElementById('changeMove'); // 變招按鈕
const humanTakeOverButton = document.getElementById('humanTakeOver'); // 人類接玩按鈕
const aiThinkingTimeLimitInput = document.getElementById('aiThinkingTimeLimit'); // 思考時間限制

// 檢查走法是否有效的輔助函數
function isValidMove(move) {
    if (!move || move.length !== 4) return false;
    
    let [fromY, fromX, toY, toX] = move;
    
    // 檢查座標是否在棋盤範圍內
    if (fromY < 0 || fromY >= mapSize[0] || fromX < 0 || fromX >= mapSize[1] ||
        toY < 0 || toY >= mapSize[0] || toX < 0 || toX >= mapSize[1]) {
        return false;
    }
    
    // 檢查起點是否是當前回合方的棋子
    let fromCell = document.getElementById(`cell_${fromY}_${fromX}`);
    if (!fromCell || fromCell.dataset.owner != turn) {
        return false;
    }
    
    // 檢查終點是否為空
    let toCell = document.getElementById(`cell_${toY}_${toX}`);
    if (!toCell || toCell.dataset.owner != 0) {
        return false;
    }
    
    // 檢查移動是否合法
    return canMove(fromY, fromX, toY, toX);
}

// 人類接玩功能 - 停止AI思考並取消雙方電腦執子
function humanTakeOver() {
    // 停止AI思考
    if (aiIsThinking) {
        aiShouldStopThinking = true;
        aiMoveNowButton.disabled = true;
        aiMoveNowButton.innerText = "思考中斷...";
        
        // 等待一小段時間，確保AI思考已停止
        setTimeout(function() {
            // 取消雙方電腦執子
            setRedIsAiCheckbox.checked = false;
            setBlueIsAiCheckbox.checked = false;
            
            // 恢復UI狀態
            setRedIsAiCheckbox.disabled = false;
            setBlueIsAiCheckbox.disabled = false;
            aiIsThinking = false;
            aiMoveNowButton.disabled = true;
        }, 100);
    } else {
        // 直接取消雙方電腦執子
        setRedIsAiCheckbox.checked = false;
        setBlueIsAiCheckbox.checked = false;
    }
}

// 獲取AI思考時間限制
function getAiThinkingTimeLimit() {
    let limit = parseInt(aiThinkingTimeLimitInput.value);
    limit = limit * 1000; // 轉換為毫秒
    return limit <= 0 ? Infinity : limit; // 0表示不限時
}

// 強制AI立即出招
function forceAiMove() {
    if (aiIsThinking) {
        aiShouldStopThinking = true;
        aiMoveNowButton.disabled = true;
        aiMoveNowButton.innerText = "思考中斷...";
    }
}

// 變招功能：讓AI重新思考，但避免相同的走法
function changeAiMove() {
    if (turn === -1 || isReviewMode) return; // 遊戲結束或回顧模式時不能變招
    
    // 確保游戲歷史中至少有一步
    if (gameHistory.length <= 1) {
        alert("沒有前一步可以變招！");
        return;
    }
    
    // 檢查上一步是否是AI所走的
    let prevTurn = gameHistory[gameHistory.length - 2].turn;
    let lastMoveWasAI = (prevTurn === 1 && setRedIsAiCheckbox.checked) || 
                        (prevTurn === 2 && setBlueIsAiCheckbox.checked);
                        
    if (!lastMoveWasAI) {
        alert("只有上一步是AI走的才能變招！");
        return;
    }
    
    // 檢查有多少合法走法
    let legalMoves = checkMove(turn);
    if (legalMoves.length <= 1) {
        alert("此乃唯一步，無法變招。");
        return;
    }
    
    // 回退到上一步
    let prevState = gameHistory[gameHistory.length - 2]; // 取得前一個狀態
    
    // 還原棋盤
    changeMapTo(prevState.board);
    
    // 還原遊戲狀態
    turn = prevState.turn;
    showRounds.innerText = prevState.round;
    showNotEat.innerText = prevState.notEat;
    showWhoTurn.innerText = ownerName[turn];
    showWhoTurn.style.color = ownerColor[turn];
    
    // 移除最後一個歷史記錄
    gameHistory.pop();
    currentHistoryIndex = gameHistory.length - 1;
    
    // 更新回顧按鈕狀態
    updateReviewButtonsState();
    
    // 記住上一步AI的走法，以便避免重複
    if (lastAiMove) {
        console.log(`避免重複走法: ${lastAiMove.join(', ')}`);
    }
    
    // 觸發AI思考
    changeMoveButton.disabled = true;
    setTimeout(checkAiTurn, aiSleepTime);
}

// 更新AI評分顯示 - 始終從紅方視角顯示評分
function updateAiScoreDisplay(score) {
    // 將分數轉換為紅方視角
    let redViewScore = (turn === 2) ? -score : score;
    aiCurrentScore = redViewScore; // 存儲紅方視角的評分
    
    if (score === Infinity || score === -Infinity) {
        if ((turn === 1 && score === Infinity) || (turn === 2 && score === -Infinity)) {
            aiScoreOutput.innerText = "紅必勝";
            aiScoreOutput.style.backgroundColor = "#ff3333";
        } else {
            aiScoreOutput.innerText = "藍必勝";
            aiScoreOutput.style.backgroundColor = "#0066ff";
        }
    } else {
        // 顯示紅方視角的評分
        aiScoreOutput.innerText = redViewScore.toFixed(2);
        
        // 根據紅方視角評分設置顏色
        if (redViewScore > 3) {
            aiScoreOutput.style.backgroundColor = "#ff3333"; // 紅子優勢
        } else if (redViewScore > 0) {
            aiScoreOutput.style.backgroundColor = "#ffbbbb"; // 輕微紅子優勢
        } else if (redViewScore < -3) {
            aiScoreOutput.style.backgroundColor = "#0066ff"; // 藍子優勢
        } else if (redViewScore < 0) {
            aiScoreOutput.style.backgroundColor = "#bbddff"; // 輕微藍子優勢
        } else {
            aiScoreOutput.style.backgroundColor = "#ffffbb"; // 均勢
        }
    }
}

// Mouse 離開棋盤時 清空 棋格資訊
table.setAttribute( 'onmouseleave' , `showCellInfo.innerText = '';` ) ;

function newGame() // 開始新的遊戲
{
        let buf = document.createDocumentFragment() ; // buff
        let tr , td ;
        
        // 地圖大小
        const newMapSize = document.getElementsByName('setMapSize') ;
        mapSize[0] = ~~ newMapSize[0].value ;
        mapSize[1] = ~~ newMapSize[1].value ;
        
        // 地圖大小 下限 = 3
        mapSize[0] = Math.max( 3 , mapSize[0] ) ;
        mapSize[1] = Math.max( 3 , mapSize[1] ) ;
        
        // 地圖大小 上限 = 16
        mapSize[0] = Math.min( 16 , mapSize[0] ) ;
        mapSize[1] = Math.min( 16 , mapSize[1] ) ;
        
        // 兵線
        startPos = document.getElementById('setStartPos').value ;
        
        // 無進展判和 步數
        notEatToDraw = ~~document.getElementById('setNotEatToDraw').value ;
        notEatToDraw = Math.max( 0 , notEatToDraw ) ; // 下限

        // 生成 空白地圖
        for( let y = 0 ; y < mapSize[0] ; ++y )
        {
                tr = document.createElement('tr') ;
                buf.appendChild(tr) ;
                for( let x = 0 ; x < mapSize[1] ; ++x )
                {
                        td = document.createElement('td') ;
                        tr.appendChild(td) ;
                        
                        td.id = `cell_${y}_${x}` ; // id
                        
                        // 棋格 座標
                        td.dataset.y = y ;
                        td.dataset.x = x ;
                        
                        td.dataset.owner = 0 ; // 預設公地
                        td.bgColor = cellBgColor[ ( y + x ) % 2 ] ; // 棋格 背景顏色

                        td.innerText = '' ; // 內容為 空
                        td.setAttribute( 'onclick' , 'clickCell(this);cellInfo(this);' ) ; // 點擊棋格時
                        td.setAttribute( 'onmouseenter' , 'cellInfo(this);' ) ; // Mouse進入棋格時 顯示棋格資訊
                        td.setAttribute( 'onmousedown' , 'cellInfo(this);' ) ; // 按下棋格時 顯示棋格資訊

                        // 樣式
                        td.style.width = '50px' ;
                        td.style.height = '50px' ;
                }
        }
        
        // 輸出地圖到頁面
        table.innerHTML = '' ;
        table.appendChild(buf) ;
        
        // reset
        takedCell = null ; // 當前抓住的棋子 的 格子
        takedCellPos = [-1,-1] ; // 當前抓住的棋子 的 座標
    lastMoveInfo = null; // 重置上一步信息
    lastAiMove = null; // 重置上一步AI走法
        turn = 1 ; // 紅先下
        showRounds.innerText = '1' ; // 輸出 回合數
        showNotEat.innerText = '0' ; // 輸出 無吃子步數
        showNotEatLimit.innerText = notEatToDraw ; // 輸出 無進展步數上限
        showWhoTurn.innerText = ownerName[1] ; // 輸出輪到誰下 (字)
        showWhoTurn.style.color = ownerColor[1] ; // 輸出輪到誰下 (色)
        showCellInfo.innerText = '' ; // 清空 棋格資訊
        ownerCurrentPoint.length = ownerName.length ; // 玩家分數 (列表長度)
        ownerCurrentPoint.fill(0) ; // 玩家分數 清0
    
    // 重置游戏历史
    gameHistory = [];
    currentHistoryIndex = -1;
    isReviewMode = false;
    document.getElementById('reviewModeIndicator').style.display = 'none';
    
    // 重置變招按鈕
    changeMoveButton.disabled = true;

        let whose ; // 隨機擁有者
        let cell ; // 當前操作的棋格

        // 根據使用者的設定, 生成對應的開局佈置
        if( isFinite(startPos) ) // 若 startPos 是數字
        {
                y = ~~( ( mapSize[0] - 2 ) * startPos ) ; // 化為行數

                // 生成 藍方棋子
                for(let x = 0 ; x < mapSize[1] ; ++x )
                {
                        cell = document.getElementById(`cell_${y}_${x}`) ;
                        cell.dataset.owner = 2 ;
                        cell.style.color = ownerColor[2] ;
                        cell.innerText = piece ;
                        
                        ++ ownerCurrentPoint[2] ; // 計玩家分
                }

                // 生成 紅方棋子
                for(let x = 0 ; x < mapSize[1] ; ++x )
                {
                        cell = document.getElementById(`cell_${mapSize[0]-1-y}_${x}`) ;
                        cell.dataset.owner = 1 ;
                        cell.style.color = ownerColor[1] ;
                        cell.innerText = piece ;
                        
                        ++ ownerCurrentPoint[1] ; // 計玩家分
                }
        }
        else // 若 startPos 不是數字
        {
                switch(startPos)
                {
                        case 'barabara' :  // 分散各地
                                for(let y = 0 ; y < mapSize[0] ; ++y )
                                {
                                        for(let x = 0 ; x < mapSize[1] ; ++x )
                                        {
                                                whose = ~~( Math.random() * ownerName.length ) ; // 隨機擁有者 (包括 公地)
                                                
                                                if(!whose) continue ; // 跳過公地
                                                
                                                // 棋子字樣
                                                cell = document.getElementById(`cell_${y}_${x}`) ;
                                                cell.dataset.owner = whose ;
                                                cell.style.color = ownerColor[whose] ;
                                                cell.innerText = piece ;
                                                
                                                ++ ownerCurrentPoint[whose] ; // 計玩家分
                                        }
                                }
                        break ;
                
                        case 'check_white' :  // 白格
                                for(let y = 0 ; y < mapSize[0] ; ++y )
                                {
                                        for(let x = 0 ; x < mapSize[1] ; ++x )
                                        {
                                                // 擁有者
                                                if( y < ~~(mapSize[0]/2) )
                                                {
                                                        whose = 2 ;
                                                }
                                                else if( y >= mapSize[0] / 2 )
                                                {
                                                        whose = 1 ;
                                                }
                                                else
                                                {
                                                        continue ;
                                                }
                                                
                                                if( ( y + x ) % 2 == 1 ) continue ;

                                        
                                                // 棋子字樣
                                                cell = document.getElementById(`cell_${y}_${x}`) ;
                                                cell.dataset.owner = whose ;
                                                cell.style.color = ownerColor[whose] ;
                                                cell.innerText = piece ;
                                                
                                                ++ ownerCurrentPoint[whose] ; // 計玩家分
                                        }
                                }
                        break ;
                        
                        case 'half_rect' :  // 各自半場
                                for(let y = 0 ; y < mapSize[0] ; ++y )
                                {
                                        for(let x = 0 ; x < mapSize[1] ; ++x )
                                        {
                                                // 擁有者
                                                if( y < ~~(mapSize[0]/2) )
                                                {
                                                        whose = 2 ;
                                                }
                                                else if( y >= mapSize[0] / 2 )
                                                {
                                                        whose = 1 ;
                                                }
                                                else
                                                {
                                                        continue ;
                                                }

                                        
                                                // 棋子字樣
                                                cell = document.getElementById(`cell_${y}_${x}`) ;
                                                cell.dataset.owner = whose ;
                                                cell.style.color = ownerColor[whose] ;
                                                cell.innerText = piece ;

                                                ++ ownerCurrentPoint[whose] ; // 計玩家分
                                        }
                                }
                        break ;
                }
        }

        renewPlayerScore(true) ; // 輸出 玩家分數
        checkEndGame(true) ; // 檢查能否進行遊戲
    
    // 記錄初始狀態
    recordCurrentBoardState();
    
        checkAiTurn() ; // 檢查是否輪到 AI 走棋
}

// 記錄當前棋盤狀態
function recordCurrentBoardState() {
    if (!isReviewMode) {
        // 如果不是在回顧模式，則記錄當前狀態
        
        // 移除當前步驟之後的所有歷史（如果有的話）
        if (currentHistoryIndex < gameHistory.length - 1) {
            gameHistory = gameHistory.slice(0, currentHistoryIndex + 1);
        }
        
        // 添加新狀態
        let currentState = {
            board: getMap(),
            turn: turn,
            notEat: parseInt(showNotEat.innerText || 0),
            round: parseInt(showRounds.innerText || 1),
            score: aiCurrentScore
        };
        
        gameHistory.push(currentState);
        currentHistoryIndex = gameHistory.length - 1;
        
        // 更新回顧按鈕狀態
        updateReviewButtonsState();
        
        // 更新變招按鈕狀態
        updateChangeMoveButtonState();
    }
}

// 更新變招按鈕狀態
function updateChangeMoveButtonState() {
    // 只有在遊戲進行中、非回顧模式、有歷史且上一步是AI走的時才啟用變招按鈕
    let lastMoveWasAI = false;
    
    if (gameHistory.length > 1) {
        let prevTurn = gameHistory[gameHistory.length - 2].turn;
        lastMoveWasAI = (prevTurn === 1 && setRedIsAiCheckbox.checked) || 
                       (prevTurn === 2 && setBlueIsAiCheckbox.checked);
    }
    
    changeMoveButton.disabled = !(turn !== -1 && !isReviewMode && 
                                gameHistory.length > 1 && lastMoveWasAI && !aiIsThinking);
}

// 更新回顧按鈕狀態
function updateReviewButtonsState() {
    document.getElementById('prevMove').disabled = (currentHistoryIndex <= 0);
    document.getElementById('nextMove').disabled = (currentHistoryIndex >= gameHistory.length - 1);
    document.getElementById('returnToGame').disabled = !isReviewMode ;
}

// 切換到指定的歷史狀態
function goToHistoryState(index) {
    if (index >= 0 && index < gameHistory.length) {
        isReviewMode = true;
        currentHistoryIndex = index;
        
        let state = gameHistory[index];
        changeMapTo(state.board);
        
        // 更新顯示信息
        showRounds.innerText = state.round;
        showNotEat.innerText = state.notEat;
        updateAiScoreDisplay(state.score || 0);
        
        if (state.turn > 0) {
            turn = state.turn; // 設置當前回合
            showWhoTurn.innerText = ownerName[state.turn];
            showWhoTurn.style.color = ownerColor[state.turn];
        }
        
        // 清除抓子狀態
        if (takedCell) {
            takedCell.bgColor = cellBgColor[(~~takedCell.dataset.y + ~~takedCell.dataset.x) % 2];
            takedCell = null;
            takedCellPos = [-1, -1];
        }
        
        // 更新按鈕狀態
        updateReviewButtonsState();
        updateChangeMoveButtonState();
        
        // 顯示當前是回顧模式
        document.getElementById('reviewModeIndicator').style.display = 'inline';
    }
}

// 返回到當前遊戲狀態
function returnToCurrentGame() {
    if (isReviewMode && gameHistory.length > 0) {
        goToHistoryState(gameHistory.length - 1);
        isReviewMode = false;
        document.getElementById('reviewModeIndicator').style.display = 'none';
        
        // 更新按鈕狀態
        updateReviewButtonsState();
        updateChangeMoveButtonState();
    }
}

// ----- 新增虛擬棋盤系統，避免直接操作DOM -----
// 創建一個虛擬棋盤，用於AI搜索
function createVirtualBoard() {
    let board = [];
    for (let y = 0; y < mapSize[0]; y++) {
        board[y] = [];
        for (let x = 0; x < mapSize[1]; x++) {
            let cell = document.getElementById(`cell_${y}_${x}`);
            if (cell) {
                board[y][x] = parseInt(cell.dataset.owner);
            } else {
                board[y][x] = 0; // 如果找不到元素，默認為空格
            }
        }
    }
    return board;
}

// 在虛擬棋盤上移動棋子
function virtualMove(board, fromY, fromX, toY, toX) {
    // 參數檢查
    if (!board || !board[fromY] || board[fromY][fromX] === undefined || 
        !board[toY] || board[toY][toX] === undefined) {
        console.error("Invalid virtualMove parameters:", fromY, fromX, toY, toX);
        return board; // 返回原始棋盤
    }
    
    let newBoard = JSON.parse(JSON.stringify(board)); // 深拷貝
    let owner = newBoard[fromY][fromX];
    newBoard[toY][toX] = owner;
    newBoard[fromY][fromX] = 0;
    return newBoard;
}

// 檢查虛擬棋盤上的合法移動
function virtualCanMove(board, fromY, fromX, toY, toX) {
    // 數字化
    fromY = ~~fromY;
    fromX = ~~fromX;
    toY = ~~toY;
    toX = ~~toX;
    
    // 參數檢查
    if (!board || !board[fromY] || board[fromY][fromX] === undefined || 
        !board[toY] || board[toY][toX] === undefined) {
        console.error("Invalid virtualCanMove parameters:", fromY, fromX, toY, toX);
        return false;
    }
    
    // 檢查座標是否有效
    if (fromY < 0 || fromY >= mapSize[0] || fromX < 0 || fromX >= mapSize[1] ||
        toY < 0 || toY >= mapSize[0] || toX < 0 || toX >= mapSize[1]) {
        return false;
    }
    
    // 檢查起點是否有棋子
    if (board[fromY][fromX] === 0) return false;
    
    // 檢查終點是否為空
    if (board[toY][toX] !== 0) return false;
    
    let sameY = toY - fromY;
    let sameX = toX - fromX;
    
    // 必須是直線移動（上下或左右）
    if (!sameY != !sameX) {
        // 檢查路徑暢通
        if (sameY) { // 上下移動
            let step = Math.sign(sameY);
            for (let y = fromY + step; y !== toY; y += step) {
                if (board[y][fromX] !== 0) return false;
            }
            return true;
        } else { // 左右移動
            let step = Math.sign(sameX);
            for (let x = fromX + step; x !== toX; x += step) {
                if (board[fromY][x] !== 0) return false;
            }
            return true;
        }
    }
    return false;
}

// 在虛擬棋盤上檢查吃子
function virtualCheckEat(board, y, x, turn) {
    // 參數檢查
    if (!board || !board[y] || board[y][x] === undefined || !turn) {
        console.error("Invalid virtualCheckEat parameters:", y, x, turn);
        return { newBoard: board, eatCount: 0 };
    }
    
    let eatCount = 0;
    let newBoard = JSON.parse(JSON.stringify(board));
    
    // 檢查上方
    let upEnemies = [];
    for (let i = y - 1; i >= 0; i--) {
        if (newBoard[i][x] === 3 - turn) {
            if (i > 0) upEnemies.push([i, x]);
            else upEnemies = []; // 邊緣不能吃
        } else if (newBoard[i][x] === 0) {
            upEnemies = []; // 有空格不能吃
            break;
        } else if (newBoard[i][x] === turn) {
            break; // 找到己方棋子，檢查是否可以吃子
        }
    }
    
    // 檢查下方
    let downEnemies = [];
    for (let i = y + 1; i < mapSize[0]; i++) {
        if (newBoard[i][x] === 3 - turn) {
            if (i < mapSize[0] - 1) downEnemies.push([i, x]);
            else downEnemies = []; // 邊緣不能吃
        } else if (newBoard[i][x] === 0) {
            downEnemies = []; // 有空格不能吃
            break;
        } else if (newBoard[i][x] === turn) {
            break; // 找到己方棋子，檢查是否可以吃子
        }
    }
    
    // 檢查左方
    let leftEnemies = [];
    for (let i = x - 1; i >= 0; i--) {
        if (newBoard[y][i] === 3 - turn) {
            if (i > 0) leftEnemies.push([y, i]);
            else leftEnemies = []; // 邊緣不能吃
        } else if (newBoard[y][i] === 0) {
            leftEnemies = []; // 有空格不能吃
            break;
        } else if (newBoard[y][i] === turn) {
            break; // 找到己方棋子，檢查是否可以吃子
        }
    }
    
    // 檢查右方
    let rightEnemies = [];
    for (let i = x + 1; i < mapSize[1]; i++) {
        if (newBoard[y][i] === 3 - turn) {
            if (i < mapSize[1] - 1) rightEnemies.push([y, i]);
            else rightEnemies = []; // 邊緣不能吃
        } else if (newBoard[y][i] === 0) {
            rightEnemies = []; // 有空格不能吃
            break;
        } else if (newBoard[y][i] === turn) {
            break; // 找到己方棋子，檢查是否可以吃子
        }
    }
    
    // 合併所有可吃的敵方棋子
    let allEnemies = [...upEnemies, ...downEnemies, ...leftEnemies, ...rightEnemies];
    
    // 吃掉這些棋子
    for (let [ey, ex] of allEnemies) {
        newBoard[ey][ex] = 0;
        eatCount++;
    }
    
    return { newBoard, eatCount };
}

// 在虛擬棋盤上檢查所有合法走法
function virtualGetMoves(board, player) {
    // 參數檢查
    if (!board || !player) {
        console.error("Invalid virtualGetMoves parameters:", player);
        return [];
    }
    
    let moves = [];
    
    // 找出所有己方棋子
    for (let y = 0; y < mapSize[0]; y++) {
        if (!board[y]) continue; // 確保行存在
        
        for (let x = 0; x < mapSize[1]; x++) {
            if (board[y][x] === undefined) continue; // 確保單元格存在
            
            if (board[y][x] === player) {
                // 檢查每個可能的目標位置
                for (let toY = 0; toY < mapSize[0]; toY++) {
                    for (let toX = 0; toX < mapSize[1]; toX++) {
                        if (virtualCanMove(board, y, x, toY, toX)) {
                            // 如果設置了要避免的走法，跳過該走法
                            if (lastAiMove && 
                                lastAiMove[0] === y && lastAiMove[1] === x && 
                                lastAiMove[2] === toY && lastAiMove[3] === toX) {
                                continue;
                            }
                            moves.push([y, x, toY, toX]);
                        }
                    }
                }
            }
        }
    }
    
    return moves;
}

// 計算虛擬棋盤上各方的棋子數量
function virtualCountPieces(board) {
    // 參數檢查
    if (!board) {
        console.error("Invalid virtualCountPieces parameter");
        return [0, 0, 0]; // 返回空棋盤
    }
    
    let count = [0, 0, 0]; // [空格, 紅子, 藍子]
    
    for (let y = 0; y < mapSize[0]; y++) {
        if (!board[y]) continue; // 確保行存在
        
        for (let x = 0; x < mapSize[1]; x++) {
            if (board[y][x] === undefined) continue; // 確保單元格存在
            
            if (board[y][x] >= 0 && board[y][x] <= 2) {
                count[board[y][x]]++;
            }
        }
    }
    
    return count;
}

// 評估虛擬棋盤局面（始終從紅方視角）
function virtualEvaluatePosition(board) {
    // 參數檢查
    if (!board) {
        console.error("Invalid virtualEvaluatePosition parameter");
        return 0; // 返回中立評分
    }
    
    // 計算棋子數量
    let pieceCounts = virtualCountPieces(board);
    
    // 首先檢查是否有一方棋子少於2個（勝負判斷）
    if (pieceCounts[1] < 2) return -Infinity; // 紅方剩下少於2個，負無窮（紅方輸）
    if (pieceCounts[2] < 2) return Infinity;  // 藍方剩下少於2個，正無窮（紅方贏）
    
    let score = 0;
    
    // 基礎棋子分數差異 (紅方比藍方多)
    score += 1.5 * (pieceCounts[1] - pieceCounts[2]);
    
    // 判斷位置：四個角 (對紅方的評分)
    let corners = [
        [0, 0], [0, mapSize[1]-1], 
        [mapSize[0]-1, 0], [mapSize[0]-1, mapSize[1]-1]
    ];
    
    for (let [y, x] of corners) {
        if (board[y] && board[y][x] !== undefined) {
            if (board[y][x] === 1) {
                score += positionScore[0];
            } else if (board[y][x] === 2) {
                score -= positionScore[0];
            }
        }
    }
    
    // 判斷邊位 (對紅方的評分)
    for (let x = 1; x < mapSize[1]-1; x++) {
        // 上邊
        if (board[0] && board[0][x] !== undefined) {
            if (board[0][x] === 1) score += positionScore[1];
            else if (board[0][x] === 2) score -= positionScore[1];
        }
        
        // 下邊
        if (board[mapSize[0]-1] && board[mapSize[0]-1][x] !== undefined) {
            if (board[mapSize[0]-1][x] === 1) score += positionScore[1];
            else if (board[mapSize[0]-1][x] === 2) score -= positionScore[1];
        }
    }
    
    for (let y = 1; y < mapSize[0]-1; y++) {
        if (!board[y]) continue;
        
        // 左邊
        if (board[y][0] !== undefined) {
            if (board[y][0] === 1) score += positionScore[1];
            else if (board[y][0] === 2) score -= positionScore[1];
        }
        
        // 右邊
        if (board[y][mapSize[1]-1] !== undefined) {
            if (board[y][mapSize[1]-1] === 1) score += positionScore[1];
            else if (board[y][mapSize[1]-1] === 2) score -= positionScore[1];
        }
    }
    
    // 靈活度分數 (對紅方的評分)
    let redMoves = virtualGetMoves(board, 1).length;
    let blueMoves = virtualGetMoves(board, 2).length;
    
    // 如果某方無子可走，對方勝
    if (redMoves === 0) return -Infinity;
    if (blueMoves === 0) return Infinity;
    
    // 行動力分數 (對紅方的評分)
    score += flexibilityScore * (redMoves - blueMoves);
    
    // 行動力差異獎勵 (對紅方的評分)
    score += mobilityBonus * (redMoves - blueMoves);
    
    // 中心控制 (對紅方的評分)
    let centerY = Math.floor(mapSize[0] / 2);
    let centerX = Math.floor(mapSize[1] / 2);
    let centerRadius = Math.min(2, Math.min(mapSize[0], mapSize[1]) / 4);
    
    for (let y = centerY - centerRadius; y <= centerY + centerRadius; y++) {
        if (y < 0 || y >= mapSize[0] || !board[y]) continue;
        
        for (let x = centerX - centerRadius; x <= centerX + centerRadius; x++) {
            if (x < 0 || x >= mapSize[1] || board[y][x] === undefined) continue;
            
            if (board[y][x] === 1) {
                score += centerBonus;
            } else if (board[y][x] === 2) {
                score -= centerBonus;
            }
        }
    }
    
    // 威脅分析 (對紅方的評分)
    let redThreatened = 0;
    let blueThreatened = 0;
    
    // 檢查每個棋子是否受威脅
    for (let y = 0; y < mapSize[0]; y++) {
        if (!board[y]) continue;
        
        for (let x = 0; x < mapSize[1]; x++) {
            if (board[y][x] === 1) {
                if (virtualIsPieceVulnerable(board, y, x, 1)) {
                    redThreatened++;
                }
            } else if (board[y][x] === 2) {
                if (virtualIsPieceVulnerable(board, y, x, 2)) {
                    blueThreatened++;
                }
            }
        }
    }
    
    score -= threatPenalty * redThreatened;
    score += threatPenalty * blueThreatened;
    
    return score;
}

// 檢查虛擬棋盤上棋子是否受威脅
function virtualIsPieceVulnerable(board, y, x, owner) {
    // 參數檢查
    if (!board || !board[y] || board[y][x] === undefined || !owner) {
        return false;
    }
    
    let directions = [[-1,0], [1,0], [0,-1], [0,1]]; // 上下左右
    
    for (let [dy, dx] of directions) {
        // 檢查一個方向是否有對方棋子
        let ny = y + dy, nx = x + dx;
        
        if (ny >= 0 && ny < mapSize[0] && nx >= 0 && nx < mapSize[1] && 
            board[ny] && board[ny][nx] !== undefined && board[ny][nx] === 3-owner) {
            
            // 檢查反方向是否有空格，然後是己方棋子
            let ry = y - dy, rx = x - dx;
            let hasEmptySpace = false;
            let hasOwnPiece = false;
            
            while (ry >= 0 && ry < mapSize[0] && rx >= 0 && rx < mapSize[1] && 
                  board[ry] && board[ry][rx] !== undefined) {
                if (board[ry][rx] === 0) {
                    hasEmptySpace = true;
                    ry -= dy;
                    rx -= dx;
                } else if (board[ry][rx] === 3-owner) {
                    break; // 對方棋子，無威脅
                } else {
                    hasOwnPiece = true;
                    break;
                }
            }
            
            if (hasEmptySpace && !hasOwnPiece) return true;
        }
    }
    
    return false;
}

// MinMax搜索（使用虛擬棋盤）
function virtualMinMax(board, depth, alpha, beta, maximizingPlayer, playerTurn, startTime, maxTime) {
    // 增加節點計數
    aiNodesEvaluated++;
    
    // 每100個節點檢查一次是否應該停止
    if (aiNodesEvaluated % 100 === 0) {
        // 檢查是否超時或應該停止
        if (Date.now() - startTime > maxTime || aiShouldStopThinking) {
            return { timeOut: true, score: 0, move: null };
        }
    }
    
    // 參數檢查
    if (!board || !playerTurn || playerTurn < 1 || playerTurn > 2) {
        console.error("Invalid virtualMinMax parameters:", playerTurn);
        return { score: 0, move: null };
    }
    
    // 達到搜索深度或遊戲結束
    if (depth === 0) {
        let score;
        try {
            // 從紅方視角評估局面
            score = virtualEvaluatePosition(board);
            
            // 如果是藍方在思考，翻轉評分
            if (playerTurn === 2) {
                score = -score;
            }
        } catch (e) {
            console.error("Error in evaluation:", e);
            score = 0;
        }
        return { score, move: null };
    }
    
    // 獲取可行走法
    let currentTurn = maximizingPlayer ? playerTurn : 3-playerTurn;
    let moves;
    try {
        moves = virtualGetMoves(board, currentTurn);
    } catch (e) {
        console.error("Error getting moves:", e);
        return { score: 0, move: null };
    }
    
    // 無棋可走
    if (!moves || moves.length === 0) {
        return { score: maximizingPlayer ? -999 : 999, move: null };
    }
    
    let bestMove = null;
    
    if (maximizingPlayer) {
        let maxEval = -Infinity;
        
        // 預先評估走法 - 特別關注能吃掉敵方棋子並使其少於2顆的走法
        if (depth > 2 && moves.length > 5) {
            let simpleMoves = [];
            for (let move of moves) {
                try {
                    let newBoard = virtualMove(board, ...move);
                    let { newBoard: afterEatBoard, eatCount } = virtualCheckEat(newBoard, move[2], move[3], playerTurn);
                    
                    // 檢查吃子後對方棋子是否會少於2個
                    let piecesAfterEat = virtualCountPieces(afterEatBoard);
                    let enemyPieces = piecesAfterEat[3-playerTurn];
                    
                    // 從紅方視角評估
                    let redViewScore = virtualEvaluatePosition(afterEatBoard);
                    
                    // 如果是藍方在思考，翻轉評分
                    let score = playerTurn === 2 ? -redViewScore : redViewScore;
                    
                    // 如果這個走法能讓對方棋子少於2顆，給予更高優先級
                    if (enemyPieces < 2) {
                        score = Infinity; // 必勝走法
                    }
                    
                    simpleMoves.push({ move, score, eatCount });
                } catch (e) {
                    console.error("Error in move evaluation:", e);
                }
            }
            
            if (simpleMoves.length > 0) {
                // 優先選擇將對方棋子減至少於2個的走法
                let victoryMoves = simpleMoves.filter(m => m.score === Infinity);
                if (victoryMoves.length > 0) {
                    // 有必勝走法，優先考慮
                    simpleMoves = victoryMoves;
                }
                
                simpleMoves.sort((a, b) => {
                    // 先按評分排序
                    if (b.score !== a.score) return b.score - a.score;
                    // 評分相同時，按吃子數排序
                    return b.eatCount - a.eatCount;
                });
                
                moves = simpleMoves.slice(0, Math.min(5, simpleMoves.length)).map(m => m.move);
            }
        }
        
        for (let move of moves) {
            try {
                // 模擬走子
                let newBoard = virtualMove(board, ...move);
                let { newBoard: afterEatBoard, eatCount } = virtualCheckEat(newBoard, move[2], move[3], playerTurn);
                
                // 檢查吃子後對方棋子是否會少於2個
                let piecesAfterEat = virtualCountPieces(afterEatBoard);
                if (piecesAfterEat[3-playerTurn] < 2) {
                    // 如果對方棋子少於2個，這是必勝走法
                    return { score: Infinity, move: move };
                }
                
                // 遞歸搜索
                let evalResult = virtualMinMax(afterEatBoard, depth - 1, alpha, beta, false, playerTurn, startTime, maxTime);
                
                // 檢查超時或中斷
                if (evalResult.timeOut) {
                    return { timeOut: true, score: maxEval, move: bestMove };
                }
                
                if (evalResult.score > maxEval) {
                    maxEval = evalResult.score;
                    bestMove = move;
                    
                    // 更新全局最佳走法
                    if (depth === 1) {
                        aiBestMoveSoFar = move;
                        // 每幾步更新一次UI評分（避免過於頻繁更新）
                        if (aiNodesEvaluated % 50 === 0) {
                            updateAiScoreDisplay(maxEval);
                        }
                    }
                }
                
                alpha = Math.max(alpha, maxEval);
                if (beta <= alpha) break; // Alpha-Beta剪枝
            } catch (e) {
                console.error("Error in maximizing player loop:", e);
            }
        }
        
        return { score: maxEval, move: bestMove };
    } else {
        let minEval = Infinity;
        
        // 評估優化走法分支 - 特別關注能吃掉敵方棋子並使其少於2顆的走法
        if (depth > 3 && moves.length > 5) {
            let simpleMoves = [];
            for (let move of moves) {
                try {
                    let newBoard = virtualMove(board, ...move);
                    let { newBoard: afterEatBoard, eatCount } = virtualCheckEat(newBoard, move[2], move[3], 3-playerTurn);
                    
                    // 檢查吃子後對方棋子是否會少於2個
                    let piecesAfterEat = virtualCountPieces(afterEatBoard);
                    let enemyPieces = piecesAfterEat[playerTurn];
                    
                    // 從紅方視角評估
                    let redViewScore = virtualEvaluatePosition(afterEatBoard);
                    
                    // 如果是藍方在思考，翻轉評分
                    let score = playerTurn === 2 ? redViewScore : -redViewScore;
                    
                    // 如果這個走法能讓對方棋子少於2顆，給予更高優先級
                    if (enemyPieces < 2) {
                        score = Infinity; // 必勝走法
                    }
                    
                    simpleMoves.push({ move, score, eatCount });
                } catch (e) {
                    console.error("Error in move evaluation:", e);
                }
            }
            
            if (simpleMoves.length > 0) {
                // 優先選擇將對方棋子減至少於2個的走法
                let victoryMoves = simpleMoves.filter(m => m.score === Infinity);
                if (victoryMoves.length > 0) {
                    // 有必勝走法，優先考慮
                    simpleMoves = victoryMoves;
                }
                
                simpleMoves.sort((a, b) => {
                    // 先按評分排序
                    if (b.score !== a.score) return b.score - a.score;
                    // 評分相同時，按吃子數排序
                    return b.eatCount - a.eatCount;
                });
                
                moves = simpleMoves.slice(0, Math.min(5, simpleMoves.length)).map(m => m.move);
            }
        }
        
        for (let move of moves) {
            try {
                // 模擬走子
                let newBoard = virtualMove(board, ...move);
                let { newBoard: afterEatBoard, eatCount } = virtualCheckEat(newBoard, move[2], move[3], 3-playerTurn);
                
                // 檢查吃子後對方棋子是否會少於2個
                let piecesAfterEat = virtualCountPieces(afterEatBoard);
                if (piecesAfterEat[playerTurn] < 2) {
                    // 如果對方棋子少於2個，這是必勝走法
                    return { score: -Infinity, move: move };
                }
                
                // 遞歸搜索
                let evalResult = virtualMinMax(afterEatBoard, depth - 1, alpha, beta, true, playerTurn, startTime, maxTime);
                
                // 檢查超時或中斷
                if (evalResult.timeOut) {
                    return { timeOut: true, score: minEval, move: bestMove };
                }
                
                if (evalResult.score < minEval) {
                    minEval = evalResult.score;
                    bestMove = move;
                }
                
                beta = Math.min(beta, minEval);
                if (beta <= alpha) break; // Alpha-Beta剪枝
            } catch (e) {
                console.error("Error in minimizing player loop:", e);
            }
        }
        
        return { score: minEval, move: bestMove };
    }
}

// 固定深度搜索
function fixedDepthSearch(exactDepth, maxTime) {
    let bestMove = null;
    let bestScore = -Infinity;
    let startTime = Date.now();
    aiNodesEvaluated = 0;
    
    // 設置AI思考狀態
    aiIsThinking = true;
    aiShouldStopThinking = false;
    aiBestMoveSoFar = null;
    aiMoveNowButton.disabled = false;
    aiMoveNowButton.innerText = "立即出招";
    
    try {
        // 創建虛擬棋盤
        let board = createVirtualBoard();
        
        console.log(`AI開始思考(固定深度: ${exactDepth}層, 時間限制: ${maxTime}ms)...`);
        
        // 先獲取所有可行走法
        let allMoves = virtualGetMoves(board, turn);
        if (!allMoves || allMoves.length === 0) {
            console.log("無合法走法");
            aiIsThinking = false;
            aiMoveNowButton.disabled = true;
            return null;
        }
        
        // 如果只有一種走法，直接執行
        if (allMoves.length === 1) {
            console.log("只有一種走法，直接執行");
            
            // 記住這次的走法，用於變招功能
            lastAiMove = allMoves[0];
            
            // 執行這個唯一的走法
            if (isValidMove(allMoves[0])) {
                aiIsThinking = false;
                aiMoveNowButton.disabled = true;
                executeAiMove(allMoves[0]);
            } else {
                console.error("AI選擇的唯一走法無效:", allMoves[0]);
            }
            return null;
        }
        
        // 優先考慮能直接吃到對方棋子少於2個的走法
        let victoryMoves = [];
        for (let move of allMoves) {
            if (!isValidMove(move)) {
                console.error("發現無效走法:", move);
                continue;
            }
            
            let newBoard = virtualMove(board, ...move);
            let { newBoard: afterEatBoard, eatCount } = virtualCheckEat(newBoard, move[2], move[3], turn);
            
            // 檢查吃子後對方棋子數量
            let piecesAfterEat = virtualCountPieces(afterEatBoard);
            if (piecesAfterEat[3-turn] < 2) {
                victoryMoves.push(move);
            }
        }
        
        // 如果有能直接獲勝的走法，直接選擇
        if (victoryMoves.length > 0) {
            console.log("發現能直接獲勝的走法，跳過深度搜索");
            bestMove = victoryMoves[0];
            aiIsThinking = false;
            aiMoveNowButton.disabled = true;
            lastAiMove = bestMove;
            executeAiMove(bestMove);
            return null;
        }
        
        // 進行固定深度搜索
        console.log(`執行${exactDepth}層深度的搜索...`);
        
        // 每10ms讓出主線程，確保UI可以響應
        function processNextMove(index) {
            if (index >= allMoves.length || aiShouldStopThinking) {
                // 所有走法都處理完或搜索被中斷
                let timeUsed = Date.now() - startTime;
                console.log(`AI思考完成：評估了 ${aiNodesEvaluated} 個節點，耗時 ${timeUsed}ms`);
                
                // 如果沒找到有效走法，可能是因為所有走法都被過濾了，重試一次，不進行過濾
                if (!bestMove) {
                    if (lastAiMove) {
                        console.log("找不到新走法，重新搜索不進行變招過濾");
                        lastAiMove = null; // 清除變招限制
                        aiIsThinking = false;
                        aiMoveNowButton.disabled = true;
                        
                        // 使用setTimeout避免遞歸調用堆棧溢出
                        setTimeout(() => {
                            aiMakeDecision(exactDepth);
                        }, 0);
                        return;
                    } else if (aiBestMoveSoFar) {
                        // 使用搜索過程中找到的最佳走法
                        bestMove = aiBestMoveSoFar;
                        console.log(`未找到最佳走法，使用搜索過程中的最佳結果: [${bestMove?.join(', ')}]`);
                    } else if (allMoves.length > 0) {
                        // 如果實在沒有，就使用第一個合法走法
                        for (let move of allMoves) {
                            if (isValidMove(move)) {
                                bestMove = move;
                                console.log(`未找到評估走法，使用第一個有效走法: [${bestMove?.join(', ')}]`);
                                break;
                            }
                        }
                        
                        // 如果還是沒有有效走法，打印警告並返回
                        if (!bestMove) {
                            console.error("無法找到有效走法！");
                            aiIsThinking = false;
                            aiMoveNowButton.disabled = true;
                            return;
                        }
                    }
                }
                
                console.log(`最終選擇走法: [${bestMove?.join(', ')}], 分數: ${bestScore}`);
                updateAiScoreDisplay(bestScore);
                
                aiIsThinking = false;
                aiMoveNowButton.disabled = true;
                
                // 記住這次的走法，用於變招功能
                lastAiMove = bestMove;
                
                if (bestMove && isValidMove(bestMove)) {
                    executeAiMove(bestMove);
                } else {
                    console.error("AI選擇的最佳走法無效:", bestMove);
                }
                return;
            }
            
            let move = allMoves[index];
            
            // 如果這個走法就是上一次的走法，跳過它（變招功能）
            if (lastAiMove && 
                lastAiMove[0] === move[0] && lastAiMove[1] === move[1] && 
                lastAiMove[2] === move[2] && lastAiMove[3] === move[3]) {
                console.log(`跳過上一次的走法: ${move.join(', ')}`);
                setTimeout(() => processNextMove(index + 1), 10);
                return;
            }
            
            try {
                // 模擬走子
                let newBoard = virtualMove(board, ...move);
                let { newBoard: afterEatBoard, eatCount } = virtualCheckEat(newBoard, move[2], move[3], turn);
                
                // 檢查吃子後對方棋子數量
                let piecesAfterEat = virtualCountPieces(afterEatBoard);
                if (piecesAfterEat[3-turn] < 2) {
                    // 如果這個走法能直接獲勝，選擇它
                    console.log(`找到能直接獲勝的走法: [${move.join(', ')}]`);
                    bestMove = move;
                    bestScore = Infinity;
                    setTimeout(() => processNextMove(allMoves.length), 0); // 直接結束搜索
                    return;
                }
                
                // 進行深度搜索
                let result = virtualMinMax(afterEatBoard, exactDepth - 1, -Infinity, Infinity, false, turn, startTime, maxTime);
                
                // 檢查是否超時或中斷
                if (result.timeOut) {
                    console.log("搜索超時或中斷，使用已找到的最佳走法");
                    setTimeout(() => processNextMove(allMoves.length), 0); // 直接結束搜索
                    return;
                }
                
                let score = result.score;
                console.log(`走法 [${move.join(', ')}] 的評分: ${score}, 吃子數: ${eatCount}`);
                
                // 更新最佳走法
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                    aiBestMoveSoFar = move;
                    console.log(`找到更好的走法: [${bestMove.join(', ')}], 評分: ${bestScore}`);
                    updateAiScoreDisplay(bestScore);
                }
                
                // 處理下一個走法，但讓出主線程
                setTimeout(() => processNextMove(index + 1), 10);
            } catch (e) {
                console.error(`評估走法 [${move.join(', ')}] 時出錯:`, e);
                setTimeout(() => processNextMove(index + 1), 10);
            }
        }
        
        // 開始處理第一個走法
        processNextMove(0);
        
        // 返回null，實際走法將在processNextMove中執行
        return null;
    } catch (e) {
        console.error("Error in fixedDepthSearch:", e);
        
        aiIsThinking = false;
        aiMoveNowButton.disabled = true;
        
        // 錯誤恢復：選擇第一個合法走法
        let moves = checkMove(turn);
        if (moves && moves.length > 0) {
            for (let move of moves) {
                if (isValidMove(move)) {
                    console.log("錯誤恢復：選擇第一個有效走法");
                    executeAiMove(move);
                    break;
                }
            }
        }
        return null;
    }
}

function changeMapTo( map = [] ) // 改變當前局面 map: 2D Array
{
        if( !map.length ) return ;
        
        let cell ; // 當前 棋格
        let owner ; // 當前 棋格 擁有者
        for(let y = 0 ; y < map.length ; ++y )
        {
                for(let x = 0 ; x < map[y].length ; ++x )
                {
                        cell = document.getElementById(`cell_${y}_${x}`) ; // 當前 棋格
                        if (!cell) continue; // 確保棋格存在
                        
                        owner = map[y][x] ; // 當前 棋格 擁有者
                        
                        cell.dataset.owner = owner ; // 改變 棋格擁有者
                        cell.style.color = ownerColor[owner] ; // 改變 顏色
                        cell.innerText = ~~owner ? piece : '' ; // 改變 棋格字樣
                }
        }
    
    renewPlayerScore(false); // 重新計算並輸出分數
}

function getMap() // 暫存當前局面(取得每個棋格的擁有者 組成的 2D Array)
{
        let map = [] ;
        let cell ; // 當前 棋格
        for(let y = 0 ; y < mapSize[0] ; ++y )
        {
                map[y] = [] ;
                for(let x = 0 ; x < mapSize[1] ; ++x )
                {
                        cell = document.getElementById(`cell_${y}_${x}`) ; // 當前 棋格
                        if (cell) {
                                map[y][x] = ~~cell.dataset.owner ; // 取得 棋格擁有者
                        } else {
                                map[y][x] = 0; // 如果元素不存在，默認為公地
                        }
                }
        }
        
        return map ; // 2D Array
}

function renewPlayerScore( justOutput = false , output = true ) // 更新 玩家分數
{
        if(!justOutput)
        {
                ownerCurrentPoint.fill(0) ; // 重置 玩家分數
                                                        
                // 統計 各玩家 的 分數
                for(let y of table.childNodes )
                {
                        for(let x of y.childNodes )
                        {
                                ownerCurrentPoint[x.dataset.owner] += !!x.dataset.owner ;
                        }
                }
        }

        if(output)
        {
                let point2htm = '' ; // 玩家分數 字串
                for(let i = 1 ; i < ownerCurrentPoint.length ; ++i )
                {
                        i > 1 && ( point2htm += ' vs ' ) ;
                        point2htm += `<font color="${ownerColor[i]}">${ownerCurrentPoint[i]}<\/font>` ;
                }
                showPlayerScore.innerHTML = point2htm ; // 輸出 玩家分數
        }
}

function checkEndGame(quiet=false) // 檢查是否結束遊戲
{
        let loser = ownerCurrentPoint.slice(1).indexOf(1) + 1 ; // 尋找 剛好有1隻棋子 的人
        loser || ( loser = ownerCurrentPoint.slice(1).indexOf(0) + 1 ) ; // 尋找 剛好有0隻棋子 的人
        loser || checkMove( turn ).length || ( loser = turn ) ; // 檢查己方是否欠行

        if( loser ) // 有敗方
        {
                quiet || alert( ownerName[3-loser] + ' 獲勝' ) ; // 顯示誰獲勝
                turn = -1 ; // 遊戲結束
                showWhoTurn.innerText = ownerName[0] ; // 清空 輪到誰下 (字)
                showWhoTurn.style.color = ownerColor[0] ; // 清空 輪到誰下 (色)
                showNotEat.innerText = '0' ; // 無吃子步數 清0
                
                if( takedCell ) // 如有抓子
                {
                        // 還原棋格背景色
                        takedCell.bgColor = cellBgColor[ ( ~~takedCell.dataset.y + ~~takedCell.dataset.x ) % 2 ] ;
                        
                        takedCellPos = [-1,-1] ; // 重置抓子 座標
                        takedCell = null ; // 清空 抓子格
                }
        
        // 如果有上一步高亮，清除它
        if (lastMoveInfo) {
            clearLastMoveHighlight();
        }
        
        // 更新回顧按鈕和變招按鈕
        updateReviewButtonsState();
        updateChangeMoveButtonState();
                
                return true ;
        }
        else return false ;
}

function canMove( fromY , fromX , toY , toX ) // 檢查是否合法棋步 [ fromY , fromX ] -> [ toY , toX ]
{
        if( arguments.length < 4 ) return ;

        // 數字化
        fromY = ~~fromY ;
        fromX = ~~fromX ;
        toY = ~~toY ;
        toX = ~~toX ;

        let roadClear = false ; // 道路是否暢通

        let sameY = toY - fromY ; // 0 = 移動時 y 座標不變
        let sameX = toX - fromX ; // 0 = 移動時 x 座標不變
        if( !sameY != !sameX ) // 目標格 為 抓子的上下左右方向的範圍
        {
                roadClear = true ; // 道路是否暢通
                let checkCell ; // 當前檢查 的 棋格
                let y = toY ; // 當前檢查棋格的 y座標
                let x = toX ; // 當前檢查棋格的 x座標

                if(sameY) // 上下移動
                {
                        for(let y = toY ; y != fromY ; y -= Math.sign(sameY) )
                        {
                                checkCell = document.getElementById(`cell_${y}_${x}`) ; // 當前檢查 的 棋格
                if (!checkCell) continue; // 確保棋格存在
                                ~~checkCell.dataset.owner && ( roadClear = false ) ; // 有棋子阻擋就不准移動
                        }
                }
                else // 左右移動
                {
                        for(let x = toX ; x != fromX ; x -= Math.sign(sameX) )
                        {
                                checkCell = document.getElementById(`cell_${y}_${x}`) ; // 當前檢查 的 棋格
                if (!checkCell) continue; // 確保棋格存在
                                ~~checkCell.dataset.owner && ( roadClear = false ) ; // 有棋子阻擋就不准移動
                        }
                }
        }
        return roadClear ; // 返回 是否合法棋步 (真假值)
}

function toMove( fromY , fromX , toY , toX ) // 移動棋子(不檢查是否合法棋步) [ fromY , fromX ] -> [ toY , toX ]
{
        if( arguments.length < 4 ) return ;

        let fromCell = document.getElementById(`cell_${fromY}_${fromX}`) ; // 來源棋格
        let toCell = document.getElementById(`cell_${toY}_${toX}`) ; // 目標棋格
    
    // 確保棋格存在
    if (!fromCell || !toCell) return;

        // 移動棋子
        toCell.innerText = piece ; // 把棋子 轉移到 目標棋格
        toCell.dataset.owner = fromCell.dataset.owner ; // 改變 目標棋格 擁有者 為 己方
        toCell.style.color = ownerColor[fromCell.dataset.owner] ; // 改變 目標棋子 顏色 為 己方

        fromCell.innerText = '' ; // 清空 來源棋格
        fromCell.dataset.owner = 0 ; // 來源棋格 變為公地
}

function checkEat( downY , downX , turn , take = false ) // 檢查食棋
{       // 返回能食多少隻棋 , [downY,downX] = 落子座標[y,x] , turn = 落子者 , take = 是否提子
        if( arguments.length < 3 ) return ;

        // let downCell = document.getElementById(`cell_${downY}_${downX}`) ; // 落子棋格
        // let turn = downCell.dataset.owner ; // 落子者

        // 數字化
        downY = ~~downY ;
        downX = ~~downX ;

        // 食棋規則
        let eatList = [] ; // 被食棋子的棋格
        let chkList = [] ; // 暫時記錄的敵方棋子格(可能被食棋的棋格)
        let y , x ; // 當前檢查棋格的 y,x 座標
        let checkCell ; // 當前檢查 的 棋格

        // 檢查棋格有冇棋食 (上)
        y = downY - 1 ; // 當前檢查棋格的 y座標
        x = downX ; // 當前檢查棋格的 x座標
        while( y >= 0 )
        {
                checkCell = document.getElementById(`cell_${y}_${x}`) ; // 當前檢查 的 棋格
        if (!checkCell) break; // 確保棋格存在
        
                if( checkCell.dataset.owner == 3 - turn ) // 檢查 的 棋格 為 敵方
                {
                        if(y)
                        {
                                chkList.push(checkCell) ; // 加到 可能被食棋的棋格 清單
                        }
                        else
                        {
                                chkList = [] ; // 沒有棋食
                        }
                        --y ; // 繼續檢查上面一格
                }
                else if( checkCell.dataset.owner == 0 ) // 檢查 的 棋格 為 公地
                {
                        chkList = [] ; // 沒有棋食
                        y = -1 ; // 短路
                }
                else // 檢查 的 棋格 為 己方
                {
                        y = -1 ; // 短路
                }
        }
        eatList.push(...chkList) ;
        
        // 檢查棋格有冇棋食 (下)
        y = downY + 1 ; // 當前檢查棋格的 y座標
        chkList = [] ; // 清空
        while( y < mapSize[0] )
        {
                checkCell = document.getElementById(`cell_${y}_${x}`) ; // 當前檢查 的 棋格
        if (!checkCell) break; // 確保棋格存在
        
                if( checkCell.dataset.owner == 3 - turn ) // 檢查 的 棋格 為 敵方
                {
                        if( y < mapSize[0] - 1 )
                        {
                                chkList.push(checkCell) ; // 加到 可能被食棋的棋格 清單
                        }
                        else
                        {
                                chkList = [] ; // 沒有棋食
                        }
                        ++y ; // 繼續檢查下面一格
                }
                else if( checkCell.dataset.owner == 0 ) // 檢查 的 棋格 為 公地
                {
                        chkList = [] ; // 沒有棋食
                        y = mapSize[0] ; // 短路
                }
                else // 檢查 的 棋格 為 己方
                {
                        y = mapSize[0] ; // 短路
                }
        }
        eatList.push(...chkList) ;
        
        // 檢查棋格有冇棋食 (左)
        y = downY ; // 當前檢查棋格的 y座標
        x = downX - 1  ; // 當前檢查棋格的 x座標
        chkList = [] ; // 清空
        while( x >= 0 )
        {
                checkCell = document.getElementById(`cell_${y}_${x}`) ; // 當前檢查 的 棋格
        if (!checkCell) break; // 確保棋格存在
        
                if( checkCell.dataset.owner == 3 - turn ) // 檢查 的 棋格 為 敵方
                {
                        if(x)
                        {
                                chkList.push(checkCell) ; // 加到 可能被食棋的棋格 清單
                        }
                        else
                        {
                                chkList = [] ; // 沒有棋食
                        }
                        --x ; // 繼續檢查左面一格
                }
                else if( checkCell.dataset.owner == 0 ) // 檢查 的 棋格 為 公地
                {
                        chkList = [] ; // 沒有棋食
                        x = -1 ; // 短路
                }
                else // 檢查 的 棋格 為 己方
                {
                        x = -1 ; // 短路
                }
        }
        eatList.push(...chkList) ;
        
        // 檢查棋格有冇棋食 (右)
        x = downX + 1 ; // 當前檢查棋格的 x座標
        chkList = [] ; // 清空
        while( x < mapSize[1] )
        {
                checkCell = document.getElementById(`cell_${y}_${x}`) ; // 當前檢查 的 棋格
        if (!checkCell) break; // 確保棋格存在
        
                if( checkCell.dataset.owner == 3 - turn ) // 檢查 的 棋格 為 敵方
                {
                        if( x < mapSize[1] - 1 )
                        {
                                chkList.push(checkCell) ; // 加到 可能被食棋的棋格 清單
                        }
                        else
                        {
                                chkList = [] ; // 沒有棋食
                        }
                        ++x ; // 繼續檢查右面一格
                }
                else if( checkCell.dataset.owner == 0 ) // 檢查 的 棋格 為 公地
                {
                        chkList = [] ; // 沒有棋食
                        x = mapSize[1] ; // 短路
                }
                else // 檢查 的 棋格 為 己方
                {
                        x = mapSize[1] ; // 短路
                }
        }
        eatList.push(...chkList) ;
        
        if( take && eatList.length ) // 提子
        {
                for(let i = 0 , dieCell ; i < eatList.length ; ++i)
                {
                        dieCell = eatList[i] ; // 死子的棋格
                        dieCell.innerText = '' ; // 清空 死子棋格
                        dieCell.dataset.owner = 0 ; // 改變 死子棋格 擁有者 為 公地
                        dieCell.style.color = ownerColor[0] ; // 改變 死子 顏色 為 公地
                }
        }
        return eatList.length ; // 返回能食多少隻棋
}

function checkMove( who ) // 檢查一方 當前的所有合法棋步 (沒有=欠行)
{
        if( !who ) return ;

        // let moveAmount = 0 ; // 有多少合法棋步
        let okMove = [] ; // 合法棋步
        let checkedAmount = 0 ; // 已檢查了該方多少隻棋
        let cell ; // 當前檢查 的 來源棋格
        

        // 檢查走法 [y,x] -> [Y,X]
        for(let y = 0 ; y < mapSize[0] ; ++y )
        {
                for(let x = 0 ; x < mapSize[1] ; ++x )
                {
                        if( checkedAmount >= ownerCurrentPoint[who] ) break ;
                        cell = document.getElementById(`cell_${y}_${x}`) ;
            if (!cell) continue; // 確保棋格存在
            
                        if( cell.dataset.owner == who ) // 是該方的棋子
                        {
                                for(let Y = 0 ; Y < mapSize[0] ; ++Y )
                                {
                                        for(let X = 0 ; X < mapSize[1] ; ++X )
                                        {
                                                // moveAmount += canMove( y , x , Y , X ) ; // 計 合法棋步
                                                canMove( y , x , Y , X ) && okMove.push( [ y , x , Y , X ] ) ;
                                        }
                                }
                        }
                }
        }
        return okMove ; // 返回 有多少合法棋步
}

// 清除上一步高亮
function clearLastMoveHighlight() {
    if (!lastMoveInfo) return;
    
    // 清除起點
    let fromCell = document.getElementById(`cell_${lastMoveInfo[0]}_${lastMoveInfo[1]}`);
    if (fromCell) {
        fromCell.bgColor = cellBgColor[(~~fromCell.dataset.y + ~~fromCell.dataset.x) % 2];
    }
    
    // 清除終點
    let toCell = document.getElementById(`cell_${lastMoveInfo[2]}_${lastMoveInfo[3]}`);
    if (toCell) {
        toCell.bgColor = cellBgColor[(~~toCell.dataset.y + ~~toCell.dataset.x) % 2];
    }
    
    lastMoveInfo = null;
}

// 設置上一步高亮
function setLastMoveHighlight(fromY, fromX, toY, toX) {
    // 先清除之前的高亮
    clearLastMoveHighlight();
    
    // 設置新的高亮
    let toCell = document.getElementById(`cell_${toY}_${toX}`);
    if (toCell) {
        toCell.bgColor = lastMoveHighlight;
    }
    
    // 保存這一步的信息
    lastMoveInfo = [fromY, fromX, toY, toX];
}

// AI決策主函數 - 嚴格按層數思考版本
function aiMakeDecision(searchDepth) {
    try {
        // 解析搜索深度
        let depth = parseInt(searchDepth);
        
        // 檢查深度是否有效
        if (isNaN(depth) || depth < 1) {
            console.error("無效的搜索深度:", searchDepth);
            depth = 1;
        }
        
        console.log(`AI(${ownerName[turn]})開始思考，指定深度：${depth}層`);
        
        // 獲取時間限制
        let timeLimit = getAiThinkingTimeLimit();
        
        // 直接使用指定深度進行搜索
        fixedDepthSearch(depth, timeLimit);
        
        // 由於fixedDepthSearch已經進行了非阻塞處理，這裡不需要返回任何值
        return null;
    } catch (e) {
        console.error("AI決策錯誤:", e);
        aiIsThinking = false;
        aiMoveNowButton.disabled = true;
        
        // 錯誤恢復：選擇第一個合法走法
        let moveList = checkMove(turn);
        if (moveList && moveList.length > 0) {
            executeAiMove(moveList[0]);
        }
        return null;
    }
}

// 健壯的AI執行函數
function executeAiMove(decision) {
    if (!decision) {
        console.error("AI走子錯誤：沒有決策");
        return;
    }
    
    try {
        console.log(`AI決定棋步: ${decision[0]},${decision[1]} -> ${decision[2]},${decision[3]}`);
        
        // 檢查起點和終點是否存在
        let fromCell = document.getElementById(`cell_${decision[0]}_${decision[1]}`);
        let toCell = document.getElementById(`cell_${decision[2]}_${decision[3]}`);
        
        if (!fromCell || !toCell) {
            console.error("AI走子錯誤：棋格不存在");
            return;
        }
        
        // 檢查起點是否是己方棋子
        if (fromCell.dataset.owner != turn) {
            console.error(`AI走子錯誤：起點不是己方棋子，起點所有者=${fromCell.dataset.owner}，當前回合=${turn}`);
            return;
        }
        
        // 檢查終點是否為空
        if (toCell.dataset.owner != 0) {
            console.error("AI走子錯誤：終點不是空格");
            return;
        }
        
        // 檢查移動是否合法
        if (!canMove(decision[0], decision[1], decision[2], decision[3])) {
            console.error("AI走子錯誤：走法不合法");
            return;
        }
        
        // 模擬點擊來源棋格
        takedCell = fromCell;
        takedCellPos[0] = decision[0];
        takedCellPos[1] = decision[1];
        takedCell.bgColor = takedCellColor;
        
        // 短暫延遲後模擬點擊目標棋格
        setTimeout(function() {
            clickCell(toCell);
            
            // 設置上一步高亮
            setLastMoveHighlight(decision[0], decision[1], decision[2], decision[3]);
            
            // 恢復UI可用
            setRedIsAiCheckbox.disabled = false;
            setBlueIsAiCheckbox.disabled = false;
            
            // 更新變招按鈕狀態
            updateChangeMoveButtonState();
        }, 300);
    } catch (e) {
        console.error("Error executing AI move:", e);
        
        // 恢復UI可用
        setRedIsAiCheckbox.disabled = false;
        setBlueIsAiCheckbox.disabled = false;
        
        // 重置抓子狀態
        if (takedCell) {
            takedCell.bgColor = cellBgColor[(~~takedCell.dataset.y + ~~takedCell.dataset.x) % 2];
            takedCell = null;
            takedCellPos = [-1, -1];
        }
    }
}

function checkAiTurn() // 檢查是否輪到 AI 走子
{
    // 在回顧模式下不讓AI走子
    if (isReviewMode) return;
    
    // 檢查當前是否輪到AI
    let isAiTurn = (turn === 1 && setRedIsAiCheckbox.checked) || 
                  (turn === 2 && setBlueIsAiCheckbox.checked);
                  
    if (turn !== -1 && isAiTurn) {
        // 選擇當前玩家的AI難度
        let aiLevel = turn === 1 ? 
                    setRedAiLevel.value : 
                    setBlueAiLevel.value;
        
        // 禁用UI，防止用戶在AI思考時操作
        setRedIsAiCheckbox.disabled = true;
        setBlueIsAiCheckbox.disabled = true;
        
        // 執行AI決策
        setTimeout(function() {
            try {
                aiMakeDecision(aiLevel);
            } catch (e) {
                console.error("AI思考錯誤:", e);
                setRedIsAiCheckbox.disabled = false;
                setBlueIsAiCheckbox.disabled = false;
            }
        }, aiSleepTime);
    }
    
    // 更新變招按鈕狀態
    updateChangeMoveButtonState();
}

function clickCell(cell) // 點擊 棋格 時
{
    if (!cell) return; // 確保棋格存在
    
    // 在回顧模式下不允許走子
    if (isReviewMode) return;
    
        if( takedCell ) // 已有 抓住的棋子
        {
                if( canMove( ...takedCellPos , cell.dataset.y , cell.dataset.x ) )
                {       // 合法棋步
            // 保存走子信息用於高亮
            let fromY = takedCellPos[0];
            let fromX = takedCellPos[1];
            let toY = parseInt(cell.dataset.y);
            let toX = parseInt(cell.dataset.x);
            
                        toMove( ...takedCellPos , cell.dataset.y , cell.dataset.x ) ; // 走子
            
            // 設置上一步高亮
            setLastMoveHighlight(fromY, fromX, toY, toX);
            
                        if ( checkEat( cell.dataset.y , cell.dataset.x , turn , true ) ) // 有棋食
                        {
                                showNotEat.innerText = '0' ; // 無吃子步數 清0
                                renewPlayerScore() ; // 更新 並 輸出 玩家分數
                        }
                        else // 冇棋食
                        {
                                if( !( ++ showNotEat.innerText - notEatToDraw ) ) // 無吃子步數 +1
                                {       // 達到上限 則判和
                                        if( ownerCurrentPoint[1] == ownerCurrentPoint[2] )
                                        {
                                                alert( '無進展判和。' ) ;
                                        }
                                        else
                                        {
                                                alert( `到達步數限制，${ ownerCurrentPoint[1] > ownerCurrentPoint[2] ? ownerName[1] : ownerName[2] } 獲勝。` ) ;
                                        }

                                        turn = -1 ; // 遊戲結束
                                        showWhoTurn.innerText = ownerName[0] ; // 清空 輪到誰下 (字)
                                        showWhoTurn.style.color = ownerColor[0] ; // 清空 輪到誰下 (色)
                                        
                                        // 還原棋格背景色
                                        takedCell.bgColor = cellBgColor[ ( ~~takedCell.dataset.y + ~~takedCell.dataset.x ) % 2 ] ;
                                        
                                        takedCellPos = [-1,-1] ; // 重置抓子 座標
                                        takedCell = null ; // 清空 抓子格
                                        
                                        return ;
                                }
                        }

                        turn = 3 - turn ; // 輪到對方下棋
                        if( checkEndGame() ) return ; // 檢查是否結束遊戲
                        turn - 1 || ++showRounds.innerText ; // 輸出 回合數
                        showWhoTurn.innerText = ownerName[turn] ; // 輸出輪到誰下 (字)
                        showWhoTurn.style.color = ownerColor[turn] ; // 輸出輪到誰下 (色)
            
            // 記錄新狀態
            recordCurrentBoardState();
            
            // 更新變招按鈕狀態
            updateChangeMoveButtonState();
                }

                // 取消抓子
                takedCell.bgColor = cellBgColor[ ( ~~takedCell.dataset.y + ~~takedCell.dataset.x ) % 2 ] ; // 還原棋格背景色
                takedCell = null ; // 重置 抓子 的格子
                takedCellPos[0] = -1 ; // 重置 抓子座標 y
                takedCellPos[1] = -1 ; // 重置 抓子座標 x
                
                setTimeout( checkAiTurn , aiSleepTime ) ; // 檢查是否輪到 AI
        }
        else // 當前 沒有 抓住的棋子
        {
                if( cell.dataset.owner != turn ) return ; // 不是輪到他走
                
                takedCell = cell ; // 記錄 抓子 的格子
                takedCellPos[0] = ~~cell.dataset.y ; // 記錄 抓子 的 y座標
                takedCellPos[1] = ~~cell.dataset.x ; // 記錄 抓子 的 x座標
                cell.bgColor = takedCellColor ; // 標記 抓子 的 棋格 (上色)
        }
}

function cellInfo(cell) // 棋格資訊
{
    if (!cell) return; // 確保棋格存在
    
        let targetCellOwner = ~~cell.dataset.owner ; 

        let txt = `已選棋格: ( ${ takedCell ? takedCellPos.join(' , ') : '沒有' } )` ;
        txt += `\n目標棋格: ( ${cell.dataset.y} , ${cell.dataset.x} )` ;
        txt += `\n${ !targetCellOwner ? '沒有' : targetCellOwner - turn ? '敵方' : '己方' }棋子` ;
        canMove( ...takedCellPos , cell.dataset.y , cell.dataset.x ) && ( txt += `\n可移動` ) ;
        showCellInfo.innerText = txt ;
}

function help() // 說明
{
        let txt = '遊戲規則如下：' ;
        txt += '\n1) 棋子移動方式：十字形，即上下左右無阻擋，走多遠都可以。' ;
        txt += '\n2) 當己方移動棋子後，在同一行或同一列，己方棋子從兩旁夾住對方棋子(沒有空格)，則把對方棋子吃掉(可吃多於一子)。' ;
        txt += '\n3) 己方棋子可以走到被對方夾住的棋格，不會被吃掉。' ;
        txt += '\n4) 先剩下少於2隻棋子的一方為敗方。' ;
        txt += '\n5) 當到達無吃子限步，剩餘棋子較多的一方勝出。' ;
        txt += '\n6) 欠行作負。' ;
        txt += '\n7) 長捉作負。' ;
        alert(txt);
}

// 當改變AI設定時，檢查是否輪到AI走棋
setRedIsAiCheckbox.setAttribute('onchange', 'checkAiTurn();');
setBlueIsAiCheckbox.setAttribute('onchange', 'checkAiTurn();');

// 初始化回顧按鈕和變招按鈕
updateReviewButtonsState();
updateChangeMoveButtonState();

// code End here
</script>

<center>
<br />
<hr />
Coded by ~tyovery~<br />2025-02
</center>

<script>
// timer
timerEnd=Date.now();
document.write('<p style="font-size: 12px;">Load Time: '+(timerEnd-timerBegin)+'ms</p>');
// timer
</script>

</body>
</html>
